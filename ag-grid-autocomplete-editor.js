!function(g,I){if("object"==typeof exports&&"object"==typeof module)module.exports=I(require("ag-grid-community"));else if("function"==typeof define&&define.amd)define(["ag-grid-community"],I);else{var C="object"==typeof exports?I(require("ag-grid-community")):I(g["ag-grid-community"]);for(var t in C)("object"==typeof exports?exports:g)[t]=C[t]}}(window,function(__WEBPACK_EXTERNAL_MODULE__0__){return function(g){var I={};function C(t){if(I[t])return I[t].exports;var e=I[t]={i:t,l:!1,exports:{}};return g[t].call(e.exports,e,e.exports,C),e.l=!0,e.exports}return C.m=g,C.c=I,C.d=function(g,I,t){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:t})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var t=Object.create(null);if(C.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var e in g)C.d(t,e,function(I){return g[I]}.bind(null,e));return t},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="http://localhost:8080/",C(C.s=2)}([function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImFnLWdyaWQtY29tbXVuaXR5XCI/ODc0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzBfXzsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FnLWdyaWQtYXV0b2NvbXBsZXRlLWVkaXRvci5zY3NzP2E4NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external "ag-grid-community"\nvar external_ag_grid_community_ = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./ag-grid-autocomplete-editor.scss\nvar ag_grid_autocomplete_editor = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./autocompleter/autocomplete.ts\n/*\r\n * https://github.com/kraaden/autocomplete\r\n * Copyright (c) 2016 Denys Krasnoshchok\r\n * MIT License\r\n */\r\nfunction autocomplete(settings) {\r\n    // just an alias to minimize JS file size\r\n    var doc = document;\r\n    var container = doc.createElement("div");\r\n    var containerStyle = container.style;\r\n    var userAgent = navigator.userAgent;\r\n    var mobileFirefox = userAgent.indexOf("Firefox") !== -1 && userAgent.indexOf("Mobile") !== -1;\r\n    var debounceWaitMs = settings.debounceWaitMs || 0;\r\n    var strict = settings.strict;\r\n    var autoselectfirst = settings.autoselectfirst;\r\n    var onFreeTextSelect = settings.onFreeTextSelect;\r\n    // \'keyup\' event will not be fired on Mobile Firefox, so we have to use \'input\' event instead\r\n    var keyUpEventName = mobileFirefox ? "input" : "keyup";\r\n    var items = [];\r\n    var inputValue = "";\r\n    var minLen = settings.minLength || 2;\r\n    var selected;\r\n    var keypressCounter = 0;\r\n    var debounceTimer;\r\n    if (!settings.input) {\r\n        throw new Error("input undefined");\r\n    }\r\n    var input = settings.input;\r\n    container.className = "autocomplete " + (settings.className || "");\r\n    containerStyle.position = "fixed";\r\n    /**\r\n     * Detach the container from DOM\r\n     */\r\n    function detach() {\r\n        var parent = container.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(container);\r\n        }\r\n    }\r\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\r\n    function clearDebounceTimer() {\r\n        if (debounceTimer) {\r\n            window.clearTimeout(debounceTimer);\r\n        }\r\n    }\r\n    /**\r\n     * Attach the container to DOM\r\n     */\r\n    function attach() {\r\n        if (!container.parentNode) {\r\n            doc.body.appendChild(container);\r\n        }\r\n    }\r\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\r\n    function containerDisplayed() {\r\n        return !!container.parentNode;\r\n    }\r\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\r\n    function clear() {\r\n        keypressCounter++;\r\n        items = [];\r\n        inputValue = "";\r\n        selected = undefined;\r\n        detach();\r\n    }\r\n    /**\r\n     * Update autocomplete position\r\n     */\r\n    function updatePosition() {\r\n        if (!containerDisplayed()) {\r\n            return;\r\n        }\r\n        containerStyle.height = "auto";\r\n        containerStyle.width = input.offsetWidth + "px";\r\n        var inputRect = input.getBoundingClientRect();\r\n        var top = inputRect.top + input.offsetHeight;\r\n        var maxHeight = window.innerHeight - top;\r\n        if (maxHeight < 0) {\r\n            maxHeight = 0;\r\n        }\r\n        containerStyle.top = top + "px";\r\n        containerStyle.bottom = "";\r\n        containerStyle.left = inputRect.left + "px";\r\n        containerStyle.maxHeight = maxHeight + "px";\r\n        if (settings.customize) {\r\n            settings.customize(input, inputRect, container, maxHeight);\r\n        }\r\n    }\r\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\r\n    function update() {\r\n        // delete all children from autocomplete DOM container\r\n        while (container.firstChild) {\r\n            container.removeChild(container.firstChild);\r\n        }\r\n        // function for rendering autocomplete suggestions\r\n        var render = function (item, currentValue) {\r\n            var itemElement = doc.createElement("div");\r\n            itemElement.textContent = item.label || "";\r\n            return itemElement;\r\n        };\r\n        if (settings.render) {\r\n            render = settings.render;\r\n        }\r\n        // function to render autocomplete groups\r\n        var renderGroup = function (groupName, currentValue) {\r\n            var groupDiv = doc.createElement("div");\r\n            groupDiv.textContent = groupName;\r\n            return groupDiv;\r\n        };\r\n        if (settings.renderGroup) {\r\n            renderGroup = settings.renderGroup;\r\n        }\r\n        var fragment = doc.createDocumentFragment();\r\n        var prevGroup = "#9?$";\r\n        items.forEach(function (item) {\r\n            if (item.group && item.group !== prevGroup) {\r\n                prevGroup = item.group;\r\n                var groupDiv = renderGroup(item.group, inputValue);\r\n                if (groupDiv) {\r\n                    groupDiv.className += " group";\r\n                    fragment.appendChild(groupDiv);\r\n                }\r\n            }\r\n            var div = render(item, inputValue);\r\n            if (div) {\r\n                div.addEventListener("click", function (ev) {\r\n                    settings.onSelect(item, input);\r\n                    clear();\r\n                    ev.preventDefault();\r\n                    ev.stopPropagation();\r\n                });\r\n                if (item === selected) {\r\n                    div.className += " selected";\r\n                }\r\n                fragment.appendChild(div);\r\n            }\r\n        });\r\n        container.appendChild(fragment);\r\n        if (items.length < 1 && strict) {\r\n            if (settings.emptyMsg) {\r\n                var empty = doc.createElement("div");\r\n                empty.className = "empty";\r\n                empty.textContent = settings.emptyMsg;\r\n                container.appendChild(empty);\r\n            }\r\n            else {\r\n                clear();\r\n                return;\r\n            }\r\n        }\r\n        attach();\r\n        updatePosition();\r\n        updateScroll();\r\n    }\r\n    function updateIfDisplayed() {\r\n        if (containerDisplayed()) {\r\n            update();\r\n        }\r\n    }\r\n    function resizeEventHandler() {\r\n        updateIfDisplayed();\r\n    }\r\n    function scrollEventHandler(e) {\r\n        if (e.target !== container) {\r\n            updateIfDisplayed();\r\n        }\r\n        else {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n    /**\r\n     * Event handler for keyup event\r\n     */\r\n    function keyup(ev) {\r\n        var keyCode = ev.which || ev.keyCode || 0;\r\n        var ignore = [38 /* Up */, 13 /* Enter */, 27 /* Esc */, 39 /* Right */, 37 /* Left */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */];\r\n        for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {\r\n            var key = ignore_1[_i];\r\n            if (keyCode === key) {\r\n                return;\r\n            }\r\n        }\r\n        // the down key is used to open autocomplete\r\n        if (keyCode === 40 /* Down */ && containerDisplayed()) {\r\n            return;\r\n        }\r\n        // if multiple keys were pressed, before we get update from server,\r\n        // this may cause redrawing our autocomplete multiple times after the last key press.\r\n        // to avoid this, the number of times keyboard was pressed will be\r\n        // saved and checked before redraw our autocomplete box.\r\n        var savedKeypressCounter = ++keypressCounter;\r\n        var val = input.value;\r\n        if (val.length >= minLen) {\r\n            clearDebounceTimer();\r\n            debounceTimer = window.setTimeout(function () {\r\n                settings.fetch(val, function (elements) {\r\n                    if (keypressCounter === savedKeypressCounter && elements) {\r\n                        items = elements;\r\n                        inputValue = val;\r\n                        selected = items.length > 0 && autoselectfirst ? items[0] : undefined;\r\n                        update();\r\n                    }\r\n                });\r\n            }, debounceWaitMs);\r\n        }\r\n        else {\r\n            clear();\r\n        }\r\n    }\r\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\r\n    function updateScroll() {\r\n        var elements = container.getElementsByClassName("selected");\r\n        if (elements.length > 0) {\r\n            var element = elements[0];\r\n            // make group visible\r\n            var previous = element.previousElementSibling;\r\n            if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {\r\n                element = previous;\r\n            }\r\n            if (element.offsetTop < container.scrollTop) {\r\n                container.scrollTop = element.offsetTop;\r\n            }\r\n            else {\r\n                var selectBottom = element.offsetTop + element.offsetHeight;\r\n                var containerBottom = container.scrollTop + container.offsetHeight;\r\n                if (selectBottom > containerBottom) {\r\n                    container.scrollTop += selectBottom - containerBottom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Select the previous item in suggestions\r\n     */\r\n    function selectPrev() {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        else {\r\n            if (selected === items[0] || selected === undefined) {\r\n                selected = items[items.length - 1];\r\n            }\r\n            else {\r\n                for (var i = items.length - 1; i > 0; i--) {\r\n                    if (selected === items[i] || i === 1) {\r\n                        selected = items[i - 1];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Select the next item in suggestions\r\n     */\r\n    function selectNext() {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        if (!selected || selected === items[items.length - 1]) {\r\n            selected = items[0];\r\n            return;\r\n        }\r\n        for (var i = 0; i < (items.length - 1); i++) {\r\n            if (selected === items[i]) {\r\n                selected = items[i + 1];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * keydown keyboard event handler\r\n     */\r\n    function keydown(ev) {\r\n        var keyCode = ev.which || ev.keyCode || 0;\r\n        if (keyCode === 38 /* Up */ || keyCode === 40 /* Down */ || keyCode === 27 /* Esc */) {\r\n            var containerIsDisplayed = containerDisplayed();\r\n            if (keyCode === 27 /* Esc */) {\r\n                clear();\r\n            }\r\n            else {\r\n                if (!containerDisplayed || items.length < 1) {\r\n                    return;\r\n                }\r\n                keyCode === 38 /* Up */\r\n                    ? selectPrev()\r\n                    : selectNext();\r\n                update();\r\n            }\r\n            ev.preventDefault();\r\n            if (containerIsDisplayed) {\r\n                ev.stopPropagation();\r\n            }\r\n            return;\r\n        }\r\n        if (keyCode === 13 /* Enter */) {\r\n            if (strict && selected) {\r\n                settings.onSelect(selected, input);\r\n                clear();\r\n            }\r\n            if (!strict) {\r\n                var freeTextSelect = { label: input.value };\r\n                if (!selected) {\r\n                    if (onFreeTextSelect) {\r\n                        onFreeTextSelect(freeTextSelect, input);\r\n                    }\r\n                    settings.onSelect(freeTextSelect, input);\r\n                }\r\n                else {\r\n                    settings.onSelect(selected, input);\r\n                }\r\n                clear();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Blur keyboard event handler\r\n     */\r\n    function blur() {\r\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\r\n        setTimeout(function () {\r\n            if (doc.activeElement !== input) {\r\n                clear();\r\n            }\r\n        }, 200);\r\n    }\r\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\r\n    function destroy() {\r\n        input.removeEventListener("keydown", keydown);\r\n        input.removeEventListener(keyUpEventName, keyup);\r\n        input.removeEventListener("blur", blur);\r\n        window.removeEventListener("resize", resizeEventHandler);\r\n        doc.removeEventListener("scroll", scrollEventHandler, true);\r\n        clearDebounceTimer();\r\n        clear();\r\n        // prevent the update call if there are pending AJAX requests\r\n        keypressCounter++;\r\n    }\r\n    // setup event handlers\r\n    input.addEventListener("keydown", keydown);\r\n    input.addEventListener(keyUpEventName, keyup);\r\n    input.addEventListener("blur", blur);\r\n    window.addEventListener("resize", resizeEventHandler);\r\n    doc.addEventListener("scroll", scrollEventHandler, true);\r\n    return {\r\n        destroy: destroy\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./ag-grid-autocomplete-editor.ts\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutocompleteSelectCellEditor", function() { return ag_grid_autocomplete_editor_AutocompleteSelectCellEditor; });\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n// This import must be done with require because of TypeScript transpiler problems with export default\r\n\r\nvar ag_grid_autocomplete_editor_AutocompleteSelectCellEditor = /** @class */ (function (_super) {\r\n    __extends(AutocompleteSelectCellEditor, _super);\r\n    function AutocompleteSelectCellEditor() {\r\n        var _this = _super.call(this, \'<div class="ag-cell-edit-input" style="padding: 0 !important;"><input class="ag-cell-edit-input" type="text"/></div>\') || this;\r\n        _this.focusAfterAttached = false;\r\n        _this.eInput = _this.getGui().querySelector(\'input\');\r\n        if (_this.currentItem) {\r\n            _this.eInput.value = _this.currentItem.label || _this.currentItem.value;\r\n        }\r\n        return _this;\r\n    }\r\n    AutocompleteSelectCellEditor.suppressKeyboardEvent = function (params) {\r\n        var keyCode = params.event.keyCode;\r\n        return params.editing && (keyCode === external_ag_grid_community_["Constants"].KEY_UP || keyCode === external_ag_grid_community_["Constants"].KEY_DOWN || keyCode === external_ag_grid_community_["Constants"].KEY_ENTER);\r\n    };\r\n    AutocompleteSelectCellEditor.getStartValue = function (params) {\r\n        var keyPressBackspaceOrDelete = params.keyPress === external_ag_grid_community_["Constants"].KEY_BACKSPACE || params.keyPress === external_ag_grid_community_["Constants"].KEY_DELETE;\r\n        if (keyPressBackspaceOrDelete) {\r\n            return \'\';\r\n        }\r\n        else if (params.charPress) {\r\n            return params.charPress;\r\n        }\r\n        return params.formatValue(params.value);\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.init = function (params) {\r\n        var _this = this;\r\n        var defaultSettings = {\r\n            render: function (cellEditor, item, value) {\r\n                var itemElement = document.createElement("div");\r\n                var regex = new RegExp(value, \'gi\');\r\n                var fieldItem = document.createElement(\'span\');\r\n                fieldItem.innerHTML = item.label.replace(regex, function (match) {\r\n                    return "<strong>" + match + "</strong>";\r\n                });\r\n                itemElement.append(fieldItem);\r\n                cellEditor.addDestroyableEventListener(itemElement, \'mousedown\', function (event) {\r\n                    cellEditor.currentItem = item;\r\n                    event.stopPropagation();\r\n                });\r\n                return itemElement;\r\n            },\r\n            renderGroup: function (cellEditor, name) {\r\n                var div = document.createElement(\'div\');\r\n                div.textContent = name;\r\n                div.className = "group";\r\n                return div;\r\n            },\r\n            className: \'ag-cell-editor-autocomplete\',\r\n            minLength: 1,\r\n            emptyMsg: "None",\r\n            strict: true,\r\n            autoselectfirst: true,\r\n            onFreeTextSelect: function () {\r\n            },\r\n            onSelect: function (cellEditor, item) {\r\n                cellEditor.currentItem = item;\r\n                cellEditor.focusOut();\r\n            },\r\n            fetch: function (cellEditor, text, callback) {\r\n                var items = params.selectData || [];\r\n                var match = text.toLowerCase() || cellEditor.eInput.value.toLowerCase();\r\n                callback(items.filter(function (n) {\r\n                    return n.label.toLowerCase().indexOf(match) !== -1;\r\n                }));\r\n            },\r\n            debounceWaitMs: 200,\r\n            customize: function (cellEditor, input, inputRect, container, maxHeight) {\r\n                if (maxHeight < 100) {\r\n                    container.style.top = "10px";\r\n                    container.style.bottom = (window.innerHeight - inputRect.bottom + input.offsetHeight) + "px";\r\n                    container.style.maxHeight = "140px";\r\n                }\r\n            }\r\n        };\r\n        this.focusAfterAttached = params.cellStartedEdit;\r\n        this.eInput.placeholder = params.placeholder || \'\';\r\n        this.eInput.value = AutocompleteSelectCellEditor.getStartValue(params);\r\n        var autocompleteParams = __assign({}, defaultSettings, params.autocomplete);\r\n        this.autocompleter = autocomplete({\r\n            input: this.eInput,\r\n            render: function (item, currentValue) {\r\n                if (autocompleteParams.render) {\r\n                    return autocompleteParams.render(_this, item, currentValue);\r\n                }\r\n                return defaultSettings.render(_this, item, currentValue);\r\n            },\r\n            renderGroup: function (name, currentValue) {\r\n                if (autocompleteParams.renderGroup) {\r\n                    return autocompleteParams.renderGroup(_this, name, currentValue);\r\n                }\r\n                return defaultSettings.renderGroup(_this, name, currentValue);\r\n            },\r\n            className: autocompleteParams.className || defaultSettings.className,\r\n            minLength: autocompleteParams.minLength || defaultSettings.minLength,\r\n            emptyMsg: autocompleteParams.emptyMsg || defaultSettings.emptyMsg,\r\n            strict: autocompleteParams.strict,\r\n            autoselectfirst: autocompleteParams.autoselectfirst,\r\n            onFreeTextSelect: function (item, input) {\r\n                if (autocompleteParams.onFreeTextSelect) {\r\n                    return autocompleteParams.onFreeTextSelect(_this, item, input);\r\n                }\r\n                return defaultSettings.onFreeTextSelect(_this, item, input);\r\n            },\r\n            onSelect: function (item, input) {\r\n                if (autocompleteParams.onSelect) {\r\n                    return autocompleteParams.onSelect(_this, item, input);\r\n                }\r\n                return defaultSettings.onSelect(_this, item, input);\r\n            },\r\n            fetch: function (text, update) {\r\n                if (autocompleteParams.fetch) {\r\n                    return autocompleteParams.fetch(_this, text, update);\r\n                }\r\n                return defaultSettings.fetch(_this, text, update);\r\n            },\r\n            debounceWaitMs: autocompleteParams.debounceWaitMs || defaultSettings.debounceWaitMs,\r\n            customize: function (input, inputRect, container, maxHeight) {\r\n                if (autocompleteParams.customize) {\r\n                    return autocompleteParams.customize(_this, input, inputRect, container, maxHeight);\r\n                }\r\n                return defaultSettings.customize(_this, input, inputRect, container, maxHeight);\r\n            }\r\n        });\r\n        // we don\'t want to add this if full row editing, otherwise selecting will stop the\r\n        // full row editing.\r\n        if (this.gridOptionsWrapper && !this.gridOptionsWrapper.isFullRowEdit()) {\r\n            this.addDestroyableEventListener(this.eInput, \'change\', function () { return params.stopEditing(); });\r\n        }\r\n        if (!params.colDef.suppressKeyboardEvent) {\r\n            params.colDef.suppressKeyboardEvent = AutocompleteSelectCellEditor.suppressKeyboardEvent;\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.afterGuiAttached = function (params) {\r\n        if (this.focusAfterAttached) {\r\n            this.eInput.focus();\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.focusIn = function () {\r\n        this.eInput.focus();\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.focusOut = function () {\r\n        this.eInput.blur();\r\n        this.autocompleter.destroy();\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.getValue = function () {\r\n        return this.currentItem || { value: \'\', label: \'\' };\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isCancelAfterEnd = function () {\r\n        return !this.currentItem;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isCancelBeforeStart = function () {\r\n        return false;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isPopup = function () {\r\n        return false;\r\n    };\r\n    __decorate([\r\n        Object(external_ag_grid_community_["Autowired"])(\'gridOptionsWrapper\')\r\n    ], AutocompleteSelectCellEditor.prototype, "gridOptionsWrapper", void 0);\r\n    return AutocompleteSelectCellEditor;\r\n}(external_ag_grid_community_["PopupComponent"]));\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2F1dG9jb21wbGV0ZXIvYXV0b2NvbXBsZXRlLnRzPzk5ZjUiLCJ3ZWJwYWNrOi8vLy4vYWctZ3JpZC1hdXRvY29tcGxldGUtZWRpdG9yLnRzP2FhNWIiXSwic291cmNlc0NvbnRlbnQiOlsiIC8qXG4gICogaHR0cHM6Ly9naXRodWIuY29tL2tyYWFkZW4vYXV0b2NvbXBsZXRlXG4gICogQ29weXJpZ2h0IChjKSAyMDE2IERlbnlzIEtyYXNub3NoY2hva1xuICAqIE1JVCBMaWNlbnNlXG4gICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlSXRlbSB7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgZ3JvdXA/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlU2V0dGluZ3M8VCBleHRlbmRzIEF1dG9jb21wbGV0ZUl0ZW0+IHtcbiAgICBpbnB1dDogSFRNTElucHV0RWxlbWVudDtcbiAgICByZW5kZXI/OiAoaXRlbTogVCwgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIHJlbmRlckdyb3VwPzogKG5hbWU6IHN0cmluZywgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGNsYXNzTmFtZT86IHN0cmluZztcbiAgICBtaW5MZW5ndGg/OiBudW1iZXI7XG4gICAgZW1wdHlNc2c/OiBzdHJpbmc7XG4gICAgc3RyaWN0OiBib29sZWFuO1xuICAgIGF1dG9zZWxlY3RmaXJzdDogYm9vbGVhbjtcbiAgICBvbkZyZWVUZXh0U2VsZWN0PzogKGl0ZW06IFQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB2b2lkO1xuICAgIG9uU2VsZWN0OiAoaXRlbTogVCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHZvaWQ7XG4gICAgZmV0Y2g6ICh0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBUW10gfCBmYWxzZSkgPT4gdm9pZCkgPT4gdm9pZDtcbiAgICBkZWJvdW5jZVdhaXRNcz86IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmb3IgYWRkaXRpb25hbCBhdXRvY29tcGxldGUgY3VzdG9taXphdGlvblxuICAgICAqIEBwYXJhbSB7SFRNTElucHV0RWxlbWVudH0gaW5wdXQgLSBpbnB1dCBib3ggYXNzb2NpYXRlZCB3aXRoIGF1dG9jb21wbGV0ZVxuICAgICAqIEBwYXJhbSB7Q2xpZW50UmVjdCB8IERPTVJlY3R9IGlucHV0UmVjdCAtIHNpemUgb2YgdGhlIGlucHV0IGJveCBhbmQgaXRzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSB7SFRNTERpdkVsZW1lbnR9IGNvbnRhaW5lciAtIGNvbnRhaW5lciB3aXRoIHN1Z2dlc3Rpb25zXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1heEhlaWdodCAtIG1heCBoZWlnaHQgdGhhdCBjYW4gYmUgdXNlZCBieSBhdXRvY29tcGxldGVcbiAgICAgKi9cbiAgICBjdXN0b21pemU/OiAoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIGlucHV0UmVjdDogQ2xpZW50UmVjdCB8IERPTVJlY3QsIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIG1heEhlaWdodDogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1dG9jb21wbGV0ZVJlc3VsdCB7XG4gICAgZGVzdHJveTogKCkgPT4gdm9pZDtcbn1cblxuY29uc3QgZW51bSBLZXlzIHtcbiAgICBFbnRlciA9IDEzLFxuICAgIEVzYyA9IDI3LFxuICAgIFVwID0gMzgsXG4gICAgRG93biA9IDQwLFxuICAgIExlZnQgPSAzNyxcbiAgICBSaWdodCA9IDM5LFxuICAgIFNoaWZ0ID0gMTYsXG4gICAgQ3RybCA9IDE3LFxuICAgIEFsdCA9IDE4LFxuICAgIENhcHNMb2NrID0gMjAsXG4gICAgV2luZG93c0tleSA9IDkxLFxuICAgIFRhYiA9IDlcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYXV0b2NvbXBsZXRlPFQgZXh0ZW5kcyBBdXRvY29tcGxldGVJdGVtPihzZXR0aW5nczogQXV0b2NvbXBsZXRlU2V0dGluZ3M8VD4pOiBBdXRvY29tcGxldGVSZXN1bHQge1xuXG4gICAgLy8ganVzdCBhbiBhbGlhcyB0byBtaW5pbWl6ZSBKUyBmaWxlIHNpemVcbiAgICBjb25zdCBkb2MgPSBkb2N1bWVudDtcblxuICAgIGNvbnN0IGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb25zdCBjb250YWluZXJTdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcbiAgICBjb25zdCB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIGNvbnN0IG1vYmlsZUZpcmVmb3ggPSB1c2VyQWdlbnQuaW5kZXhPZihcIkZpcmVmb3hcIikgIT09IC0xICYmIHVzZXJBZ2VudC5pbmRleE9mKFwiTW9iaWxlXCIpICE9PSAtMTtcbiAgICBjb25zdCBkZWJvdW5jZVdhaXRNcyA9IHNldHRpbmdzLmRlYm91bmNlV2FpdE1zIHx8IDA7XG4gICAgY29uc3Qgc3RyaWN0ID0gc2V0dGluZ3Muc3RyaWN0O1xuICAgIGNvbnN0IGF1dG9zZWxlY3RmaXJzdCA9IHNldHRpbmdzLmF1dG9zZWxlY3RmaXJzdDtcbiAgICBjb25zdCBvbkZyZWVUZXh0U2VsZWN0ID0gc2V0dGluZ3Mub25GcmVlVGV4dFNlbGVjdDtcblxuICAgIC8vICdrZXl1cCcgZXZlbnQgd2lsbCBub3QgYmUgZmlyZWQgb24gTW9iaWxlIEZpcmVmb3gsIHNvIHdlIGhhdmUgdG8gdXNlICdpbnB1dCcgZXZlbnQgaW5zdGVhZFxuICAgIGNvbnN0IGtleVVwRXZlbnROYW1lID0gbW9iaWxlRmlyZWZveCA/IFwiaW5wdXRcIiA6IFwia2V5dXBcIjtcblxuICAgIGxldCBpdGVtczogVFtdID0gW107XG4gICAgbGV0IGlucHV0VmFsdWUgPSBcIlwiO1xuICAgIGNvbnN0IG1pbkxlbiA9IHNldHRpbmdzLm1pbkxlbmd0aCB8fCAyO1xuICAgIGxldCBzZWxlY3RlZDogVCB8IHVuZGVmaW5lZDtcbiAgICBsZXQga2V5cHJlc3NDb3VudGVyID0gMDtcbiAgICBsZXQgZGVib3VuY2VUaW1lciA6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICAgIGlmICghc2V0dGluZ3MuaW5wdXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdW5kZWZpbmVkXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0OiBIVE1MSW5wdXRFbGVtZW50ID0gc2V0dGluZ3MuaW5wdXQ7XG5cbiAgICBjb250YWluZXIuY2xhc3NOYW1lID0gXCJhdXRvY29tcGxldGUgXCIgKyAoc2V0dGluZ3MuY2xhc3NOYW1lIHx8IFwiXCIpO1xuICAgIGNvbnRhaW5lclN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuXG4gICAgLyoqXG4gICAgICogRGV0YWNoIHRoZSBjb250YWluZXIgZnJvbSBET01cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZXRhY2goKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGRlYm91bmNpbmcgdGltZXIgaWYgYXNzaWduZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhckRlYm91bmNlVGltZXIoKTogdm9pZCB7XG4gICAgICAgIGlmIChkZWJvdW5jZVRpbWVyKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGRlYm91bmNlVGltZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBjb250YWluZXIgdG8gRE9NXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXR0YWNoKCk6IHZvaWQge1xuICAgICAgICBpZiAoIWNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY29udGFpbmVyIGZvciBhdXRvY29tcGxldGUgaXMgZGlzcGxheWVkXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjb250YWluZXJEaXNwbGF5ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIWNvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGF1dG9jb21wbGV0ZSBzdGF0ZSBhbmQgaGlkZSBjb250YWluZXJcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGNsZWFyKCk6IHZvaWQge1xuICAgICAgICBrZXlwcmVzc0NvdW50ZXIrKztcbiAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgaW5wdXRWYWx1ZSA9IFwiXCI7XG4gICAgICAgIHNlbGVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICBkZXRhY2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYXV0b2NvbXBsZXRlIHBvc2l0aW9uXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKTogdm9pZCB7XG4gICAgICAgIGlmICghY29udGFpbmVyRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lclN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xuICAgICAgICBjb250YWluZXJTdHlsZS53aWR0aCA9IGlucHV0Lm9mZnNldFdpZHRoICsgXCJweFwiO1xuXG4gICAgICAgIGNvbnN0IGlucHV0UmVjdCA9IGlucHV0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB0b3AgPSBpbnB1dFJlY3QudG9wICsgaW5wdXQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBsZXQgbWF4SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gdG9wO1xuXG4gICAgICAgIGlmIChtYXhIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICBtYXhIZWlnaHQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyU3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICBjb250YWluZXJTdHlsZS5ib3R0b20gPSBcIlwiO1xuICAgICAgICBjb250YWluZXJTdHlsZS5sZWZ0ID0gaW5wdXRSZWN0LmxlZnQgKyBcInB4XCI7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCA9IG1heEhlaWdodCArIFwicHhcIjtcblxuICAgICAgICBpZiAoc2V0dGluZ3MuY3VzdG9taXplKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5jdXN0b21pemUoaW5wdXQsIGlucHV0UmVjdCwgY29udGFpbmVyLCBtYXhIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVkcmF3IHRoZSBhdXRvY29tcGxldGUgZGl2IGVsZW1lbnQgd2l0aCBzdWdnZXN0aW9uc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlKCk6IHZvaWQge1xuXG4gICAgICAgIC8vIGRlbGV0ZSBhbGwgY2hpbGRyZW4gZnJvbSBhdXRvY29tcGxldGUgRE9NIGNvbnRhaW5lclxuICAgICAgICB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmdW5jdGlvbiBmb3IgcmVuZGVyaW5nIGF1dG9jb21wbGV0ZSBzdWdnZXN0aW9uc1xuICAgICAgICBsZXQgcmVuZGVyID0gZnVuY3Rpb24oaXRlbTogVCwgY3VycmVudFZhbHVlOiBzdHJpbmcpOiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZCB7XG4gICAgICAgICAgICBjb25zdCBpdGVtRWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgaXRlbUVsZW1lbnQudGV4dENvbnRlbnQgPSBpdGVtLmxhYmVsIHx8IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gaXRlbUVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXIpIHtcbiAgICAgICAgICAgIHJlbmRlciA9IHNldHRpbmdzLnJlbmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIHJlbmRlciBhdXRvY29tcGxldGUgZ3JvdXBzXG4gICAgICAgIGxldCByZW5kZXJHcm91cCA9IGZ1bmN0aW9uKGdyb3VwTmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZyk6IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwRGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBncm91cERpdi50ZXh0Q29udGVudCA9IGdyb3VwTmFtZTtcbiAgICAgICAgICAgIHJldHVybiBncm91cERpdjtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnJlbmRlckdyb3VwKSB7XG4gICAgICAgICAgICByZW5kZXJHcm91cCA9IHNldHRpbmdzLnJlbmRlckdyb3VwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgcHJldkdyb3VwID0gXCIjOT8kXCI7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtOiBUKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoaXRlbS5ncm91cCAmJiBpdGVtLmdyb3VwICE9PSBwcmV2R3JvdXApIHtcbiAgICAgICAgICAgICAgICBwcmV2R3JvdXAgPSBpdGVtLmdyb3VwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwRGl2ID0gcmVuZGVyR3JvdXAoaXRlbS5ncm91cCwgaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwRGl2KSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwRGl2LmNsYXNzTmFtZSArPSBcIiBncm91cFwiO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChncm91cERpdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGl2ID0gcmVuZGVyKGl0ZW0sIGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRpdikge1xuICAgICAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXY6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWxlY3QoaXRlbSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSArPSBcIiBzZWxlY3RlZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEgJiYgc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZW1wdHlNc2cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGVtcHR5LmNsYXNzTmFtZSA9IFwiZW1wdHlcIjtcbiAgICAgICAgICAgICAgICBlbXB0eS50ZXh0Q29udGVudCA9IHNldHRpbmdzLmVtcHR5TXNnO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXR0YWNoKCk7XG4gICAgICAgIHVwZGF0ZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgdXBkYXRlU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlSWZEaXNwbGF5ZWQoKTogdm9pZCB7XG4gICAgICAgIGlmIChjb250YWluZXJEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemVFdmVudEhhbmRsZXIoKTogdm9pZCB7XG4gICAgICAgIHVwZGF0ZUlmRGlzcGxheWVkKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsRXZlbnRIYW5kbGVyKGU6IEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChlLnRhcmdldCAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICB1cGRhdGVJZkRpc3BsYXllZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlciBmb3Iga2V5dXAgZXZlbnRcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGtleXVwKGV2OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldi53aGljaCB8fCBldi5rZXlDb2RlIHx8IDA7XG5cbiAgICAgICAgY29uc3QgaWdub3JlID0gW0tleXMuVXAsIEtleXMuRW50ZXIsIEtleXMuRXNjLCBLZXlzLlJpZ2h0LCBLZXlzLkxlZnQsIEtleXMuU2hpZnQsIEtleXMuQ3RybCwgS2V5cy5BbHQsIEtleXMuQ2Fwc0xvY2ssIEtleXMuV2luZG93c0tleSwgS2V5cy5UYWJdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBpZ25vcmUpIHtcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZG93biBrZXkgaXMgdXNlZCB0byBvcGVuIGF1dG9jb21wbGV0ZVxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Eb3duICYmIGNvbnRhaW5lckRpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBtdWx0aXBsZSBrZXlzIHdlcmUgcHJlc3NlZCwgYmVmb3JlIHdlIGdldCB1cGRhdGUgZnJvbSBzZXJ2ZXIsXG4gICAgICAgIC8vIHRoaXMgbWF5IGNhdXNlIHJlZHJhd2luZyBvdXIgYXV0b2NvbXBsZXRlIG11bHRpcGxlIHRpbWVzIGFmdGVyIHRoZSBsYXN0IGtleSBwcmVzcy5cbiAgICAgICAgLy8gdG8gYXZvaWQgdGhpcywgdGhlIG51bWJlciBvZiB0aW1lcyBrZXlib2FyZCB3YXMgcHJlc3NlZCB3aWxsIGJlXG4gICAgICAgIC8vIHNhdmVkIGFuZCBjaGVja2VkIGJlZm9yZSByZWRyYXcgb3VyIGF1dG9jb21wbGV0ZSBib3guXG4gICAgICAgIGNvbnN0IHNhdmVkS2V5cHJlc3NDb3VudGVyID0gKytrZXlwcmVzc0NvdW50ZXI7XG5cbiAgICAgICAgY29uc3QgdmFsID0gaW5wdXQudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPj0gbWluTGVuKSB7XG4gICAgICAgICAgICBjbGVhckRlYm91bmNlVGltZXIoKTtcbiAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5mZXRjaCh2YWwsIGZ1bmN0aW9uKGVsZW1lbnRzOiBUW10gfCBmYWxzZSk6IHZvaWQge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cHJlc3NDb3VudGVyID09PSBzYXZlZEtleXByZXNzQ291bnRlciAmJiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBlbGVtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zLmxlbmd0aCA+IDAgJiYgYXV0b3NlbGVjdGZpcnN0ID8gaXRlbXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZGVib3VuY2VXYWl0TXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgbW92ZSBzY3JvbGwgYmFyIGlmIHNlbGVjdGVkIGl0ZW0gaXMgbm90IHZpc2libGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBjb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInNlbGVjdGVkXCIpO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBlbGVtZW50c1swXSBhcyBIVE1MRGl2RWxlbWVudDtcblxuICAgICAgICAgICAgLy8gbWFrZSBncm91cCB2aXNpYmxlXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZyBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cy5jbGFzc05hbWUuaW5kZXhPZihcImdyb3VwXCIpICE9PSAtMSAmJiAhcHJldmlvdXMucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwcmV2aW91cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0VG9wIDwgY29udGFpbmVyLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0Qm90dG9tID0gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJCb3R0b20gPSBjb250YWluZXIuc2Nyb2xsVG9wICsgY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0Qm90dG9tID4gY29udGFpbmVyQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2VsZWN0Qm90dG9tIC0gY29udGFpbmVyQm90dG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgcHJldmlvdXMgaXRlbSBpbiBzdWdnZXN0aW9uc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2VsZWN0UHJldigpOiB2b2lkIHtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1swXSB8fCBzZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSB8fCBpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSBuZXh0IGl0ZW0gaW4gc3VnZ2VzdGlvbnNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHNlbGVjdE5leHQoKTogdm9pZCB7XG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGVjdGVkIHx8IHNlbGVjdGVkID09PSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1swXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChpdGVtcy5sZW5ndGggLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IGl0ZW1zW2ldKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpICsgMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBrZXlkb3duIGtleWJvYXJkIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGtleWRvd24oZXY6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2LndoaWNoIHx8IGV2LmtleUNvZGUgfHwgMDtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuVXAgfHwga2V5Q29kZSA9PT0gS2V5cy5Eb3duIHx8IGtleUNvZGUgPT09IEtleXMuRXNjKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJJc0Rpc3BsYXllZCA9IGNvbnRhaW5lckRpc3BsYXllZCgpO1xuXG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Fc2MpIHtcbiAgICAgICAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lckRpc3BsYXllZCB8fCBpdGVtcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5Q29kZSA9PT0gS2V5cy5VcFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdFByZXYoKVxuICAgICAgICAgICAgICAgICAgICA6IHNlbGVjdE5leHQoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXJJc0Rpc3BsYXllZCkge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5FbnRlcikge1xuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VsZWN0KHNlbGVjdGVkLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJlZVRleHRTZWxlY3QgPSB7bGFiZWw6IGlucHV0LnZhbHVlfSBhcyBUO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRnJlZVRleHRTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRnJlZVRleHRTZWxlY3QoZnJlZVRleHRTZWxlY3QsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdChmcmVlVGV4dFNlbGVjdCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VsZWN0KHNlbGVjdGVkLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCbHVyIGtleWJvYXJkIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGJsdXIoKTogdm9pZCB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsYXkgY2xlYXIsIGJlY2F1c2Ugd2hlbiB3ZSBjbGljayBvbiBhbiBpdGVtLCBibHVyIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBjbGljayBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gRE9NXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvYy5hY3RpdmVFbGVtZW50ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHJlbW92ZSBET00gZWxlbWVudHMgYW5kIGNsZWFyIGV2ZW50IGhhbmRsZXJzXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlkb3duKTtcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihrZXlVcEV2ZW50TmFtZSwga2V5dXAgYXMgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCk7XG4gICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemVFdmVudEhhbmRsZXIpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzY3JvbGxFdmVudEhhbmRsZXIsIHRydWUpO1xuICAgICAgICBjbGVhckRlYm91bmNlVGltZXIoKTtcbiAgICAgICAgY2xlYXIoKTtcblxuICAgICAgICAvLyBwcmV2ZW50IHRoZSB1cGRhdGUgY2FsbCBpZiB0aGVyZSBhcmUgcGVuZGluZyBBSkFYIHJlcXVlc3RzXG4gICAgICAgIGtleXByZXNzQ291bnRlcisrO1xuICAgIH1cblxuICAgIC8vIHNldHVwIGV2ZW50IGhhbmRsZXJzXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5ZG93bik7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihrZXlVcEV2ZW50TmFtZSwga2V5dXAgYXMgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1cik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzY3JvbGxFdmVudEhhbmRsZXIsIHRydWUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveVxuICAgIH07XG59XG4iLCJpbXBvcnQge1xuICAgIEF1dG93aXJlZCxcbiAgICBDb25zdGFudHMsXG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLFxuICAgIElBZnRlckd1aUF0dGFjaGVkUGFyYW1zLFxuICAgIElDZWxsRWRpdG9yQ29tcCxcbiAgICBJQ2VsbEVkaXRvclBhcmFtcyxcbiAgICBQb3B1cENvbXBvbmVudCxcbiAgICBTdXBwcmVzc0tleWJvYXJkRXZlbnRQYXJhbXNcbn0gZnJvbSAnYWctZ3JpZC1jb21tdW5pdHknO1xuXG5pbXBvcnQgJy4vYWctZ3JpZC1hdXRvY29tcGxldGUtZWRpdG9yLnNjc3MnO1xuLy8gVGhpcyBpbXBvcnQgbXVzdCBiZSBkb25lIHdpdGggcmVxdWlyZSBiZWNhdXNlIG9mIFR5cGVTY3JpcHQgdHJhbnNwaWxlciBwcm9ibGVtcyB3aXRoIGV4cG9ydCBkZWZhdWx0XG5pbXBvcnQgYXV0b2NvbXBsZXRlLCB7QXV0b2NvbXBsZXRlSXRlbX0gZnJvbSAnLi9hdXRvY29tcGxldGVyL2F1dG9jb21wbGV0ZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0YUZvcm1hdCBleHRlbmRzIEF1dG9jb21wbGV0ZUl0ZW0ge1xuICAgIHZhbHVlOiBudW1iZXIgfCBzdHJpbmc7XG4gICAgbGFiZWw6IHN0cmluZztcbiAgICBncm91cD86IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgQXV0b2NvbXBsZXRlQ2xpZW50ID0gRGF0YUZvcm1hdCAmIEF1dG9jb21wbGV0ZUl0ZW07XG5cbmludGVyZmFjZSBJRGVmYXVsdEF1dG9jb21wbGV0ZXJTZXR0aW5nczxUIGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbT4ge1xuICAgIHJlbmRlcjogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIGl0ZW06IFQsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKSA9PiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgICByZW5kZXJHcm91cDogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIG5hbWU6IHN0cmluZywgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGNsYXNzTmFtZTogc3RyaW5nO1xuICAgIG1pbkxlbmd0aDogbnVtYmVyO1xuICAgIGVtcHR5TXNnOiBzdHJpbmc7XG4gICAgc3RyaWN0OiBib29sZWFuO1xuICAgIGF1dG9zZWxlY3RmaXJzdDogYm9vbGVhbjtcbiAgICBvbkZyZWVUZXh0U2VsZWN0OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaXRlbTogVCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHZvaWQ7XG4gICAgb25TZWxlY3Q6IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBULCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcbiAgICBmZXRjaDogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIHRleHQ6IHN0cmluZywgdXBkYXRlOiAoaXRlbXM6IFRbXSB8IGZhbHNlKSA9PiB2b2lkKSA9PiB2b2lkO1xuICAgIGRlYm91bmNlV2FpdE1zOiBudW1iZXI7XG4gICAgY3VzdG9taXplOiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIGlucHV0UmVjdDogQ2xpZW50UmVjdCB8IERPTVJlY3QsIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIG1heEhlaWdodDogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElBdXRvY29tcGxldGVyU2V0dGluZ3M8VCBleHRlbmRzIEF1dG9jb21wbGV0ZUl0ZW0+IHtcbiAgICByZW5kZXI/OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaXRlbTogVCwgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIHJlbmRlckdyb3VwPzogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIG5hbWU6IHN0cmluZywgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGNsYXNzTmFtZT86IHN0cmluZztcbiAgICBtaW5MZW5ndGg/OiBudW1iZXI7XG4gICAgZW1wdHlNc2c/OiBzdHJpbmc7XG4gICAgc3RyaWN0PzogYm9vbGVhbjtcbiAgICBhdXRvc2VsZWN0Zmlyc3Q/OiBib29sZWFuO1xuICAgIG9uRnJlZVRleHRTZWxlY3Q/OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaXRlbTogVCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHZvaWQ7XG4gICAgb25TZWxlY3Q/OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaXRlbTogVCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHZvaWQ7XG4gICAgZmV0Y2g/OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgdGV4dDogc3RyaW5nLCB1cGRhdGU6IChpdGVtczogVFtdIHwgZmFsc2UpID0+IHZvaWQpID0+IHZvaWQ7XG4gICAgZGVib3VuY2VXYWl0TXM/OiBudW1iZXI7XG4gICAgY3VzdG9taXplPzogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50LCBpbnB1dFJlY3Q6IENsaWVudFJlY3QgfCBET01SZWN0LCBjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBtYXhIZWlnaHQ6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvclBhcmFtcyBleHRlbmRzIElDZWxsRWRpdG9yUGFyYW1zIHtcbiAgICBhdXRvY29tcGxldGU/OiBJQXV0b2NvbXBsZXRlclNldHRpbmdzPEF1dG9jb21wbGV0ZUNsaWVudD47XG4gICAgc2VsZWN0RGF0YTogRGF0YUZvcm1hdFtdO1xuICAgIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciBleHRlbmRzIFBvcHVwQ29tcG9uZW50IGltcGxlbWVudHMgSUNlbGxFZGl0b3JDb21wIHtcbiAgICBwcml2YXRlIGZvY3VzQWZ0ZXJBdHRhY2hlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgZUlucHV0OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIHB1YmxpYyBjdXJyZW50SXRlbT86IERhdGFGb3JtYXQ7XG4gICAgcHJpdmF0ZSBhdXRvY29tcGxldGVyPzogYW55O1xuXG4gICAgQEF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJykgcHJpdmF0ZSBncmlkT3B0aW9uc1dyYXBwZXI/OiBHcmlkT3B0aW9uc1dyYXBwZXI7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJzxkaXYgY2xhc3M9XCJhZy1jZWxsLWVkaXQtaW5wdXRcIiBzdHlsZT1cInBhZGRpbmc6IDAgIWltcG9ydGFudDtcIj48aW5wdXQgY2xhc3M9XCJhZy1jZWxsLWVkaXQtaW5wdXRcIiB0eXBlPVwidGV4dFwiLz48L2Rpdj4nKTtcbiAgICAgICAgdGhpcy5lSW5wdXQgPSB0aGlzLmdldEd1aSgpLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuZUlucHV0LnZhbHVlID0gdGhpcy5jdXJyZW50SXRlbS5sYWJlbCB8fCB0aGlzLmN1cnJlbnRJdGVtLnZhbHVlIGFzIHN0cmluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIHN0YXRpYyBzdXBwcmVzc0tleWJvYXJkRXZlbnQocGFyYW1zOiBTdXBwcmVzc0tleWJvYXJkRXZlbnRQYXJhbXMpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGtleUNvZGUgPSBwYXJhbXMuZXZlbnQua2V5Q29kZTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5lZGl0aW5nICYmIChrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX1VQIHx8IGtleUNvZGUgPT09IENvbnN0YW50cy5LRVlfRE9XTiB8fCBrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX0VOVEVSKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRTdGFydFZhbHVlKHBhcmFtczogSUF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3JQYXJhbXMpIHtcbiAgICAgICAgY29uc3Qga2V5UHJlc3NCYWNrc3BhY2VPckRlbGV0ZSA9IHBhcmFtcy5rZXlQcmVzcyA9PT0gQ29uc3RhbnRzLktFWV9CQUNLU1BBQ0UgfHwgcGFyYW1zLmtleVByZXNzID09PSBDb25zdGFudHMuS0VZX0RFTEVURTtcbiAgICAgICAgaWYgKGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuY2hhclByZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmNoYXJQcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zLmZvcm1hdFZhbHVlKHBhcmFtcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGluaXQocGFyYW1zOiBJQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvclBhcmFtcykge1xuICAgICAgICBjb25zdCBkZWZhdWx0U2V0dGluZ3M6IElEZWZhdWx0QXV0b2NvbXBsZXRlclNldHRpbmdzPEF1dG9jb21wbGV0ZUNsaWVudD4gPSB7XG4gICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBBdXRvY29tcGxldGVDbGllbnQsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVnZXggPSBuZXcgUmVnRXhwKHZhbHVlLCAnZ2knKTtcbiAgICAgICAgICAgICAgICBsZXQgZmllbGRJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIGZpZWxkSXRlbS5pbm5lckhUTUwgPSBpdGVtLmxhYmVsLnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uIChtYXRjaDogc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxzdHJvbmc+XCIgKyBtYXRjaCArIFwiPC9zdHJvbmc+XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdGVtRWxlbWVudC5hcHBlbmQoZmllbGRJdGVtKTtcbiAgICAgICAgICAgICAgICBjZWxsRWRpdG9yLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcihpdGVtRWxlbWVudCwgJ21vdXNlZG93bicsIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjZWxsRWRpdG9yLmN1cnJlbnRJdGVtID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1FbGVtZW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlckdyb3VwOiBmdW5jdGlvbiAoY2VsbEVkaXRvciwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBkaXYudGV4dENvbnRlbnQgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGRpdi5jbGFzc05hbWUgPSBcImdyb3VwXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhZy1jZWxsLWVkaXRvci1hdXRvY29tcGxldGUnLFxuICAgICAgICAgICAgbWluTGVuZ3RoOiAxLFxuICAgICAgICAgICAgZW1wdHlNc2c6IFwiTm9uZVwiLFxuICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgYXV0b3NlbGVjdGZpcnN0OiB0cnVlLFxuICAgICAgICAgICAgb25GcmVlVGV4dFNlbGVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiAoY2VsbEVkaXRvciwgaXRlbTogQXV0b2NvbXBsZXRlQ2xpZW50KSB7XG4gICAgICAgICAgICAgICAgY2VsbEVkaXRvci5jdXJyZW50SXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgY2VsbEVkaXRvci5mb2N1c091dCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZldGNoOiAoY2VsbEVkaXRvciwgdGV4dCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBwYXJhbXMuc2VsZWN0RGF0YSB8fCBbXTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0ZXh0LnRvTG93ZXJDYXNlKCkgfHwgY2VsbEVkaXRvci5lSW5wdXQudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4ubGFiZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKG1hdGNoKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYm91bmNlV2FpdE1zOiAyMDAsXG4gICAgICAgICAgICBjdXN0b21pemU6IGZ1bmN0aW9uIChjZWxsRWRpdG9yLCBpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXhIZWlnaHQgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IFwiMTBweFwiO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm90dG9tID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIGlucHV0UmVjdC5ib3R0b20gKyBpbnB1dC5vZmZzZXRIZWlnaHQpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUubWF4SGVpZ2h0ID0gXCIxNDBweFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQgPSBwYXJhbXMuY2VsbFN0YXJ0ZWRFZGl0O1xuXG4gICAgICAgIHRoaXMuZUlucHV0LnBsYWNlaG9sZGVyID0gcGFyYW1zLnBsYWNlaG9sZGVyIHx8ICcnO1xuICAgICAgICB0aGlzLmVJbnB1dC52YWx1ZSA9IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IuZ2V0U3RhcnRWYWx1ZShwYXJhbXMpO1xuXG4gICAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZVBhcmFtcyA9IHsuLi5kZWZhdWx0U2V0dGluZ3MsIC4uLnBhcmFtcy5hdXRvY29tcGxldGV9O1xuXG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlciA9IGF1dG9jb21wbGV0ZSh7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5lSW5wdXQsXG4gICAgICAgICAgICByZW5kZXI6IChpdGVtOiBBdXRvY29tcGxldGVDbGllbnQsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5yZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9jb21wbGV0ZVBhcmFtcy5yZW5kZXIodGhpcywgaXRlbSwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZXR0aW5ncy5yZW5kZXIodGhpcywgaXRlbSwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW5kZXJHcm91cDogKG5hbWU6IHN0cmluZywgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUGFyYW1zLnJlbmRlckdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvY29tcGxldGVQYXJhbXMucmVuZGVyR3JvdXAodGhpcywgbmFtZSwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZXR0aW5ncy5yZW5kZXJHcm91cCh0aGlzLCBuYW1lLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYXV0b2NvbXBsZXRlUGFyYW1zLmNsYXNzTmFtZSB8fCBkZWZhdWx0U2V0dGluZ3MuY2xhc3NOYW1lLFxuICAgICAgICAgICAgbWluTGVuZ3RoOiBhdXRvY29tcGxldGVQYXJhbXMubWluTGVuZ3RoIHx8IGRlZmF1bHRTZXR0aW5ncy5taW5MZW5ndGgsXG4gICAgICAgICAgICBlbXB0eU1zZzogYXV0b2NvbXBsZXRlUGFyYW1zLmVtcHR5TXNnIHx8IGRlZmF1bHRTZXR0aW5ncy5lbXB0eU1zZyxcbiAgICAgICAgICAgIHN0cmljdDogYXV0b2NvbXBsZXRlUGFyYW1zLnN0cmljdCxcbiAgICAgICAgICAgIGF1dG9zZWxlY3RmaXJzdDogYXV0b2NvbXBsZXRlUGFyYW1zLmF1dG9zZWxlY3RmaXJzdCxcbiAgICAgICAgICAgIG9uRnJlZVRleHRTZWxlY3Q6IChpdGVtOiBBdXRvY29tcGxldGVDbGllbnQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5vbkZyZWVUZXh0U2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvY29tcGxldGVQYXJhbXMub25GcmVlVGV4dFNlbGVjdCh0aGlzLCBpdGVtLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2V0dGluZ3Mub25GcmVlVGV4dFNlbGVjdCh0aGlzLCBpdGVtLCBpbnB1dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25TZWxlY3Q6IChpdGVtOiBBdXRvY29tcGxldGVDbGllbnQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5vblNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUGFyYW1zLm9uU2VsZWN0KHRoaXMsIGl0ZW0sIGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZXR0aW5ncy5vblNlbGVjdCh0aGlzLCBpdGVtLCBpbnB1dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmV0Y2g6ICh0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBBdXRvY29tcGxldGVDbGllbnRbXSB8IGZhbHNlKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5mZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUGFyYW1zLmZldGNoKHRoaXMsIHRleHQsIHVwZGF0ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZXR0aW5ncy5mZXRjaCh0aGlzLCB0ZXh0LCB1cGRhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYm91bmNlV2FpdE1zOiBhdXRvY29tcGxldGVQYXJhbXMuZGVib3VuY2VXYWl0TXMgfHwgZGVmYXVsdFNldHRpbmdzLmRlYm91bmNlV2FpdE1zLFxuICAgICAgICAgICAgY3VzdG9taXplOiAoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIGlucHV0UmVjdDogQ2xpZW50UmVjdCB8IERPTVJlY3QsIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIG1heEhlaWdodDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5jdXN0b21pemUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9jb21wbGV0ZVBhcmFtcy5jdXN0b21pemUodGhpcywgaW5wdXQsIGlucHV0UmVjdCwgY29udGFpbmVyLCBtYXhIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzLmN1c3RvbWl6ZSh0aGlzLCBpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gYWRkIHRoaXMgaWYgZnVsbCByb3cgZWRpdGluZywgb3RoZXJ3aXNlIHNlbGVjdGluZyB3aWxsIHN0b3AgdGhlXG4gICAgICAgIC8vIGZ1bGwgcm93IGVkaXRpbmcuXG4gICAgICAgIGlmICh0aGlzLmdyaWRPcHRpb25zV3JhcHBlciAmJiAhdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuaXNGdWxsUm93RWRpdCgpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcih0aGlzLmVJbnB1dCwgJ2NoYW5nZScsICgpID0+IHBhcmFtcy5zdG9wRWRpdGluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtcy5jb2xEZWYuc3VwcHJlc3NLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgICBwYXJhbXMuY29sRGVmLnN1cHByZXNzS2V5Ym9hcmRFdmVudCA9IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3Iuc3VwcHJlc3NLZXlib2FyZEV2ZW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWZ0ZXJHdWlBdHRhY2hlZChwYXJhbXM/OiBJQWZ0ZXJHdWlBdHRhY2hlZFBhcmFtcyk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZUlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmb2N1c0luKCk6IHZvaWQge1xuICAgICAgICB0aGlzLmVJbnB1dC5mb2N1cygpXG4gICAgfVxuXG4gICAgZm9jdXNPdXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZUlucHV0LmJsdXIoKTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBnZXRWYWx1ZSgpOiBEYXRhRm9ybWF0IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEl0ZW0gfHwge3ZhbHVlOiAnJywgbGFiZWw6ICcnfTtcbiAgICB9XG5cbiAgICBpc0NhbmNlbEFmdGVyRW5kKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuY3VycmVudEl0ZW07XG4gICAgfVxuXG4gICAgaXNDYW5jZWxCZWZvcmVTdGFydCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlzUG9wdXAoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBSUE7QUFpREE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMWNBO0FBV0E7QUFDQTtBQUNBO0FBOENBO0FBQUE7QUFRQTtBQUFBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFyS0E7QUFBQTtBQUFBO0FBc0tBO0FBQUE7QUE1S0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')}])});