!function(g,I){if("object"==typeof exports&&"object"==typeof module)module.exports=I(require("ag-grid-community"));else if("function"==typeof define&&define.amd)define(["ag-grid-community"],I);else{var C="object"==typeof exports?I(require("ag-grid-community")):I(g["ag-grid-community"]);for(var t in C)("object"==typeof exports?exports:g)[t]=C[t]}}(window,function(__WEBPACK_EXTERNAL_MODULE__0__){return function(g){var I={};function C(t){if(I[t])return I[t].exports;var e=I[t]={i:t,l:!1,exports:{}};return g[t].call(e.exports,e,e.exports,C),e.l=!0,e.exports}return C.m=g,C.c=I,C.d=function(g,I,t){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:t})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var t=Object.create(null);if(C.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var e in g)C.d(t,e,function(I){return g[I]}.bind(null,e));return t},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="http://localhost:8080/",C(C.s=2)}([function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImFnLWdyaWQtY29tbXVuaXR5XCI/ODc0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzBfXzsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FnLWdyaWQtYXV0b2NvbXBsZXRlLWVkaXRvci5zY3NzP2E4NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external "ag-grid-community"\nvar external_ag_grid_community_ = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./ag-grid-autocomplete-editor.scss\nvar ag_grid_autocomplete_editor = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./autocompleter/autocomplete.ts\n/*\r\n * https://github.com/kraaden/autocomplete\r\n * Copyright (c) 2016 Denys Krasnoshchok\r\n * MIT License\r\n */\r\nfunction autocomplete(settings) {\r\n    // just an alias to minimize JS file size\r\n    var doc = document;\r\n    var container = doc.createElement("div");\r\n    var containerStyle = container.style;\r\n    var userAgent = navigator.userAgent;\r\n    var mobileFirefox = userAgent.indexOf("Firefox") !== -1 && userAgent.indexOf("Mobile") !== -1;\r\n    var debounceWaitMs = settings.debounceWaitMs || 0;\r\n    var strict = settings.strict;\r\n    var autoselectfirst = settings.autoselectfirst;\r\n    var onFreeTextSelect = settings.onFreeTextSelect;\r\n    // \'keyup\' event will not be fired on Mobile Firefox, so we have to use \'input\' event instead\r\n    var keyUpEventName = mobileFirefox ? "input" : "keyup";\r\n    var items = [];\r\n    var inputValue = "";\r\n    var minLen = settings.minLength || 2;\r\n    var showOnFocus = settings.showOnFocus;\r\n    var selected;\r\n    var keypressCounter = 0;\r\n    var debounceTimer;\r\n    if (!settings.input) {\r\n        throw new Error("input undefined");\r\n    }\r\n    var input = settings.input;\r\n    container.className = "autocomplete " + (settings.className || "");\r\n    containerStyle.position = "fixed";\r\n    /**\r\n     * Detach the container from DOM\r\n     */\r\n    function detach() {\r\n        var parent = container.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(container);\r\n        }\r\n    }\r\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\r\n    function clearDebounceTimer() {\r\n        if (debounceTimer) {\r\n            window.clearTimeout(debounceTimer);\r\n        }\r\n    }\r\n    /**\r\n     * Attach the container to DOM\r\n     */\r\n    function attach() {\r\n        if (!container.parentNode) {\r\n            doc.body.appendChild(container);\r\n        }\r\n    }\r\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\r\n    function containerDisplayed() {\r\n        return !!container.parentNode;\r\n    }\r\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\r\n    function clear() {\r\n        keypressCounter++;\r\n        items = [];\r\n        inputValue = "";\r\n        selected = undefined;\r\n        detach();\r\n    }\r\n    /**\r\n     * Update autocomplete position\r\n     */\r\n    function updatePosition() {\r\n        if (!containerDisplayed()) {\r\n            return;\r\n        }\r\n        containerStyle.height = "auto";\r\n        containerStyle.width = input.offsetWidth + "px";\r\n        var inputRect = input.getBoundingClientRect();\r\n        var top = inputRect.top + input.offsetHeight;\r\n        var maxHeight = window.innerHeight - top;\r\n        if (maxHeight < 0) {\r\n            maxHeight = 0;\r\n        }\r\n        containerStyle.top = top + "px";\r\n        containerStyle.bottom = "";\r\n        containerStyle.left = inputRect.left + "px";\r\n        containerStyle.maxHeight = maxHeight + "px";\r\n        if (settings.customize) {\r\n            settings.customize(input, inputRect, container, maxHeight);\r\n        }\r\n    }\r\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\r\n    function update() {\r\n        // delete all children from autocomplete DOM container\r\n        while (container.firstChild) {\r\n            container.removeChild(container.firstChild);\r\n        }\r\n        // function for rendering autocomplete suggestions\r\n        // noinspection JSUnusedLocalSymbols\r\n        var render = function (item, currentValue) {\r\n            var itemElement = doc.createElement("div");\r\n            itemElement.textContent = item.label || "";\r\n            return itemElement;\r\n        };\r\n        if (settings.render) {\r\n            render = settings.render;\r\n        }\r\n        // function to render autocomplete groups\r\n        // noinspection JSUnusedLocalSymbols\r\n        var renderGroup = function (groupName, currentValue) {\r\n            var groupDiv = doc.createElement("div");\r\n            groupDiv.textContent = groupName;\r\n            return groupDiv;\r\n        };\r\n        if (settings.renderGroup) {\r\n            renderGroup = settings.renderGroup;\r\n        }\r\n        var fragment = doc.createDocumentFragment();\r\n        var prevGroup = "#9?$";\r\n        items.forEach(function (item) {\r\n            if (item.group && item.group !== prevGroup) {\r\n                prevGroup = item.group;\r\n                var groupDiv = renderGroup(item.group, inputValue);\r\n                if (groupDiv) {\r\n                    groupDiv.className += " group";\r\n                    fragment.appendChild(groupDiv);\r\n                }\r\n            }\r\n            var div = render(item, inputValue);\r\n            if (div) {\r\n                div.addEventListener("click", function (ev) {\r\n                    settings.onSelect(item, input, ev);\r\n                    clear();\r\n                    ev.preventDefault();\r\n                    ev.stopPropagation();\r\n                });\r\n                if (item === selected) {\r\n                    div.className += " selected";\r\n                }\r\n                fragment.appendChild(div);\r\n            }\r\n        });\r\n        container.appendChild(fragment);\r\n        if (items.length < 1 && strict) {\r\n            if (settings.emptyMsg) {\r\n                var empty = doc.createElement("div");\r\n                empty.className = "empty";\r\n                empty.textContent = settings.emptyMsg;\r\n                container.appendChild(empty);\r\n                selected = undefined;\r\n            }\r\n            else {\r\n                clear();\r\n                return;\r\n            }\r\n        }\r\n        attach();\r\n        updatePosition();\r\n        updateScroll();\r\n    }\r\n    function updateIfDisplayed() {\r\n        if (containerDisplayed()) {\r\n            update();\r\n        }\r\n    }\r\n    function resizeEventHandler() {\r\n        updateIfDisplayed();\r\n    }\r\n    function scrollEventHandler(e) {\r\n        if (e.target !== container) {\r\n            updateIfDisplayed();\r\n        }\r\n        else {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n    function keyupEventHandler(ev) {\r\n        var keyCode = ev.which || ev.keyCode || 0;\r\n        var ignore = [38 /* Up */, 13 /* Enter */, 27 /* Esc */, 39 /* Right */, 37 /* Left */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */];\r\n        for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {\r\n            var key = ignore_1[_i];\r\n            if (keyCode === key) {\r\n                return;\r\n            }\r\n        }\r\n        // the down key is used to open autocomplete\r\n        if (keyCode === 40 /* Down */ && containerDisplayed()) {\r\n            return;\r\n        }\r\n        startFetch(0 /* Keyboard */);\r\n    }\r\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\r\n    function updateScroll() {\r\n        var elements = container.getElementsByClassName("selected");\r\n        if (elements.length > 0) {\r\n            var element = elements[0];\r\n            // make group visible\r\n            var previous = element.previousElementSibling;\r\n            if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {\r\n                element = previous;\r\n            }\r\n            if (element.offsetTop < container.scrollTop) {\r\n                container.scrollTop = element.offsetTop;\r\n            }\r\n            else {\r\n                var selectBottom = element.offsetTop + element.offsetHeight;\r\n                var containerBottom = container.scrollTop + container.offsetHeight;\r\n                if (selectBottom > containerBottom) {\r\n                    container.scrollTop += selectBottom - containerBottom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Select the previous item in suggestions\r\n     */\r\n    function selectPrev() {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        else {\r\n            if (selected === items[0] || selected === undefined) {\r\n                selected = items[items.length - 1];\r\n            }\r\n            else {\r\n                for (var i = items.length - 1; i > 0; i--) {\r\n                    if (selected === items[i] || i === 1) {\r\n                        selected = items[i - 1];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Select the next item in suggestions\r\n     */\r\n    function selectNext() {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        if (!selected || selected === items[items.length - 1]) {\r\n            selected = items[0];\r\n            return;\r\n        }\r\n        for (var i = 0; i < (items.length - 1); i++) {\r\n            if (selected === items[i]) {\r\n                selected = items[i + 1];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    function keydownEventHandler(ev) {\r\n        var keyCode = ev.which || ev.keyCode || 0;\r\n        if (keyCode === 38 /* Up */ || keyCode === 40 /* Down */ || keyCode === 27 /* Esc */) {\r\n            var containerIsDisplayed = containerDisplayed();\r\n            if (keyCode === 27 /* Esc */) {\r\n                settings.onSelect(undefined, input, ev);\r\n                clear();\r\n            }\r\n            else {\r\n                if (!containerDisplayed || items.length < 1) {\r\n                    return;\r\n                }\r\n                keyCode === 38 /* Up */\r\n                    ? selectPrev()\r\n                    : selectNext();\r\n                update();\r\n            }\r\n            ev.preventDefault();\r\n            if (containerIsDisplayed) {\r\n                ev.stopPropagation();\r\n            }\r\n            return;\r\n        }\r\n        if (keyCode === 13 /* Enter */ || keyCode === 9 /* Tab */) {\r\n            if (strict) {\r\n                settings.onSelect(selected, input, ev);\r\n                clear();\r\n            }\r\n            if (!strict) {\r\n                var freeTextSelect = { label: input.value };\r\n                if (!selected) {\r\n                    if (onFreeTextSelect) {\r\n                        onFreeTextSelect(freeTextSelect, input);\r\n                    }\r\n                    settings.onSelect(freeTextSelect, input, ev);\r\n                }\r\n                else {\r\n                    settings.onSelect(selected, input, ev);\r\n                }\r\n                clear();\r\n            }\r\n        }\r\n    }\r\n    function focusEventHandler() {\r\n        if (showOnFocus) {\r\n            startFetch(1 /* Focus */);\r\n        }\r\n    }\r\n    function startFetch(trigger) {\r\n        // if multiple keys were pressed, before we get update from server,\r\n        // this may cause redrawing our autocomplete multiple times after the last key press.\r\n        // to avoid this, the number of times keyboard was pressed will be\r\n        // saved and checked before redraw our autocomplete box.\r\n        var savedKeypressCounter = ++keypressCounter;\r\n        var val = input.value;\r\n        if (val.length >= minLen || trigger === 1 /* Focus */) {\r\n            clearDebounceTimer();\r\n            debounceTimer = window.setTimeout(function () {\r\n                settings.fetch(val, function (elements) {\r\n                    if (keypressCounter === savedKeypressCounter && elements) {\r\n                        items = elements;\r\n                        inputValue = val;\r\n                        selected = items.length > 0 && autoselectfirst ? items[0] : undefined;\r\n                        update();\r\n                    }\r\n                }, 0 /* Keyboard */);\r\n            }, trigger === 0 /* Keyboard */ ? debounceWaitMs : 0);\r\n        }\r\n        else {\r\n            clear();\r\n        }\r\n    }\r\n    function blurEventHandler() {\r\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\r\n        setTimeout(function () {\r\n            if (doc.activeElement !== input) {\r\n                clear();\r\n            }\r\n        }, 200);\r\n    }\r\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\r\n    function destroy() {\r\n        input.removeEventListener("focus", focusEventHandler);\r\n        input.removeEventListener("keydown", keydownEventHandler);\r\n        input.removeEventListener(keyUpEventName, keyupEventHandler);\r\n        input.removeEventListener("blur", blurEventHandler);\r\n        window.removeEventListener("resize", resizeEventHandler);\r\n        doc.removeEventListener("scroll", scrollEventHandler, true);\r\n        clearDebounceTimer();\r\n        clear();\r\n        // prevent the update call if there are pending AJAX requests\r\n        keypressCounter++;\r\n    }\r\n    // setup event handlers\r\n    input.addEventListener("keydown", keydownEventHandler);\r\n    input.addEventListener(keyUpEventName, keyupEventHandler);\r\n    input.addEventListener("blur", blurEventHandler);\r\n    input.addEventListener("focus", focusEventHandler);\r\n    window.addEventListener("resize", resizeEventHandler);\r\n    doc.addEventListener("scroll", scrollEventHandler, true);\r\n    return {\r\n        destroy: destroy\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./ag-grid-autocomplete-editor.ts\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutocompleteSelectCellEditor", function() { return ag_grid_autocomplete_editor_AutocompleteSelectCellEditor; });\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n// This import must be done with require because of TypeScript transpiler problems with export default\r\n\r\nvar ag_grid_autocomplete_editor_AutocompleteSelectCellEditor = /** @class */ (function (_super) {\r\n    __extends(AutocompleteSelectCellEditor, _super);\r\n    function AutocompleteSelectCellEditor() {\r\n        var _this = _super.call(this, \'<div class="ag-cell-edit-input" style="padding: 0 !important;"><input class="ag-cell-edit-input" type="text"/></div>\') || this;\r\n        _this.focusAfterAttached = false;\r\n        _this.required = false;\r\n        _this.eInput = _this.getGui().querySelector(\'input\');\r\n        if (_this.currentItem) {\r\n            _this.eInput.value = _this.currentItem.label || _this.currentItem.value;\r\n        }\r\n        return _this;\r\n    }\r\n    AutocompleteSelectCellEditor.suppressKeyboardEvent = function (params) {\r\n        var keyCode = params.event.keyCode;\r\n        return params.editing && (keyCode === external_ag_grid_community_["Constants"].KEY_UP || keyCode === external_ag_grid_community_["Constants"].KEY_DOWN || keyCode === external_ag_grid_community_["Constants"].KEY_ENTER || keyCode === external_ag_grid_community_["Constants"].KEY_TAB);\r\n    };\r\n    AutocompleteSelectCellEditor.getStartValue = function (params) {\r\n        var keyPressBackspaceOrDelete = params.keyPress === external_ag_grid_community_["Constants"].KEY_BACKSPACE || params.keyPress === external_ag_grid_community_["Constants"].KEY_DELETE;\r\n        if (keyPressBackspaceOrDelete) {\r\n            return \'\';\r\n        }\r\n        else if (params.charPress) {\r\n            return params.charPress;\r\n        }\r\n        return params.formatValue(params.value);\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.init = function (params) {\r\n        var _this = this;\r\n        this.stopEditing = params.stopEditing;\r\n        var defaultSettings = {\r\n            showOnFocus: false,\r\n            render: function (cellEditor, item, value) {\r\n                var itemElement = document.createElement("div");\r\n                var regex = new RegExp(value, \'gi\');\r\n                var fieldItem = document.createElement(\'span\');\r\n                fieldItem.innerHTML = item.label.replace(regex, function (match) {\r\n                    return "<strong>" + match + "</strong>";\r\n                });\r\n                itemElement.append(fieldItem);\r\n                cellEditor.addDestroyableEventListener(itemElement, \'mousedown\', function (event) {\r\n                    cellEditor.currentItem = item;\r\n                    event.stopPropagation();\r\n                });\r\n                return itemElement;\r\n            },\r\n            renderGroup: function (cellEditor, name) {\r\n                var div = document.createElement(\'div\');\r\n                div.textContent = name;\r\n                div.className = "group";\r\n                return div;\r\n            },\r\n            className: \'ag-cell-editor-autocomplete\',\r\n            minLength: 1,\r\n            emptyMsg: "None",\r\n            strict: true,\r\n            autoselectfirst: true,\r\n            onFreeTextSelect: function () {\r\n            },\r\n            onSelect: function (cellEditor, item) {\r\n                cellEditor.currentItem = item;\r\n            },\r\n            fetch: function (cellEditor, text, callback) {\r\n                var items = params.selectData || [];\r\n                var match = text.toLowerCase() || cellEditor.eInput.value.toLowerCase();\r\n                callback(items.filter(function (n) {\r\n                    return n.label.toLowerCase().indexOf(match) !== -1;\r\n                }));\r\n            },\r\n            debounceWaitMs: 200,\r\n            customize: function (cellEditor, input, inputRect, container, maxHeight) {\r\n                if (maxHeight < 100) {\r\n                    container.style.top = "10px";\r\n                    container.style.bottom = (window.innerHeight - inputRect.bottom + input.offsetHeight) + "px";\r\n                    container.style.maxHeight = "140px";\r\n                }\r\n            }\r\n        };\r\n        this.focusAfterAttached = params.cellStartedEdit;\r\n        this.eInput.placeholder = params.placeholder || \'\';\r\n        this.eInput.value = AutocompleteSelectCellEditor.getStartValue(params);\r\n        var autocompleteParams = __assign({}, defaultSettings, params.autocomplete);\r\n        this.autocompleter = autocomplete({\r\n            input: this.eInput,\r\n            render: function (item, currentValue) {\r\n                if (autocompleteParams.render) {\r\n                    return autocompleteParams.render(_this, item, currentValue);\r\n                }\r\n                return defaultSettings.render(_this, item, currentValue);\r\n            },\r\n            renderGroup: function (name, currentValue) {\r\n                if (autocompleteParams.renderGroup) {\r\n                    return autocompleteParams.renderGroup(_this, name, currentValue);\r\n                }\r\n                return defaultSettings.renderGroup(_this, name, currentValue);\r\n            },\r\n            className: autocompleteParams.className || defaultSettings.className,\r\n            minLength: autocompleteParams.minLength || defaultSettings.minLength,\r\n            emptyMsg: autocompleteParams.emptyMsg || defaultSettings.emptyMsg,\r\n            strict: autocompleteParams.strict,\r\n            autoselectfirst: autocompleteParams.autoselectfirst,\r\n            showOnFocus: autocompleteParams.showOnFocus,\r\n            onFreeTextSelect: function (item, input) {\r\n                if (autocompleteParams.onFreeTextSelect) {\r\n                    return autocompleteParams.onFreeTextSelect(_this, item, input);\r\n                }\r\n                return defaultSettings.onFreeTextSelect(_this, item, input);\r\n            },\r\n            onSelect: function (item, input, event) {\r\n                var result;\r\n                if (autocompleteParams.onSelect) {\r\n                    result = autocompleteParams.onSelect(_this, item, input);\r\n                    if (event instanceof KeyboardEvent) {\r\n                        _this.handleTabEvent(event);\r\n                    }\r\n                    return result;\r\n                }\r\n                result = defaultSettings.onSelect(_this, item, input);\r\n                if (event instanceof KeyboardEvent) {\r\n                    _this.handleTabEvent(event);\r\n                }\r\n                return result;\r\n            },\r\n            fetch: function (text, update, trigger) {\r\n                if (autocompleteParams.fetch) {\r\n                    return autocompleteParams.fetch(_this, text, update, trigger);\r\n                }\r\n                return defaultSettings.fetch(_this, text, update, trigger);\r\n            },\r\n            debounceWaitMs: autocompleteParams.debounceWaitMs || defaultSettings.debounceWaitMs,\r\n            customize: function (input, inputRect, container, maxHeight) {\r\n                if (autocompleteParams.customize) {\r\n                    return autocompleteParams.customize(_this, input, inputRect, container, maxHeight);\r\n                }\r\n                return defaultSettings.customize(_this, input, inputRect, container, maxHeight);\r\n            }\r\n        });\r\n        if (params.required) {\r\n            this.required = true;\r\n        }\r\n        if (!params.colDef.suppressKeyboardEvent) {\r\n            params.colDef.suppressKeyboardEvent = AutocompleteSelectCellEditor.suppressKeyboardEvent;\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.handleTabEvent = function (event) {\r\n        var keyCode = event.which || event.keyCode || 0;\r\n        if (keyCode === external_ag_grid_community_["Constants"].KEY_TAB && this.gridOptionsWrapper) {\r\n            if (event.shiftKey) {\r\n                this.gridOptionsWrapper.getApi().tabToPreviousCell();\r\n            }\r\n            else {\r\n                this.gridOptionsWrapper.getApi().tabToNextCell();\r\n            }\r\n        }\r\n        else {\r\n            this.destroy();\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.afterGuiAttached = function (params) {\r\n        if (!this.focusAfterAttached) {\r\n            return;\r\n        }\r\n        var eInput = this.eInput;\r\n        eInput.focus();\r\n        eInput.select();\r\n        // when we started editing, we want the caret at the end, not the start.\r\n        // this comes into play in two scenarios: a) when user hits F2 and b)\r\n        // when user hits a printable character, then on IE (and only IE) the caret\r\n        // was placed after the first character, thus \'apply\' would end up as \'pplea\'\r\n        var length = eInput.value ? eInput.value.length : 0;\r\n        if (length > 0) {\r\n            eInput.setSelectionRange(length, length);\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.focusIn = function () {\r\n        this.eInput.focus();\r\n        this.eInput.select();\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.focusOut = function () {\r\n        this.eInput.blur();\r\n        this.autocompleter.destroy();\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.destroy = function () {\r\n        this.focusOut();\r\n        if (this.stopEditing) {\r\n            this.stopEditing();\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.getValue = function () {\r\n        return this.currentItem;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isCancelAfterEnd = function () {\r\n        if (this.required) {\r\n            return !this.currentItem;\r\n        }\r\n        return false;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isCancelBeforeStart = function () {\r\n        return false;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isPopup = function () {\r\n        return false;\r\n    };\r\n    __decorate([\r\n        Object(external_ag_grid_community_["Autowired"])(\'gridOptionsWrapper\')\r\n    ], AutocompleteSelectCellEditor.prototype, "gridOptionsWrapper", void 0);\r\n    return AutocompleteSelectCellEditor;\r\n}(external_ag_grid_community_["PopupComponent"]));\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2F1dG9jb21wbGV0ZXIvYXV0b2NvbXBsZXRlLnRzPzk5ZjUiLCJ3ZWJwYWNrOi8vLy4vYWctZ3JpZC1hdXRvY29tcGxldGUtZWRpdG9yLnRzP2FhNWIiXSwic291cmNlc0NvbnRlbnQiOlsiIC8qXG4gICogaHR0cHM6Ly9naXRodWIuY29tL2tyYWFkZW4vYXV0b2NvbXBsZXRlXG4gICogQ29weXJpZ2h0IChjKSAyMDE2IERlbnlzIEtyYXNub3NoY2hva1xuICAqIE1JVCBMaWNlbnNlXG4gICovXG5cbiBleHBvcnQgY29uc3QgZW51bSBFdmVudFRyaWdnZXIge1xuICAgICBLZXlib2FyZCA9IDAsXG4gICAgIEZvY3VzID0gMVxuIH1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRvY29tcGxldGVJdGVtIHtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBncm91cD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRvY29tcGxldGVTZXR0aW5nczxUIGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbT4ge1xuICAgIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIHJlbmRlcj86IChpdGVtOiBULCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgcmVuZGVyR3JvdXA/OiAobmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIG1pbkxlbmd0aD86IG51bWJlcjtcbiAgICBlbXB0eU1zZz86IHN0cmluZztcbiAgICBzdHJpY3Q6IGJvb2xlYW47XG4gICAgYXV0b3NlbGVjdGZpcnN0OiBib29sZWFuO1xuICAgIG9uRnJlZVRleHRTZWxlY3Q/OiAoaXRlbTogVCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHZvaWQ7XG4gICAgb25TZWxlY3Q6IChpdGVtOiBUIHwgdW5kZWZpbmVkLCBpbnB1dDogSFRNTElucHV0RWxlbWVudCwgZXZlbnQ6IEtleWJvYXJkRXZlbnQgfCBNb3VzZUV2ZW50KSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNob3cgYXV0b2NvbXBsZXRlIG9uIGZvY3VzIGV2ZW50LiBGb2N1cyBldmVudCB3aWxsIGlnbm9yZSB0aGUgYG1pbkxlbmd0aGAgcHJvcGVydHkgYW5kIHdpbGwgYWx3YXlzIGNhbGwgYGZldGNoYC5cbiAgICAgKi9cbiAgICBzaG93T25Gb2N1cz86IGJvb2xlYW47XG4gICAgZmV0Y2g6ICh0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBUW10gfCBmYWxzZSkgPT4gdm9pZCwgdHJpZ2dlcjogRXZlbnRUcmlnZ2VyKSA9PiB2b2lkO1xuICAgIGRlYm91bmNlV2FpdE1zPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZvciBhZGRpdGlvbmFsIGF1dG9jb21wbGV0ZSBjdXN0b21pemF0aW9uXG4gICAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dCAtIGlucHV0IGJveCBhc3NvY2lhdGVkIHdpdGggYXV0b2NvbXBsZXRlXG4gICAgICogQHBhcmFtIHtDbGllbnRSZWN0IHwgRE9NUmVjdH0gaW5wdXRSZWN0IC0gc2l6ZSBvZiB0aGUgaW5wdXQgYm94IGFuZCBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyIC0gY29udGFpbmVyIHdpdGggc3VnZ2VzdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IC0gbWF4IGhlaWdodCB0aGF0IGNhbiBiZSB1c2VkIGJ5IGF1dG9jb21wbGV0ZVxuICAgICAqL1xuICAgIGN1c3RvbWl6ZT86IChpbnB1dDogSFRNTElucHV0RWxlbWVudCwgaW5wdXRSZWN0OiBDbGllbnRSZWN0IHwgRE9NUmVjdCwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgbWF4SGVpZ2h0OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlUmVzdWx0IHtcbiAgICBkZXN0cm95OiAoKSA9PiB2b2lkO1xufVxuXG5jb25zdCBlbnVtIEtleXMge1xuICAgIEVudGVyID0gMTMsXG4gICAgRXNjID0gMjcsXG4gICAgVXAgPSAzOCxcbiAgICBEb3duID0gNDAsXG4gICAgTGVmdCA9IDM3LFxuICAgIFJpZ2h0ID0gMzksXG4gICAgU2hpZnQgPSAxNixcbiAgICBDdHJsID0gMTcsXG4gICAgQWx0ID0gMTgsXG4gICAgQ2Fwc0xvY2sgPSAyMCxcbiAgICBXaW5kb3dzS2V5ID0gOTEsXG4gICAgVGFiID0gOVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhdXRvY29tcGxldGU8VCBleHRlbmRzIEF1dG9jb21wbGV0ZUl0ZW0+KHNldHRpbmdzOiBBdXRvY29tcGxldGVTZXR0aW5nczxUPik6IEF1dG9jb21wbGV0ZVJlc3VsdCB7XG5cbiAgICAvLyBqdXN0IGFuIGFsaWFzIHRvIG1pbmltaXplIEpTIGZpbGUgc2l6ZVxuICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50O1xuXG4gICAgY29uc3QgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgY29uc3QgbW9iaWxlRmlyZWZveCA9IHVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSAhPT0gLTEgJiYgdXNlckFnZW50LmluZGV4T2YoXCJNb2JpbGVcIikgIT09IC0xO1xuICAgIGNvbnN0IGRlYm91bmNlV2FpdE1zID0gc2V0dGluZ3MuZGVib3VuY2VXYWl0TXMgfHwgMDtcbiAgICBjb25zdCBzdHJpY3QgPSBzZXR0aW5ncy5zdHJpY3Q7XG4gICAgY29uc3QgYXV0b3NlbGVjdGZpcnN0ID0gc2V0dGluZ3MuYXV0b3NlbGVjdGZpcnN0O1xuICAgIGNvbnN0IG9uRnJlZVRleHRTZWxlY3QgPSBzZXR0aW5ncy5vbkZyZWVUZXh0U2VsZWN0O1xuXG4gICAgLy8gJ2tleXVwJyBldmVudCB3aWxsIG5vdCBiZSBmaXJlZCBvbiBNb2JpbGUgRmlyZWZveCwgc28gd2UgaGF2ZSB0byB1c2UgJ2lucHV0JyBldmVudCBpbnN0ZWFkXG4gICAgY29uc3Qga2V5VXBFdmVudE5hbWUgPSBtb2JpbGVGaXJlZm94ID8gXCJpbnB1dFwiIDogXCJrZXl1cFwiO1xuXG4gICAgbGV0IGl0ZW1zOiBUW10gPSBbXTtcbiAgICBsZXQgaW5wdXRWYWx1ZSA9IFwiXCI7XG4gICAgY29uc3QgbWluTGVuID0gc2V0dGluZ3MubWluTGVuZ3RoIHx8IDI7XG4gICAgY29uc3Qgc2hvd09uRm9jdXMgPSBzZXR0aW5ncy5zaG93T25Gb2N1cztcbiAgICBsZXQgc2VsZWN0ZWQ6IFQgfCB1bmRlZmluZWQ7XG4gICAgbGV0IGtleXByZXNzQ291bnRlciA9IDA7XG4gICAgbGV0IGRlYm91bmNlVGltZXIgOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIXNldHRpbmdzLmlucHV0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0IHVuZGVmaW5lZFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnB1dDogSFRNTElucHV0RWxlbWVudCA9IHNldHRpbmdzLmlucHV0O1xuXG4gICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiYXV0b2NvbXBsZXRlIFwiICsgKHNldHRpbmdzLmNsYXNzTmFtZSB8fCBcIlwiKTtcbiAgICBjb250YWluZXJTdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcblxuICAgIC8qKlxuICAgICAqIERldGFjaCB0aGUgY29udGFpbmVyIGZyb20gRE9NXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGV0YWNoKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBkZWJvdW5jaW5nIHRpbWVyIGlmIGFzc2lnbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xlYXJEZWJvdW5jZVRpbWVyKCk6IHZvaWQge1xuICAgICAgICBpZiAoZGVib3VuY2VUaW1lcikge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChkZWJvdW5jZVRpbWVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaCB0aGUgY29udGFpbmVyIHRvIERPTVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGF0dGFjaCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFjb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGNvbnRhaW5lciBmb3IgYXV0b2NvbXBsZXRlIGlzIGRpc3BsYXllZFxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY29udGFpbmVyRGlzcGxheWVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISFjb250YWluZXIucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhdXRvY29tcGxldGUgc3RhdGUgYW5kIGhpZGUgY29udGFpbmVyXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjbGVhcigpOiB2b2lkIHtcbiAgICAgICAga2V5cHJlc3NDb3VudGVyKys7XG4gICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgIGlucHV0VmFsdWUgPSBcIlwiO1xuICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZGV0YWNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGF1dG9jb21wbGV0ZSBwb3NpdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCk6IHZvaWQge1xuICAgICAgICBpZiAoIWNvbnRhaW5lckRpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXJTdHlsZS5oZWlnaHQgPSBcImF1dG9cIjtcbiAgICAgICAgY29udGFpbmVyU3R5bGUud2lkdGggPSBpbnB1dC5vZmZzZXRXaWR0aCArIFwicHhcIjtcblxuICAgICAgICBjb25zdCBpbnB1dFJlY3QgPSBpbnB1dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgY29uc3QgdG9wID0gaW5wdXRSZWN0LnRvcCArIGlucHV0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgbGV0IG1heEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcDtcblxuICAgICAgICBpZiAobWF4SGVpZ2h0IDwgMCkge1xuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lclN0eWxlLnRvcCA9IHRvcCArIFwicHhcIjtcbiAgICAgICAgY29udGFpbmVyU3R5bGUuYm90dG9tID0gXCJcIjtcbiAgICAgICAgY29udGFpbmVyU3R5bGUubGVmdCA9IGlucHV0UmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICBjb250YWluZXJTdHlsZS5tYXhIZWlnaHQgPSBtYXhIZWlnaHQgKyBcInB4XCI7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmN1c3RvbWl6ZSkge1xuICAgICAgICAgICAgc2V0dGluZ3MuY3VzdG9taXplKGlucHV0LCBpbnB1dFJlY3QsIGNvbnRhaW5lciwgbWF4SGVpZ2h0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhdyB0aGUgYXV0b2NvbXBsZXRlIGRpdiBlbGVtZW50IHdpdGggc3VnZ2VzdGlvbnNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpOiB2b2lkIHtcblxuICAgICAgICAvLyBkZWxldGUgYWxsIGNoaWxkcmVuIGZyb20gYXV0b2NvbXBsZXRlIERPTSBjb250YWluZXJcbiAgICAgICAgd2hpbGUgKGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZnVuY3Rpb24gZm9yIHJlbmRlcmluZyBhdXRvY29tcGxldGUgc3VnZ2VzdGlvbnNcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkTG9jYWxTeW1ib2xzXG4gICAgICAgIGxldCByZW5kZXIgPSBmdW5jdGlvbihpdGVtOiBULCBjdXJyZW50VmFsdWU6IHN0cmluZyk6IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1FbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBpdGVtRWxlbWVudC50ZXh0Q29udGVudCA9IGl0ZW0ubGFiZWwgfHwgXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBpdGVtRWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnJlbmRlcikge1xuICAgICAgICAgICAgcmVuZGVyID0gc2V0dGluZ3MucmVuZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gcmVuZGVyIGF1dG9jb21wbGV0ZSBncm91cHNcbiAgICAgICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkTG9jYWxTeW1ib2xzXG4gICAgICAgIGxldCByZW5kZXJHcm91cCA9IGZ1bmN0aW9uKGdyb3VwTmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZyk6IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwRGl2ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBncm91cERpdi50ZXh0Q29udGVudCA9IGdyb3VwTmFtZTtcbiAgICAgICAgICAgIHJldHVybiBncm91cERpdjtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnJlbmRlckdyb3VwKSB7XG4gICAgICAgICAgICByZW5kZXJHcm91cCA9IHNldHRpbmdzLnJlbmRlckdyb3VwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgcHJldkdyb3VwID0gXCIjOT8kXCI7XG5cbiAgICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbihpdGVtOiBUKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoaXRlbS5ncm91cCAmJiBpdGVtLmdyb3VwICE9PSBwcmV2R3JvdXApIHtcbiAgICAgICAgICAgICAgICBwcmV2R3JvdXAgPSBpdGVtLmdyb3VwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwRGl2ID0gcmVuZGVyR3JvdXAoaXRlbS5ncm91cCwgaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwRGl2KSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwRGl2LmNsYXNzTmFtZSArPSBcIiBncm91cFwiO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChncm91cERpdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGl2ID0gcmVuZGVyKGl0ZW0sIGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRpdikge1xuICAgICAgICAgICAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZXY6IE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWxlY3QoaXRlbSwgaW5wdXQsIGV2KTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5jbGFzc05hbWUgKz0gXCIgc2VsZWN0ZWRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxICYmIHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5TXNnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW1wdHkgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICBlbXB0eS5jbGFzc05hbWUgPSBcImVtcHR5XCI7XG4gICAgICAgICAgICAgICAgZW1wdHkudGV4dENvbnRlbnQgPSBzZXR0aW5ncy5lbXB0eU1zZztcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHkpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGF0dGFjaCgpO1xuICAgICAgICB1cGRhdGVQb3NpdGlvbigpO1xuXG4gICAgICAgIHVwZGF0ZVNjcm9sbCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUlmRGlzcGxheWVkKCk6IHZvaWQge1xuICAgICAgICBpZiAoY29udGFpbmVyRGlzcGxheWVkKCkpIHtcbiAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzaXplRXZlbnRIYW5kbGVyKCk6IHZvaWQge1xuICAgICAgICB1cGRhdGVJZkRpc3BsYXllZCgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNjcm9sbEV2ZW50SGFuZGxlcihlOiBFdmVudCk6IHZvaWQge1xuICAgICAgICBpZiAoZS50YXJnZXQgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgdXBkYXRlSWZEaXNwbGF5ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleXVwRXZlbnRIYW5kbGVyKGV2OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldi53aGljaCB8fCBldi5rZXlDb2RlIHx8IDA7XG5cbiAgICAgICAgY29uc3QgaWdub3JlID0gW0tleXMuVXAsIEtleXMuRW50ZXIsIEtleXMuRXNjLCBLZXlzLlJpZ2h0LCBLZXlzLkxlZnQsIEtleXMuU2hpZnQsIEtleXMuQ3RybCwgS2V5cy5BbHQsIEtleXMuQ2Fwc0xvY2ssIEtleXMuV2luZG93c0tleSwgS2V5cy5UYWJdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBpZ25vcmUpIHtcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZG93biBrZXkgaXMgdXNlZCB0byBvcGVuIGF1dG9jb21wbGV0ZVxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Eb3duICYmIGNvbnRhaW5lckRpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydEZldGNoKEV2ZW50VHJpZ2dlci5LZXlib2FyZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXV0b21hdGljYWxseSBtb3ZlIHNjcm9sbCBiYXIgaWYgc2VsZWN0ZWQgaXRlbSBpcyBub3QgdmlzaWJsZVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IGNvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwic2VsZWN0ZWRcIik7XG4gICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgZWxlbWVudCA9IGVsZW1lbnRzWzBdIGFzIEhUTUxEaXZFbGVtZW50O1xuXG4gICAgICAgICAgICAvLyBtYWtlIGdyb3VwIHZpc2libGVcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIGFzIEhUTUxEaXZFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzICYmIHByZXZpb3VzLmNsYXNzTmFtZS5pbmRleE9mKFwiZ3JvdXBcIikgIT09IC0xICYmICFwcmV2aW91cy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHByZXZpb3VzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRUb3AgPCBjb250YWluZXIuc2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RCb3R0b20gPSBlbGVtZW50Lm9mZnNldFRvcCArIGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lckJvdHRvbSA9IGNvbnRhaW5lci5zY3JvbGxUb3AgKyBjb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RCb3R0b20gPiBjb250YWluZXJCb3R0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCArPSBzZWxlY3RCb3R0b20gLSBjb250YWluZXJCb3R0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSBwcmV2aW91cyBpdGVtIGluIHN1Z2dlc3Rpb25zXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBzZWxlY3RQcmV2KCk6IHZvaWQge1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IGl0ZW1zWzBdIHx8IHNlbGVjdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IGl0ZW1zW2ldIHx8IGkgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkID0gaXRlbXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIG5leHQgaXRlbSBpbiBzdWdnZXN0aW9uc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2VsZWN0TmV4dCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZWN0ZWQgfHwgc2VsZWN0ZWQgPT09IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zWzBdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKGl0ZW1zLmxlbmd0aCAtIDEpOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCA9PT0gaXRlbXNbaV0pIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGtleWRvd25FdmVudEhhbmRsZXIoZXY6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2LndoaWNoIHx8IGV2LmtleUNvZGUgfHwgMDtcblxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5VcCB8fCBrZXlDb2RlID09PSBLZXlzLkRvd24gfHwga2V5Q29kZSA9PT0gS2V5cy5Fc2MpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lcklzRGlzcGxheWVkID0gY29udGFpbmVyRGlzcGxheWVkKCk7XG5cbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBLZXlzLkVzYykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VsZWN0KHVuZGVmaW5lZCwgaW5wdXQsIGV2KTtcbiAgICAgICAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRhaW5lckRpc3BsYXllZCB8fCBpdGVtcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5Q29kZSA9PT0gS2V5cy5VcFxuICAgICAgICAgICAgICAgICAgICA/IHNlbGVjdFByZXYoKVxuICAgICAgICAgICAgICAgICAgICA6IHNlbGVjdE5leHQoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChjb250YWluZXJJc0Rpc3BsYXllZCkge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5FbnRlciB8fCBrZXlDb2RlID09PSAgS2V5cy5UYWIpIHtcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdChzZWxlY3RlZCwgaW5wdXQsIGV2KTtcbiAgICAgICAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmVlVGV4dFNlbGVjdCA9IHtsYWJlbDogaW5wdXQudmFsdWV9IGFzIFQ7XG4gICAgICAgICAgICAgICAgaWYgKCFzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob25GcmVlVGV4dFNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25GcmVlVGV4dFNlbGVjdChmcmVlVGV4dFNlbGVjdCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VsZWN0KGZyZWVUZXh0U2VsZWN0LCBpbnB1dCwgZXYpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VsZWN0KHNlbGVjdGVkLCBpbnB1dCwgZXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9jdXNFdmVudEhhbmRsZXIoKTogdm9pZCB7XG4gICAgICAgIGlmIChzaG93T25Gb2N1cykge1xuICAgICAgICAgICAgc3RhcnRGZXRjaChFdmVudFRyaWdnZXIuRm9jdXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRGZXRjaCh0cmlnZ2VyOiBFdmVudFRyaWdnZXIpIHtcbiAgICAgICAgLy8gaWYgbXVsdGlwbGUga2V5cyB3ZXJlIHByZXNzZWQsIGJlZm9yZSB3ZSBnZXQgdXBkYXRlIGZyb20gc2VydmVyLFxuICAgICAgICAvLyB0aGlzIG1heSBjYXVzZSByZWRyYXdpbmcgb3VyIGF1dG9jb21wbGV0ZSBtdWx0aXBsZSB0aW1lcyBhZnRlciB0aGUgbGFzdCBrZXkgcHJlc3MuXG4gICAgICAgIC8vIHRvIGF2b2lkIHRoaXMsIHRoZSBudW1iZXIgb2YgdGltZXMga2V5Ym9hcmQgd2FzIHByZXNzZWQgd2lsbCBiZVxuICAgICAgICAvLyBzYXZlZCBhbmQgY2hlY2tlZCBiZWZvcmUgcmVkcmF3IG91ciBhdXRvY29tcGxldGUgYm94LlxuICAgICAgICBjb25zdCBzYXZlZEtleXByZXNzQ291bnRlciA9ICsra2V5cHJlc3NDb3VudGVyO1xuXG4gICAgICAgIGNvbnN0IHZhbCA9IGlucHV0LnZhbHVlO1xuICAgICAgICBpZiAodmFsLmxlbmd0aCA+PSBtaW5MZW4gfHwgdHJpZ2dlciA9PT0gRXZlbnRUcmlnZ2VyLkZvY3VzKSB7XG4gICAgICAgICAgICBjbGVhckRlYm91bmNlVGltZXIoKTtcbiAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5mZXRjaCh2YWwsIGZ1bmN0aW9uKGVsZW1lbnRzOiBUW10gfCBmYWxzZSk6IHZvaWQge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cHJlc3NDb3VudGVyID09PSBzYXZlZEtleXByZXNzQ291bnRlciAmJiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBlbGVtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zLmxlbmd0aCA+IDAgJiYgYXV0b3NlbGVjdGZpcnN0ID8gaXRlbXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIEV2ZW50VHJpZ2dlci5LZXlib2FyZCk7XG4gICAgICAgICAgICB9LCB0cmlnZ2VyID09PSBFdmVudFRyaWdnZXIuS2V5Ym9hcmQgPyBkZWJvdW5jZVdhaXRNcyA6IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJsdXJFdmVudEhhbmRsZXIoKTogdm9pZCB7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGVsYXkgY2xlYXIsIGJlY2F1c2Ugd2hlbiB3ZSBjbGljayBvbiBhbiBpdGVtLCBibHVyIHdpbGwgYmUgY2FsbGVkIGJlZm9yZSBjbGljayBhbmQgcmVtb3ZlIGl0ZW1zIGZyb20gRE9NXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvYy5hY3RpdmVFbGVtZW50ICE9PSBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIHJlbW92ZSBET00gZWxlbWVudHMgYW5kIGNsZWFyIGV2ZW50IGhhbmRsZXJzXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgZm9jdXNFdmVudEhhbmRsZXIpO1xuICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlkb3duRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihrZXlVcEV2ZW50TmFtZSwga2V5dXBFdmVudEhhbmRsZXIgYXMgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCk7XG4gICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJFdmVudEhhbmRsZXIpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemVFdmVudEhhbmRsZXIpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzY3JvbGxFdmVudEhhbmRsZXIsIHRydWUpO1xuICAgICAgICBjbGVhckRlYm91bmNlVGltZXIoKTtcbiAgICAgICAgY2xlYXIoKTtcblxuICAgICAgICAvLyBwcmV2ZW50IHRoZSB1cGRhdGUgY2FsbCBpZiB0aGVyZSBhcmUgcGVuZGluZyBBSkFYIHJlcXVlc3RzXG4gICAgICAgIGtleXByZXNzQ291bnRlcisrO1xuICAgIH1cblxuICAgIC8vIHNldHVwIGV2ZW50IGhhbmRsZXJzXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5ZG93bkV2ZW50SGFuZGxlcik7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihrZXlVcEV2ZW50TmFtZSwga2V5dXBFdmVudEhhbmRsZXIgYXMgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCk7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckV2ZW50SGFuZGxlcik7XG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGZvY3VzRXZlbnRIYW5kbGVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemVFdmVudEhhbmRsZXIpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEV2ZW50SGFuZGxlciwgdHJ1ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkZXN0cm95XG4gICAgfTtcbn1cbiIsImltcG9ydCB7XG4gICAgQXV0b3dpcmVkLFxuICAgIENvbnN0YW50cyxcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIsXG4gICAgSUFmdGVyR3VpQXR0YWNoZWRQYXJhbXMsXG4gICAgSUNlbGxFZGl0b3JDb21wLFxuICAgIElDZWxsRWRpdG9yUGFyYW1zLFxuICAgIFBvcHVwQ29tcG9uZW50LFxuICAgIFN1cHByZXNzS2V5Ym9hcmRFdmVudFBhcmFtc1xufSBmcm9tICdhZy1ncmlkLWNvbW11bml0eSc7XG5cbmltcG9ydCAnLi9hZy1ncmlkLWF1dG9jb21wbGV0ZS1lZGl0b3Iuc2Nzcyc7XG4vLyBUaGlzIGltcG9ydCBtdXN0IGJlIGRvbmUgd2l0aCByZXF1aXJlIGJlY2F1c2Ugb2YgVHlwZVNjcmlwdCB0cmFuc3BpbGVyIHByb2JsZW1zIHdpdGggZXhwb3J0IGRlZmF1bHRcbmltcG9ydCBhdXRvY29tcGxldGUsIHtBdXRvY29tcGxldGVJdGVtLCBFdmVudFRyaWdnZXJ9IGZyb20gJy4vYXV0b2NvbXBsZXRlci9hdXRvY29tcGxldGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIERhdGFGb3JtYXQgZXh0ZW5kcyBBdXRvY29tcGxldGVJdGVtIHtcbiAgICB2YWx1ZTogbnVtYmVyIHwgc3RyaW5nO1xuICAgIGxhYmVsOiBzdHJpbmc7XG4gICAgZ3JvdXA/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCB0eXBlIEF1dG9jb21wbGV0ZUNsaWVudCA9IERhdGFGb3JtYXQgJiBBdXRvY29tcGxldGVJdGVtO1xuXG5pbnRlcmZhY2UgSURlZmF1bHRBdXRvY29tcGxldGVyU2V0dGluZ3M8VCBleHRlbmRzIEF1dG9jb21wbGV0ZUl0ZW0+IHtcbiAgICByZW5kZXI6IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBULCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgcmVuZGVyR3JvdXA6IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBuYW1lOiBzdHJpbmcsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKSA9PiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgICBjbGFzc05hbWU6IHN0cmluZztcbiAgICBtaW5MZW5ndGg6IG51bWJlcjtcbiAgICBlbXB0eU1zZzogc3RyaW5nO1xuICAgIHN0cmljdDogYm9vbGVhbjtcbiAgICBhdXRvc2VsZWN0Zmlyc3Q6IGJvb2xlYW47XG4gICAgb25GcmVlVGV4dFNlbGVjdDogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIGl0ZW06IFQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB2b2lkO1xuICAgIG9uU2VsZWN0OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaXRlbTogVCB8IHVuZGVmaW5lZCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHZvaWQ7XG4gICAgZmV0Y2g6IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCB0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBUW10gfCBmYWxzZSkgPT4gdm9pZCwgdHJpZ2dlcj86IEV2ZW50VHJpZ2dlcikgPT4gdm9pZDtcbiAgICBkZWJvdW5jZVdhaXRNczogbnVtYmVyO1xuICAgIHNob3dPbkZvY3VzOiBib29sZWFuO1xuICAgIGN1c3RvbWl6ZTogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50LCBpbnB1dFJlY3Q6IENsaWVudFJlY3QgfCBET01SZWN0LCBjb250YWluZXI6IEhUTUxEaXZFbGVtZW50LCBtYXhIZWlnaHQ6IG51bWJlcikgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQXV0b2NvbXBsZXRlclNldHRpbmdzPFQgZXh0ZW5kcyBBdXRvY29tcGxldGVJdGVtPiB7XG4gICAgcmVuZGVyPzogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIGl0ZW06IFQsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKSA9PiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgICByZW5kZXJHcm91cD86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBuYW1lOiBzdHJpbmcsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKSA9PiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZDtcbiAgICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gICAgbWluTGVuZ3RoPzogbnVtYmVyO1xuICAgIGVtcHR5TXNnPzogc3RyaW5nO1xuICAgIHN0cmljdD86IGJvb2xlYW47XG4gICAgYXV0b3NlbGVjdGZpcnN0PzogYm9vbGVhbjtcbiAgICBvbkZyZWVUZXh0U2VsZWN0PzogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIGl0ZW06IFQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB2b2lkO1xuICAgIG9uU2VsZWN0PzogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIGl0ZW06IFQgfCB1bmRlZmluZWQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB2b2lkO1xuICAgIGZldGNoPzogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIHRleHQ6IHN0cmluZywgdXBkYXRlOiAoaXRlbXM6IFRbXSB8IGZhbHNlKSA9PiB2b2lkLCB0cmlnZ2VyPzogRXZlbnRUcmlnZ2VyKSA9PiB2b2lkO1xuICAgIGRlYm91bmNlV2FpdE1zPzogbnVtYmVyO1xuICAgIGN1c3RvbWl6ZT86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpbnB1dDogSFRNTElucHV0RWxlbWVudCwgaW5wdXRSZWN0OiBDbGllbnRSZWN0IHwgRE9NUmVjdCwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgbWF4SGVpZ2h0OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3JQYXJhbXMgZXh0ZW5kcyBJQ2VsbEVkaXRvclBhcmFtcyB7XG4gICAgYXV0b2NvbXBsZXRlPzogSUF1dG9jb21wbGV0ZXJTZXR0aW5nczxBdXRvY29tcGxldGVDbGllbnQ+O1xuICAgIHNlbGVjdERhdGE6IEFycmF5PERhdGFGb3JtYXQ+O1xuICAgIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIHJlcXVpcmVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IgZXh0ZW5kcyBQb3B1cENvbXBvbmVudCBpbXBsZW1lbnRzIElDZWxsRWRpdG9yQ29tcCB7XG4gICAgcHJpdmF0ZSBmb2N1c0FmdGVyQXR0YWNoZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGVJbnB1dDogSFRNTElucHV0RWxlbWVudDtcbiAgICBwdWJsaWMgY3VycmVudEl0ZW0/OiBEYXRhRm9ybWF0O1xuICAgIHByaXZhdGUgYXV0b2NvbXBsZXRlcj86IGFueTtcbiAgICBwcml2YXRlIHJlcXVpcmVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBzdG9wRWRpdGluZz86IChjYW5jZWw/OiBib29sZWFuKSA9PiB2b2lkO1xuXG4gICAgQEF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJykgcHJpdmF0ZSBncmlkT3B0aW9uc1dyYXBwZXI/OiBHcmlkT3B0aW9uc1dyYXBwZXI7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJzxkaXYgY2xhc3M9XCJhZy1jZWxsLWVkaXQtaW5wdXRcIiBzdHlsZT1cInBhZGRpbmc6IDAgIWltcG9ydGFudDtcIj48aW5wdXQgY2xhc3M9XCJhZy1jZWxsLWVkaXQtaW5wdXRcIiB0eXBlPVwidGV4dFwiLz48L2Rpdj4nKTtcbiAgICAgICAgdGhpcy5lSW5wdXQgPSB0aGlzLmdldEd1aSgpLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuZUlucHV0LnZhbHVlID0gdGhpcy5jdXJyZW50SXRlbS5sYWJlbCB8fCB0aGlzLmN1cnJlbnRJdGVtLnZhbHVlIGFzIHN0cmluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIHN0YXRpYyBzdXBwcmVzc0tleWJvYXJkRXZlbnQocGFyYW1zOiBTdXBwcmVzc0tleWJvYXJkRXZlbnRQYXJhbXMpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGtleUNvZGUgPSBwYXJhbXMuZXZlbnQua2V5Q29kZTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5lZGl0aW5nICYmIChrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX1VQIHx8IGtleUNvZGUgPT09IENvbnN0YW50cy5LRVlfRE9XTiB8fCBrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX0VOVEVSIHx8IGtleUNvZGUgPT09IENvbnN0YW50cy5LRVlfVEFCKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRTdGFydFZhbHVlKHBhcmFtczogSUF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3JQYXJhbXMpIHtcbiAgICAgICAgY29uc3Qga2V5UHJlc3NCYWNrc3BhY2VPckRlbGV0ZSA9IHBhcmFtcy5rZXlQcmVzcyA9PT0gQ29uc3RhbnRzLktFWV9CQUNLU1BBQ0UgfHwgcGFyYW1zLmtleVByZXNzID09PSBDb25zdGFudHMuS0VZX0RFTEVURTtcbiAgICAgICAgaWYgKGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuY2hhclByZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmNoYXJQcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zLmZvcm1hdFZhbHVlKHBhcmFtcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGluaXQocGFyYW1zOiBJQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvclBhcmFtcykge1xuICAgICAgICB0aGlzLnN0b3BFZGl0aW5nID0gcGFyYW1zLnN0b3BFZGl0aW5nO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2V0dGluZ3M6IElEZWZhdWx0QXV0b2NvbXBsZXRlclNldHRpbmdzPEF1dG9jb21wbGV0ZUNsaWVudD4gPSB7XG4gICAgICAgICAgICBzaG93T25Gb2N1czogZmFsc2UsXG4gICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBBdXRvY29tcGxldGVDbGllbnQsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVnZXggPSBuZXcgUmVnRXhwKHZhbHVlLCAnZ2knKTtcbiAgICAgICAgICAgICAgICBsZXQgZmllbGRJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIGZpZWxkSXRlbS5pbm5lckhUTUwgPSBpdGVtLmxhYmVsLnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uIChtYXRjaDogc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxzdHJvbmc+XCIgKyBtYXRjaCArIFwiPC9zdHJvbmc+XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdGVtRWxlbWVudC5hcHBlbmQoZmllbGRJdGVtKTtcbiAgICAgICAgICAgICAgICBjZWxsRWRpdG9yLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcihpdGVtRWxlbWVudCwgJ21vdXNlZG93bicsIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjZWxsRWRpdG9yLmN1cnJlbnRJdGVtID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1FbGVtZW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlckdyb3VwOiBmdW5jdGlvbiAoY2VsbEVkaXRvciwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBkaXYudGV4dENvbnRlbnQgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGRpdi5jbGFzc05hbWUgPSBcImdyb3VwXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhZy1jZWxsLWVkaXRvci1hdXRvY29tcGxldGUnLFxuICAgICAgICAgICAgbWluTGVuZ3RoOiAxLFxuICAgICAgICAgICAgZW1wdHlNc2c6IFwiTm9uZVwiLFxuICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgYXV0b3NlbGVjdGZpcnN0OiB0cnVlLFxuICAgICAgICAgICAgb25GcmVlVGV4dFNlbGVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiAoY2VsbEVkaXRvciwgaXRlbTogQXV0b2NvbXBsZXRlQ2xpZW50IHwgdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2VsbEVkaXRvci5jdXJyZW50SXRlbSA9IGl0ZW07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmV0Y2g6IChjZWxsRWRpdG9yLCB0ZXh0LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IHBhcmFtcy5zZWxlY3REYXRhIHx8IFtdO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRleHQudG9Mb3dlckNhc2UoKSB8fCBjZWxsRWRpdG9yLmVJbnB1dC52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5sYWJlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YobWF0Y2gpICE9PSAtMTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVib3VuY2VXYWl0TXM6IDIwMCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZTogZnVuY3Rpb24gKGNlbGxFZGl0b3IsIGlucHV0LCBpbnB1dFJlY3QsIGNvbnRhaW5lciwgbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heEhlaWdodCA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUudG9wID0gXCIxMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3R0b20gPSAod2luZG93LmlubmVySGVpZ2h0IC0gaW5wdXRSZWN0LmJvdHRvbSArIGlucHV0Lm9mZnNldEhlaWdodCkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5tYXhIZWlnaHQgPSBcIjE0MHB4XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZvY3VzQWZ0ZXJBdHRhY2hlZCA9IHBhcmFtcy5jZWxsU3RhcnRlZEVkaXQ7XG5cbiAgICAgICAgdGhpcy5lSW5wdXQucGxhY2Vob2xkZXIgPSBwYXJhbXMucGxhY2Vob2xkZXIgfHwgJyc7XG4gICAgICAgIHRoaXMuZUlucHV0LnZhbHVlID0gQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvci5nZXRTdGFydFZhbHVlKHBhcmFtcyk7XG5cbiAgICAgICAgY29uc3QgYXV0b2NvbXBsZXRlUGFyYW1zID0gey4uLmRlZmF1bHRTZXR0aW5ncywgLi4ucGFyYW1zLmF1dG9jb21wbGV0ZX07XG5cbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVyID0gYXV0b2NvbXBsZXRlKHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLmVJbnB1dCxcbiAgICAgICAgICAgIHJlbmRlcjogKGl0ZW06IEF1dG9jb21wbGV0ZUNsaWVudCwgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUGFyYW1zLnJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUGFyYW1zLnJlbmRlcih0aGlzLCBpdGVtLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzLnJlbmRlcih0aGlzLCBpdGVtLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlckdyb3VwOiAobmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdXRvY29tcGxldGVQYXJhbXMucmVuZGVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9jb21wbGV0ZVBhcmFtcy5yZW5kZXJHcm91cCh0aGlzLCBuYW1lLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzLnJlbmRlckdyb3VwKHRoaXMsIG5hbWUsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBhdXRvY29tcGxldGVQYXJhbXMuY2xhc3NOYW1lIHx8IGRlZmF1bHRTZXR0aW5ncy5jbGFzc05hbWUsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IGF1dG9jb21wbGV0ZVBhcmFtcy5taW5MZW5ndGggfHwgZGVmYXVsdFNldHRpbmdzLm1pbkxlbmd0aCxcbiAgICAgICAgICAgIGVtcHR5TXNnOiBhdXRvY29tcGxldGVQYXJhbXMuZW1wdHlNc2cgfHwgZGVmYXVsdFNldHRpbmdzLmVtcHR5TXNnLFxuICAgICAgICAgICAgc3RyaWN0OiBhdXRvY29tcGxldGVQYXJhbXMuc3RyaWN0LFxuICAgICAgICAgICAgYXV0b3NlbGVjdGZpcnN0OiBhdXRvY29tcGxldGVQYXJhbXMuYXV0b3NlbGVjdGZpcnN0LFxuICAgICAgICAgICAgc2hvd09uRm9jdXM6IGF1dG9jb21wbGV0ZVBhcmFtcy5zaG93T25Gb2N1cyxcbiAgICAgICAgICAgIG9uRnJlZVRleHRTZWxlY3Q6IChpdGVtOiBBdXRvY29tcGxldGVDbGllbnQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5vbkZyZWVUZXh0U2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvY29tcGxldGVQYXJhbXMub25GcmVlVGV4dFNlbGVjdCh0aGlzLCBpdGVtLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2V0dGluZ3Mub25GcmVlVGV4dFNlbGVjdCh0aGlzLCBpdGVtLCBpbnB1dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25TZWxlY3Q6IChpdGVtOiBBdXRvY29tcGxldGVDbGllbnQgfCB1bmRlZmluZWQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50LCBldmVudDogS2V5Ym9hcmRFdmVudCB8IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0OiBhbnk7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5vblNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhdXRvY29tcGxldGVQYXJhbXMub25TZWxlY3QodGhpcywgaXRlbSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRhYkV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWZhdWx0U2V0dGluZ3Mub25TZWxlY3QodGhpcywgaXRlbSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUYWJFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmV0Y2g6ICh0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBBdXRvY29tcGxldGVDbGllbnRbXSB8IGZhbHNlKSA9PiB2b2lkLCB0cmlnZ2VyOiBFdmVudFRyaWdnZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUGFyYW1zLmZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvY29tcGxldGVQYXJhbXMuZmV0Y2godGhpcywgdGV4dCwgdXBkYXRlLCB0cmlnZ2VyKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzLmZldGNoKHRoaXMsIHRleHQsIHVwZGF0ZSwgdHJpZ2dlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVib3VuY2VXYWl0TXM6IGF1dG9jb21wbGV0ZVBhcmFtcy5kZWJvdW5jZVdhaXRNcyB8fCBkZWZhdWx0U2V0dGluZ3MuZGVib3VuY2VXYWl0TXMsXG4gICAgICAgICAgICBjdXN0b21pemU6IChpbnB1dDogSFRNTElucHV0RWxlbWVudCwgaW5wdXRSZWN0OiBDbGllbnRSZWN0IHwgRE9NUmVjdCwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgbWF4SGVpZ2h0OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUGFyYW1zLmN1c3RvbWl6ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUGFyYW1zLmN1c3RvbWl6ZSh0aGlzLCBpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2V0dGluZ3MuY3VzdG9taXplKHRoaXMsIGlucHV0LCBpbnB1dFJlY3QsIGNvbnRhaW5lciwgbWF4SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5yZXF1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJhbXMuY29sRGVmLnN1cHByZXNzS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgcGFyYW1zLmNvbERlZi5zdXBwcmVzc0tleWJvYXJkRXZlbnQgPSBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLnN1cHByZXNzS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVRhYkV2ZW50KGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlIHx8IDA7XG4gICAgICAgIGlmIChrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX1RBQiAmJiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlcikge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QXBpKCkhLnRhYlRvUHJldmlvdXNDZWxsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpIS50YWJUb05leHRDZWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyR3VpQXR0YWNoZWQocGFyYW1zPzogSUFmdGVyR3VpQXR0YWNoZWRQYXJhbXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmZvY3VzQWZ0ZXJBdHRhY2hlZCkgeyByZXR1cm47IH1cblxuICAgICAgICBjb25zdCBlSW5wdXQgPSB0aGlzLmVJbnB1dDtcbiAgICAgICAgZUlucHV0LmZvY3VzKCk7XG4gICAgICAgIGVJbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgLy8gd2hlbiB3ZSBzdGFydGVkIGVkaXRpbmcsIHdlIHdhbnQgdGhlIGNhcmV0IGF0IHRoZSBlbmQsIG5vdCB0aGUgc3RhcnQuXG4gICAgICAgIC8vIHRoaXMgY29tZXMgaW50byBwbGF5IGluIHR3byBzY2VuYXJpb3M6IGEpIHdoZW4gdXNlciBoaXRzIEYyIGFuZCBiKVxuICAgICAgICAvLyB3aGVuIHVzZXIgaGl0cyBhIHByaW50YWJsZSBjaGFyYWN0ZXIsIHRoZW4gb24gSUUgKGFuZCBvbmx5IElFKSB0aGUgY2FyZXRcbiAgICAgICAgLy8gd2FzIHBsYWNlZCBhZnRlciB0aGUgZmlyc3QgY2hhcmFjdGVyLCB0aHVzICdhcHBseScgd291bGQgZW5kIHVwIGFzICdwcGxlYSdcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZUlucHV0LnZhbHVlID8gZUlucHV0LnZhbHVlLmxlbmd0aCA6IDA7XG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlSW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXNJbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5lSW5wdXQuc2VsZWN0KCk7XG4gICAgfVxuXG4gICAgZm9jdXNPdXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZUlucHV0LmJsdXIoKTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzT3V0KCk7XG4gICAgICAgIGlmICh0aGlzLnN0b3BFZGl0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRWYWx1ZSgpOiBEYXRhRm9ybWF0IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEl0ZW07XG4gICAgfVxuXG4gICAgaXNDYW5jZWxBZnRlckVuZCgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5jdXJyZW50SXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzQ2FuY2VsQmVmb3JlU3RhcnQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpc1BvcHVwKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7OztBQUlBO0FBMERBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hkQTtBQVdBO0FBQ0E7QUFDQTtBQWdEQTtBQUFBO0FBVUE7QUFBQTtBQVRBO0FBSUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBL01BO0FBQUE7QUFBQTtBQWdOQTtBQUFBO0FBeE5BOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2\n')}])});