!function(g,I){if("object"==typeof exports&&"object"==typeof module)module.exports=I(require("ag-grid-community"));else if("function"==typeof define&&define.amd)define(["ag-grid-community"],I);else{var C="object"==typeof exports?I(require("ag-grid-community")):I(g["ag-grid-community"]);for(var e in C)("object"==typeof exports?exports:g)[e]=C[e]}}(window,(function(__WEBPACK_EXTERNAL_MODULE__0__){return function(g){var I={};function C(e){if(I[e])return I[e].exports;var t=I[e]={i:e,l:!1,exports:{}};return g[e].call(t.exports,t,t.exports,C),t.l=!0,t.exports}return C.m=g,C.c=I,C.d=function(g,I,e){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:e})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var e=Object.create(null);if(C.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var t in g)C.d(e,t,function(I){return g[I]}.bind(null,t));return e},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="http://localhost:8080/",C(C.s=2)}([function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImFnLWdyaWQtY29tbXVuaXR5XCI/ODc0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzBfXzsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FnLWdyaWQtYXV0b2NvbXBsZXRlLWVkaXRvci5zY3NzP2Q4YTEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external "ag-grid-community"\nvar external_ag_grid_community_ = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./ag-grid-autocomplete-editor.scss\nvar ag_grid_autocomplete_editor = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./autocompleter/autocomplete.ts\n/*\r\n * https://github.com/kraaden/autocomplete\r\n * Copyright (c) 2016 Denys Krasnoshchok\r\n * MIT License\r\n */\r\nfunction autocomplete(settings) {\r\n    // just an alias to minimize JS file size\r\n    var doc = document;\r\n    var container = doc.createElement("div");\r\n    var containerStyle = container.style;\r\n    var userAgent = navigator.userAgent;\r\n    var mobileFirefox = userAgent.indexOf("Firefox") !== -1 && userAgent.indexOf("Mobile") !== -1;\r\n    var debounceWaitMs = settings.debounceWaitMs || 0;\r\n    var strict = settings.strict;\r\n    var autoselectfirst = settings.autoselectfirst;\r\n    var onFreeTextSelect = settings.onFreeTextSelect;\r\n    // \'keyup\' event will not be fired on Mobile Firefox, so we have to use \'input\' event instead\r\n    var keyUpEventName = mobileFirefox ? "input" : "keyup";\r\n    var items = [];\r\n    var inputValue = "";\r\n    var minLen = settings.minLength !== undefined ? settings.minLength : 2;\r\n    var showOnFocus = settings.showOnFocus;\r\n    var selected;\r\n    var keypressCounter = 0;\r\n    var debounceTimer;\r\n    if (!settings.input) {\r\n        throw new Error("input undefined");\r\n    }\r\n    var input = settings.input;\r\n    container.className = "autocomplete " + (settings.className || "");\r\n    containerStyle.position = "fixed";\r\n    /**\r\n     * Detach the container from DOM\r\n     */\r\n    function detach() {\r\n        var parent = container.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(container);\r\n        }\r\n    }\r\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\r\n    function clearDebounceTimer() {\r\n        if (debounceTimer) {\r\n            window.clearTimeout(debounceTimer);\r\n        }\r\n    }\r\n    /**\r\n     * Attach the container to DOM\r\n     */\r\n    function attach() {\r\n        if (!container.parentNode) {\r\n            doc.body.appendChild(container);\r\n        }\r\n    }\r\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\r\n    function containerDisplayed() {\r\n        return !!container.parentNode;\r\n    }\r\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\r\n    function clear() {\r\n        keypressCounter++;\r\n        items = [];\r\n        inputValue = "";\r\n        selected = undefined;\r\n        detach();\r\n    }\r\n    /**\r\n     * Update autocomplete position\r\n     */\r\n    function updatePosition() {\r\n        if (!containerDisplayed()) {\r\n            return;\r\n        }\r\n        containerStyle.height = "auto";\r\n        containerStyle.width = input.offsetWidth + "px";\r\n        var inputRect = input.getBoundingClientRect();\r\n        var top = inputRect.top + input.offsetHeight;\r\n        var maxHeight = window.innerHeight - top;\r\n        if (maxHeight < 0) {\r\n            maxHeight = 0;\r\n        }\r\n        containerStyle.top = top + "px";\r\n        containerStyle.bottom = "";\r\n        containerStyle.left = inputRect.left + "px";\r\n        containerStyle.maxHeight = maxHeight + "px";\r\n        if (settings.customize) {\r\n            settings.customize(input, inputRect, container, maxHeight);\r\n        }\r\n    }\r\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\r\n    function update() {\r\n        // delete all children from autocomplete DOM container\r\n        while (container.firstChild) {\r\n            container.removeChild(container.firstChild);\r\n        }\r\n        // function for rendering autocomplete suggestions\r\n        // noinspection JSUnusedLocalSymbols\r\n        var render = function (item, currentValue) {\r\n            var itemElement = doc.createElement("div");\r\n            itemElement.textContent = item.label || "";\r\n            return itemElement;\r\n        };\r\n        if (settings.render) {\r\n            render = settings.render;\r\n        }\r\n        // function to render autocomplete groups\r\n        // noinspection JSUnusedLocalSymbols\r\n        var renderGroup = function (groupName, currentValue) {\r\n            var groupDiv = doc.createElement("div");\r\n            groupDiv.textContent = groupName;\r\n            return groupDiv;\r\n        };\r\n        if (settings.renderGroup) {\r\n            renderGroup = settings.renderGroup;\r\n        }\r\n        var fragment = doc.createDocumentFragment();\r\n        var prevGroup = "#9?$";\r\n        items.forEach(function (item) {\r\n            if (item.group && item.group !== prevGroup) {\r\n                prevGroup = item.group;\r\n                var groupDiv = renderGroup(item.group, inputValue);\r\n                if (groupDiv) {\r\n                    groupDiv.className += " group";\r\n                    fragment.appendChild(groupDiv);\r\n                }\r\n            }\r\n            var div = render(item, inputValue);\r\n            if (div) {\r\n                div.addEventListener("click", function (ev) {\r\n                    settings.onSelect(item, input, ev);\r\n                    clear();\r\n                    ev.preventDefault();\r\n                    ev.stopPropagation();\r\n                });\r\n                if (item === selected) {\r\n                    div.className += " selected";\r\n                }\r\n                fragment.appendChild(div);\r\n            }\r\n        });\r\n        container.appendChild(fragment);\r\n        if (items.length < 1 && strict) {\r\n            if (settings.emptyMsg) {\r\n                var empty = doc.createElement("div");\r\n                empty.className = "empty";\r\n                empty.textContent = settings.emptyMsg;\r\n                container.appendChild(empty);\r\n                selected = undefined;\r\n            }\r\n            else {\r\n                clear();\r\n                return;\r\n            }\r\n        }\r\n        attach();\r\n        updatePosition();\r\n        updateScroll();\r\n    }\r\n    function updateIfDisplayed() {\r\n        if (containerDisplayed()) {\r\n            update();\r\n        }\r\n    }\r\n    function resizeEventHandler() {\r\n        updateIfDisplayed();\r\n    }\r\n    function scrollEventHandler(e) {\r\n        if (e.target !== container) {\r\n            updateIfDisplayed();\r\n        }\r\n        else {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n    function keyupEventHandler(ev) {\r\n        var keyCode = ev.which || ev.keyCode || 0;\r\n        var ignore = [38 /* Up */, 13 /* Enter */, 27 /* Esc */, 39 /* Right */, 37 /* Left */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */];\r\n        for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {\r\n            var key = ignore_1[_i];\r\n            if (keyCode === key) {\r\n                return;\r\n            }\r\n        }\r\n        // the down key is used to open autocomplete\r\n        if (keyCode === 40 /* Down */ && containerDisplayed()) {\r\n            return;\r\n        }\r\n        startFetch(0 /* Keyboard */);\r\n    }\r\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\r\n    function updateScroll() {\r\n        var elements = container.getElementsByClassName("selected");\r\n        if (elements.length > 0) {\r\n            var element = elements[0];\r\n            // make group visible\r\n            var previous = element.previousElementSibling;\r\n            if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {\r\n                element = previous;\r\n            }\r\n            if (element.offsetTop < container.scrollTop) {\r\n                container.scrollTop = element.offsetTop;\r\n            }\r\n            else {\r\n                var selectBottom = element.offsetTop + element.offsetHeight;\r\n                var containerBottom = container.scrollTop + container.offsetHeight;\r\n                if (selectBottom > containerBottom) {\r\n                    container.scrollTop += selectBottom - containerBottom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Select the previous item in suggestions\r\n     */\r\n    function selectPrev() {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        else {\r\n            if (selected === items[0] || selected === undefined) {\r\n                selected = items[items.length - 1];\r\n            }\r\n            else {\r\n                for (var i = items.length - 1; i > 0; i--) {\r\n                    if (selected === items[i] || i === 1) {\r\n                        selected = items[i - 1];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Select the next item in suggestions\r\n     */\r\n    function selectNext() {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        if (!selected || selected === items[items.length - 1]) {\r\n            selected = items[0];\r\n            return;\r\n        }\r\n        for (var i = 0; i < (items.length - 1); i++) {\r\n            if (selected === items[i]) {\r\n                selected = items[i + 1];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    function keydownEventHandler(ev) {\r\n        var keyCode = ev.which || ev.keyCode || 0;\r\n        if (keyCode === 38 /* Up */ || keyCode === 40 /* Down */ || keyCode === 27 /* Esc */) {\r\n            var containerIsDisplayed = containerDisplayed();\r\n            if (keyCode === 27 /* Esc */) {\r\n                settings.onSelect(undefined, input, ev);\r\n                clear();\r\n            }\r\n            else {\r\n                if (!containerDisplayed || items.length < 1) {\r\n                    return;\r\n                }\r\n                keyCode === 38 /* Up */\r\n                    ? selectPrev()\r\n                    : selectNext();\r\n                update();\r\n            }\r\n            ev.preventDefault();\r\n            if (containerIsDisplayed) {\r\n                ev.stopPropagation();\r\n            }\r\n            return;\r\n        }\r\n        if (keyCode === 13 /* Enter */ || keyCode === 9 /* Tab */) {\r\n            if (strict) {\r\n                settings.onSelect(selected, input, ev);\r\n                clear();\r\n            }\r\n            if (!strict) {\r\n                var freeTextSelect = { label: input.value };\r\n                if (!selected) {\r\n                    if (onFreeTextSelect) {\r\n                        onFreeTextSelect(freeTextSelect, input);\r\n                    }\r\n                    settings.onSelect(freeTextSelect, input, ev);\r\n                }\r\n                else {\r\n                    settings.onSelect(selected, input, ev);\r\n                }\r\n                clear();\r\n            }\r\n        }\r\n    }\r\n    function focusEventHandler() {\r\n        if (showOnFocus) {\r\n            startFetch(1 /* Focus */);\r\n        }\r\n    }\r\n    function startFetch(trigger) {\r\n        // if multiple keys were pressed, before we get update from server,\r\n        // this may cause redrawing our autocomplete multiple times after the last key press.\r\n        // to avoid this, the number of times keyboard was pressed will be\r\n        // saved and checked before redraw our autocomplete box.\r\n        var savedKeypressCounter = ++keypressCounter;\r\n        var val = input.value;\r\n        if (val.length >= minLen || trigger === 1 /* Focus */) {\r\n            clearDebounceTimer();\r\n            debounceTimer = window.setTimeout(function () {\r\n                settings.fetch(val, function (elements) {\r\n                    if (keypressCounter === savedKeypressCounter && elements) {\r\n                        items = elements;\r\n                        inputValue = val;\r\n                        selected = items.length > 0 && autoselectfirst ? items[0] : undefined;\r\n                        update();\r\n                    }\r\n                }, 0 /* Keyboard */);\r\n            }, trigger === 0 /* Keyboard */ ? debounceWaitMs : 0);\r\n        }\r\n        else {\r\n            clear();\r\n        }\r\n    }\r\n    function blurEventHandler() {\r\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\r\n        setTimeout(function () {\r\n            if (doc.activeElement !== input) {\r\n                clear();\r\n            }\r\n        }, 200);\r\n    }\r\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\r\n    function destroy() {\r\n        input.removeEventListener("focus", focusEventHandler);\r\n        input.removeEventListener("keydown", keydownEventHandler);\r\n        input.removeEventListener(keyUpEventName, keyupEventHandler);\r\n        input.removeEventListener("blur", blurEventHandler);\r\n        window.removeEventListener("resize", resizeEventHandler);\r\n        doc.removeEventListener("scroll", scrollEventHandler, true);\r\n        clearDebounceTimer();\r\n        clear();\r\n        // prevent the update call if there are pending AJAX requests\r\n        keypressCounter++;\r\n    }\r\n    // setup event handlers\r\n    input.addEventListener("keydown", keydownEventHandler);\r\n    input.addEventListener(keyUpEventName, keyupEventHandler);\r\n    input.addEventListener("blur", blurEventHandler);\r\n    input.addEventListener("focus", focusEventHandler);\r\n    window.addEventListener("resize", resizeEventHandler);\r\n    doc.addEventListener("scroll", scrollEventHandler, true);\r\n    return {\r\n        destroy: destroy\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./ag-grid-autocomplete-editor.ts\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutocompleteSelectCellEditor", function() { return ag_grid_autocomplete_editor_AutocompleteSelectCellEditor; });\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n// This import must be done with require because of TypeScript transpiler problems with export default\r\n\r\nvar ag_grid_autocomplete_editor_AutocompleteSelectCellEditor = /** @class */ (function (_super) {\r\n    __extends(AutocompleteSelectCellEditor, _super);\r\n    function AutocompleteSelectCellEditor() {\r\n        var _this = _super.call(this, \'<div class="ag-cell-edit-input" style="padding: 0 !important;"><input class="ag-cell-edit-input" type="text"/></div>\') || this;\r\n        _this.focusAfterAttached = false;\r\n        _this.required = false;\r\n        _this.eInput = _this.getGui().querySelector(\'input\');\r\n        if (_this.currentItem) {\r\n            _this.eInput.value = _this.currentItem.label || _this.currentItem.value;\r\n        }\r\n        return _this;\r\n    }\r\n    AutocompleteSelectCellEditor.suppressKeyboardEvent = function (params) {\r\n        var keyCode = params.event.keyCode;\r\n        return params.editing && (keyCode === external_ag_grid_community_["Constants"].KEY_UP || keyCode === external_ag_grid_community_["Constants"].KEY_DOWN || keyCode === external_ag_grid_community_["Constants"].KEY_ENTER || keyCode === external_ag_grid_community_["Constants"].KEY_TAB);\r\n    };\r\n    AutocompleteSelectCellEditor.getStartValue = function (params) {\r\n        var keyPressBackspaceOrDelete = params.keyPress === external_ag_grid_community_["Constants"].KEY_BACKSPACE || params.keyPress === external_ag_grid_community_["Constants"].KEY_DELETE;\r\n        if (keyPressBackspaceOrDelete) {\r\n            return \'\';\r\n        }\r\n        else if (params.charPress) {\r\n            return params.charPress;\r\n        }\r\n        return params.formatValue(params.value);\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.init = function (params) {\r\n        var _this = this;\r\n        this.stopEditing = params.stopEditing;\r\n        var defaultSettings = {\r\n            showOnFocus: false,\r\n            render: function (cellEditor, item, value) {\r\n                var itemElement = document.createElement("div");\r\n                var regex = new RegExp(value, \'gi\');\r\n                var fieldItem = document.createElement(\'span\');\r\n                fieldItem.innerHTML = item.label.replace(regex, function (match) {\r\n                    return "<strong>" + match + "</strong>";\r\n                });\r\n                itemElement.appendChild(fieldItem);\r\n                cellEditor.addDestroyableEventListener(itemElement, \'mousedown\', function (event) {\r\n                    cellEditor.currentItem = item;\r\n                    event.stopPropagation();\r\n                });\r\n                return itemElement;\r\n            },\r\n            renderGroup: function (cellEditor, name) {\r\n                var div = document.createElement(\'div\');\r\n                div.textContent = name;\r\n                div.className = "group";\r\n                return div;\r\n            },\r\n            className: \'ag-cell-editor-autocomplete\',\r\n            minLength: 1,\r\n            emptyMsg: "None",\r\n            strict: true,\r\n            autoselectfirst: true,\r\n            onFreeTextSelect: function () {\r\n            },\r\n            onSelect: function (cellEditor, item) {\r\n                cellEditor.currentItem = item;\r\n            },\r\n            fetch: function (cellEditor, text, callback) {\r\n                var items = _this.getSelectData(params);\r\n                var match = text.toLowerCase() || cellEditor.eInput.value.toLowerCase();\r\n                callback(items.filter(function (n) {\r\n                    return n.label.toLowerCase().indexOf(match) !== -1;\r\n                }));\r\n            },\r\n            debounceWaitMs: 200,\r\n            customize: function (cellEditor, input, inputRect, container, maxHeight) {\r\n                if (maxHeight < 100) {\r\n                    container.style.top = "10px";\r\n                    container.style.bottom = (window.innerHeight - inputRect.bottom + input.offsetHeight) + "px";\r\n                    container.style.maxHeight = "140px";\r\n                }\r\n            }\r\n        };\r\n        this.focusAfterAttached = params.cellStartedEdit;\r\n        this.eInput.placeholder = params.placeholder || \'\';\r\n        this.eInput.value = AutocompleteSelectCellEditor.getStartValue(params);\r\n        var autocompleteParams = __assign(__assign({}, defaultSettings), params.autocomplete);\r\n        this.autocompleter = autocomplete({\r\n            input: this.eInput,\r\n            render: function (item, currentValue) {\r\n                if (autocompleteParams.render) {\r\n                    return autocompleteParams.render(_this, item, currentValue);\r\n                }\r\n                return defaultSettings.render(_this, item, currentValue);\r\n            },\r\n            renderGroup: function (name, currentValue) {\r\n                if (autocompleteParams.renderGroup) {\r\n                    return autocompleteParams.renderGroup(_this, name, currentValue);\r\n                }\r\n                return defaultSettings.renderGroup(_this, name, currentValue);\r\n            },\r\n            className: autocompleteParams.className || defaultSettings.className,\r\n            minLength: autocompleteParams.minLength !== undefined ? autocompleteParams.minLength : defaultSettings.minLength,\r\n            emptyMsg: autocompleteParams.emptyMsg || defaultSettings.emptyMsg,\r\n            strict: autocompleteParams.strict,\r\n            autoselectfirst: autocompleteParams.autoselectfirst,\r\n            showOnFocus: autocompleteParams.showOnFocus,\r\n            onFreeTextSelect: function (item, input) {\r\n                if (autocompleteParams.onFreeTextSelect) {\r\n                    return autocompleteParams.onFreeTextSelect(_this, item, input);\r\n                }\r\n                return defaultSettings.onFreeTextSelect(_this, item, input);\r\n            },\r\n            onSelect: function (item, input, event) {\r\n                var result;\r\n                if (autocompleteParams.onSelect) {\r\n                    result = autocompleteParams.onSelect(_this, item, input);\r\n                    if (event instanceof KeyboardEvent) {\r\n                        _this.handleTabEvent(event);\r\n                    }\r\n                    else {\r\n                        _this.destroy();\r\n                    }\r\n                    return result;\r\n                }\r\n                result = defaultSettings.onSelect(_this, item, input);\r\n                if (event instanceof KeyboardEvent) {\r\n                    _this.handleTabEvent(event);\r\n                }\r\n                else {\r\n                    _this.destroy();\r\n                }\r\n                return result;\r\n            },\r\n            fetch: function (text, update, trigger) {\r\n                if (autocompleteParams.fetch) {\r\n                    return autocompleteParams.fetch(_this, text, update, trigger);\r\n                }\r\n                return defaultSettings.fetch(_this, text, update, trigger);\r\n            },\r\n            debounceWaitMs: autocompleteParams.debounceWaitMs || defaultSettings.debounceWaitMs,\r\n            customize: function (input, inputRect, container, maxHeight) {\r\n                if (autocompleteParams.customize) {\r\n                    return autocompleteParams.customize(_this, input, inputRect, container, maxHeight);\r\n                }\r\n                return defaultSettings.customize(_this, input, inputRect, container, maxHeight);\r\n            }\r\n        });\r\n        if (params.required) {\r\n            this.required = true;\r\n        }\r\n        if (!params.colDef.suppressKeyboardEvent) {\r\n            params.colDef.suppressKeyboardEvent = AutocompleteSelectCellEditor.suppressKeyboardEvent;\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.handleTabEvent = function (event) {\r\n        var keyCode = event.which || event.keyCode || 0;\r\n        if (keyCode === external_ag_grid_community_["Constants"].KEY_TAB && this.gridOptionsWrapper) {\r\n            if (event.shiftKey) {\r\n                this.gridOptionsWrapper.getApi().tabToPreviousCell();\r\n            }\r\n            else {\r\n                this.gridOptionsWrapper.getApi().tabToNextCell();\r\n            }\r\n        }\r\n        else {\r\n            this.destroy();\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.afterGuiAttached = function (params) {\r\n        if (!this.focusAfterAttached) {\r\n            return;\r\n        }\r\n        var eInput = this.eInput;\r\n        eInput.focus();\r\n        eInput.select();\r\n        // when we started editing, we want the caret at the end, not the start.\r\n        // this comes into play in two scenarios: a) when user hits F2 and b)\r\n        // when user hits a printable character, then on IE (and only IE) the caret\r\n        // was placed after the first character, thus \'apply\' would end up as \'pplea\'\r\n        var length = eInput.value ? eInput.value.length : 0;\r\n        if (length > 0) {\r\n            eInput.setSelectionRange(length, length);\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.focusIn = function () {\r\n        this.eInput.focus();\r\n        this.eInput.select();\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.focusOut = function () {\r\n        this.eInput.blur();\r\n        this.autocompleter.destroy();\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.destroy = function () {\r\n        this.focusOut();\r\n        if (this.stopEditing) {\r\n            this.stopEditing();\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.getValue = function () {\r\n        return this.currentItem;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isCancelAfterEnd = function () {\r\n        if (this.required) {\r\n            return !this.currentItem;\r\n        }\r\n        return false;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isCancelBeforeStart = function () {\r\n        return false;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isPopup = function () {\r\n        return false;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.getSelectData = function (params) {\r\n        if (typeof params.selectData === \'function\') {\r\n            return params.selectData(params);\r\n        }\r\n        if (Array.isArray(params.selectData)) {\r\n            return params.selectData;\r\n        }\r\n        return [];\r\n    };\r\n    __decorate([\r\n        Object(external_ag_grid_community_["Autowired"])(\'gridOptionsWrapper\')\r\n    ], AutocompleteSelectCellEditor.prototype, "gridOptionsWrapper", void 0);\r\n    return AutocompleteSelectCellEditor;\r\n}(external_ag_grid_community_["PopupComponent"]));\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2F1dG9jb21wbGV0ZXIvYXV0b2NvbXBsZXRlLnRzPzk5ZjUiLCJ3ZWJwYWNrOi8vLy4vYWctZ3JpZC1hdXRvY29tcGxldGUtZWRpdG9yLnRzP2FhNWIiXSwic291cmNlc0NvbnRlbnQiOlsiIC8qXG4gICogaHR0cHM6Ly9naXRodWIuY29tL2tyYWFkZW4vYXV0b2NvbXBsZXRlXG4gICogQ29weXJpZ2h0IChjKSAyMDE2IERlbnlzIEtyYXNub3NoY2hva1xuICAqIE1JVCBMaWNlbnNlXG4gICovXG5cbiBleHBvcnQgY29uc3QgZW51bSBFdmVudFRyaWdnZXIge1xuICAgICBLZXlib2FyZCA9IDAsXG4gICAgIEZvY3VzID0gMVxuIH1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRvY29tcGxldGVJdGVtIHtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBncm91cD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRvY29tcGxldGVTZXR0aW5nczxUIGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbT4ge1xuICAgIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIHJlbmRlcj86IChpdGVtOiBULCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgcmVuZGVyR3JvdXA/OiAobmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIG1pbkxlbmd0aD86IG51bWJlcjtcbiAgICBlbXB0eU1zZz86IHN0cmluZztcbiAgICBzdHJpY3Q6IGJvb2xlYW47XG4gICAgYXV0b3NlbGVjdGZpcnN0OiBib29sZWFuO1xuICAgIG9uRnJlZVRleHRTZWxlY3Q/OiAoaXRlbTogVCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHZvaWQ7XG4gICAgb25TZWxlY3Q6IChpdGVtOiBUIHwgdW5kZWZpbmVkLCBpbnB1dDogSFRNTElucHV0RWxlbWVudCwgZXZlbnQ6IEtleWJvYXJkRXZlbnQgfCBNb3VzZUV2ZW50KSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNob3cgYXV0b2NvbXBsZXRlIG9uIGZvY3VzIGV2ZW50LiBGb2N1cyBldmVudCB3aWxsIGlnbm9yZSB0aGUgYG1pbkxlbmd0aGAgcHJvcGVydHkgYW5kIHdpbGwgYWx3YXlzIGNhbGwgYGZldGNoYC5cbiAgICAgKi9cbiAgICBzaG93T25Gb2N1cz86IGJvb2xlYW47XG4gICAgZmV0Y2g6ICh0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBUW10gfCBmYWxzZSkgPT4gdm9pZCwgdHJpZ2dlcjogRXZlbnRUcmlnZ2VyKSA9PiB2b2lkO1xuICAgIGRlYm91bmNlV2FpdE1zPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZvciBhZGRpdGlvbmFsIGF1dG9jb21wbGV0ZSBjdXN0b21pemF0aW9uXG4gICAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dCAtIGlucHV0IGJveCBhc3NvY2lhdGVkIHdpdGggYXV0b2NvbXBsZXRlXG4gICAgICogQHBhcmFtIHtDbGllbnRSZWN0IHwgRE9NUmVjdH0gaW5wdXRSZWN0IC0gc2l6ZSBvZiB0aGUgaW5wdXQgYm94IGFuZCBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyIC0gY29udGFpbmVyIHdpdGggc3VnZ2VzdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IC0gbWF4IGhlaWdodCB0aGF0IGNhbiBiZSB1c2VkIGJ5IGF1dG9jb21wbGV0ZVxuICAgICAqL1xuICAgIGN1c3RvbWl6ZT86IChpbnB1dDogSFRNTElucHV0RWxlbWVudCwgaW5wdXRSZWN0OiBDbGllbnRSZWN0IHwgRE9NUmVjdCwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgbWF4SGVpZ2h0OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlUmVzdWx0IHtcbiAgICBkZXN0cm95OiAoKSA9PiB2b2lkO1xufVxuXG5jb25zdCBlbnVtIEtleXMge1xuICAgIEVudGVyID0gMTMsXG4gICAgRXNjID0gMjcsXG4gICAgVXAgPSAzOCxcbiAgICBEb3duID0gNDAsXG4gICAgTGVmdCA9IDM3LFxuICAgIFJpZ2h0ID0gMzksXG4gICAgU2hpZnQgPSAxNixcbiAgICBDdHJsID0gMTcsXG4gICAgQWx0ID0gMTgsXG4gICAgQ2Fwc0xvY2sgPSAyMCxcbiAgICBXaW5kb3dzS2V5ID0gOTEsXG4gICAgVGFiID0gOVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhdXRvY29tcGxldGU8VCBleHRlbmRzIEF1dG9jb21wbGV0ZUl0ZW0+KHNldHRpbmdzOiBBdXRvY29tcGxldGVTZXR0aW5nczxUPik6IEF1dG9jb21wbGV0ZVJlc3VsdCB7XG5cbiAgICAvLyBqdXN0IGFuIGFsaWFzIHRvIG1pbmltaXplIEpTIGZpbGUgc2l6ZVxuICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50O1xuXG4gICAgY29uc3QgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgY29uc3QgbW9iaWxlRmlyZWZveCA9IHVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSAhPT0gLTEgJiYgdXNlckFnZW50LmluZGV4T2YoXCJNb2JpbGVcIikgIT09IC0xO1xuICAgIGNvbnN0IGRlYm91bmNlV2FpdE1zID0gc2V0dGluZ3MuZGVib3VuY2VXYWl0TXMgfHwgMDtcbiAgICBjb25zdCBzdHJpY3QgPSBzZXR0aW5ncy5zdHJpY3Q7XG4gICAgY29uc3QgYXV0b3NlbGVjdGZpcnN0ID0gc2V0dGluZ3MuYXV0b3NlbGVjdGZpcnN0O1xuICAgIGNvbnN0IG9uRnJlZVRleHRTZWxlY3QgPSBzZXR0aW5ncy5vbkZyZWVUZXh0U2VsZWN0O1xuXG4gICAgLy8gJ2tleXVwJyBldmVudCB3aWxsIG5vdCBiZSBmaXJlZCBvbiBNb2JpbGUgRmlyZWZveCwgc28gd2UgaGF2ZSB0byB1c2UgJ2lucHV0JyBldmVudCBpbnN0ZWFkXG4gICAgY29uc3Qga2V5VXBFdmVudE5hbWUgPSBtb2JpbGVGaXJlZm94ID8gXCJpbnB1dFwiIDogXCJrZXl1cFwiO1xuXG4gICAgbGV0IGl0ZW1zOiBUW10gPSBbXTtcbiAgICBsZXQgaW5wdXRWYWx1ZSA9IFwiXCI7XG4gICAgY29uc3QgbWluTGVuID0gc2V0dGluZ3MubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBzZXR0aW5ncy5taW5MZW5ndGggOiAyO1xuICAgIGNvbnN0IHNob3dPbkZvY3VzID0gc2V0dGluZ3Muc2hvd09uRm9jdXM7XG4gICAgbGV0IHNlbGVjdGVkOiBUIHwgdW5kZWZpbmVkO1xuICAgIGxldCBrZXlwcmVzc0NvdW50ZXIgPSAwO1xuICAgIGxldCBkZWJvdW5jZVRpbWVyIDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFzZXR0aW5ncy5pbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB1bmRlZmluZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQgPSBzZXR0aW5ncy5pbnB1dDtcblxuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcImF1dG9jb21wbGV0ZSBcIiArIChzZXR0aW5ncy5jbGFzc05hbWUgfHwgXCJcIik7XG4gICAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggdGhlIGNvbnRhaW5lciBmcm9tIERPTVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGFjaCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgZGVib3VuY2luZyB0aW1lciBpZiBhc3NpZ25lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFyRGVib3VuY2VUaW1lcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKGRlYm91bmNlVGltZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoZGVib3VuY2VUaW1lcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggdGhlIGNvbnRhaW5lciB0byBET01cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdHRhY2goKTogdm9pZCB7XG4gICAgICAgIGlmICghY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjb250YWluZXIgZm9yIGF1dG9jb21wbGV0ZSBpcyBkaXNwbGF5ZWRcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5lckRpc3BsYXllZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYXV0b2NvbXBsZXRlIHN0YXRlIGFuZCBoaWRlIGNvbnRhaW5lclxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIGtleXByZXNzQ291bnRlcisrO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBpbnB1dFZhbHVlID0gXCJcIjtcbiAgICAgICAgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGRldGFjaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhdXRvY29tcGxldGUgcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFjb250YWluZXJEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyU3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLndpZHRoID0gaW5wdXQub2Zmc2V0V2lkdGggKyBcInB4XCI7XG5cbiAgICAgICAgY29uc3QgaW5wdXRSZWN0ID0gaW5wdXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRvcCA9IGlucHV0UmVjdC50b3AgKyBpbnB1dC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGxldCBtYXhIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3A7XG5cbiAgICAgICAgaWYgKG1heEhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIG1heEhlaWdodCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXJTdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLmJvdHRvbSA9IFwiXCI7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLmxlZnQgPSBpbnB1dFJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgICAgY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXN0b21pemUpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmN1c3RvbWl6ZShpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgdGhlIGF1dG9jb21wbGV0ZSBkaXYgZWxlbWVudCB3aXRoIHN1Z2dlc3Rpb25zXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZGVsZXRlIGFsbCBjaGlsZHJlbiBmcm9tIGF1dG9jb21wbGV0ZSBET00gY29udGFpbmVyXG4gICAgICAgIHdoaWxlIChjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zXG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZExvY2FsU3ltYm9sc1xuICAgICAgICBsZXQgcmVuZGVyID0gZnVuY3Rpb24oaXRlbTogVCwgY3VycmVudFZhbHVlOiBzdHJpbmcpOiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZCB7XG4gICAgICAgICAgICBjb25zdCBpdGVtRWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgaXRlbUVsZW1lbnQudGV4dENvbnRlbnQgPSBpdGVtLmxhYmVsIHx8IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gaXRlbUVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXIpIHtcbiAgICAgICAgICAgIHJlbmRlciA9IHNldHRpbmdzLnJlbmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIHJlbmRlciBhdXRvY29tcGxldGUgZ3JvdXBzXG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZExvY2FsU3ltYm9sc1xuICAgICAgICBsZXQgcmVuZGVyR3JvdXAgPSBmdW5jdGlvbihncm91cE5hbWU6IHN0cmluZywgY3VycmVudFZhbHVlOiBzdHJpbmcpOiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZCB7XG4gICAgICAgICAgICBjb25zdCBncm91cERpdiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZ3JvdXBEaXYudGV4dENvbnRlbnQgPSBncm91cE5hbWU7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBEaXY7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXJHcm91cCkge1xuICAgICAgICAgICAgcmVuZGVyR3JvdXAgPSBzZXR0aW5ncy5yZW5kZXJHcm91cDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgbGV0IHByZXZHcm91cCA9IFwiIzk/JFwiO1xuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbTogVCk6IHZvaWQge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZ3JvdXAgJiYgaXRlbS5ncm91cCAhPT0gcHJldkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcHJldkdyb3VwID0gaXRlbS5ncm91cDtcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cERpdiA9IHJlbmRlckdyb3VwKGl0ZW0uZ3JvdXAsIGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChncm91cERpdikge1xuICAgICAgICAgICAgICAgICAgICBncm91cERpdi5jbGFzc05hbWUgKz0gXCIgZ3JvdXBcIjtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZ3JvdXBEaXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpdiA9IHJlbmRlcihpdGVtLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkaXYpIHtcbiAgICAgICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VsZWN0KGl0ZW0sIGlucHV0LCBldik7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXYuY2xhc3NOYW1lICs9IFwiIHNlbGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMSAmJiBzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbXB0eU1zZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgZW1wdHkuY2xhc3NOYW1lID0gXCJlbXB0eVwiO1xuICAgICAgICAgICAgICAgIGVtcHR5LnRleHRDb250ZW50ID0gc2V0dGluZ3MuZW1wdHlNc2c7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVtcHR5KTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhdHRhY2goKTtcbiAgICAgICAgdXBkYXRlUG9zaXRpb24oKTtcblxuICAgICAgICB1cGRhdGVTY3JvbGwoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVJZkRpc3BsYXllZCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lckRpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZUV2ZW50SGFuZGxlcigpOiB2b2lkIHtcbiAgICAgICAgdXBkYXRlSWZEaXNwbGF5ZWQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxFdmVudEhhbmRsZXIoZTogRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgIHVwZGF0ZUlmRGlzcGxheWVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXl1cEV2ZW50SGFuZGxlcihldjogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gZXYud2hpY2ggfHwgZXYua2V5Q29kZSB8fCAwO1xuXG4gICAgICAgIGNvbnN0IGlnbm9yZSA9IFtLZXlzLlVwLCBLZXlzLkVudGVyLCBLZXlzLkVzYywgS2V5cy5SaWdodCwgS2V5cy5MZWZ0LCBLZXlzLlNoaWZ0LCBLZXlzLkN0cmwsIEtleXMuQWx0LCBLZXlzLkNhcHNMb2NrLCBLZXlzLldpbmRvd3NLZXksIEtleXMuVGFiXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgaWdub3JlKSB7XG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGRvd24ga2V5IGlzIHVzZWQgdG8gb3BlbiBhdXRvY29tcGxldGVcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRG93biAmJiBjb250YWluZXJEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRGZXRjaChFdmVudFRyaWdnZXIuS2V5Ym9hcmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgbW92ZSBzY3JvbGwgYmFyIGlmIHNlbGVjdGVkIGl0ZW0gaXMgbm90IHZpc2libGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBjb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInNlbGVjdGVkXCIpO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBlbGVtZW50c1swXSBhcyBIVE1MRGl2RWxlbWVudDtcblxuICAgICAgICAgICAgLy8gbWFrZSBncm91cCB2aXNpYmxlXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZyBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cy5jbGFzc05hbWUuaW5kZXhPZihcImdyb3VwXCIpICE9PSAtMSAmJiAhcHJldmlvdXMucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwcmV2aW91cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0VG9wIDwgY29udGFpbmVyLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0Qm90dG9tID0gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJCb3R0b20gPSBjb250YWluZXIuc2Nyb2xsVG9wICsgY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0Qm90dG9tID4gY29udGFpbmVyQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2VsZWN0Qm90dG9tIC0gY29udGFpbmVyQm90dG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgcHJldmlvdXMgaXRlbSBpbiBzdWdnZXN0aW9uc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2VsZWN0UHJldigpOiB2b2lkIHtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1swXSB8fCBzZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSB8fCBpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSBuZXh0IGl0ZW0gaW4gc3VnZ2VzdGlvbnNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHNlbGVjdE5leHQoKTogdm9pZCB7XG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGVjdGVkIHx8IHNlbGVjdGVkID09PSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1swXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChpdGVtcy5sZW5ndGggLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IGl0ZW1zW2ldKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpICsgMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXlkb3duRXZlbnRIYW5kbGVyKGV2OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldi53aGljaCB8fCBldi5rZXlDb2RlIHx8IDA7XG5cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuVXAgfHwga2V5Q29kZSA9PT0gS2V5cy5Eb3duIHx8IGtleUNvZGUgPT09IEtleXMuRXNjKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJJc0Rpc3BsYXllZCA9IGNvbnRhaW5lckRpc3BsYXllZCgpO1xuXG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Fc2MpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdCh1bmRlZmluZWQsIGlucHV0LCBldik7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXJEaXNwbGF5ZWQgfHwgaXRlbXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleUNvZGUgPT09IEtleXMuVXBcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxlY3RQcmV2KClcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxlY3ROZXh0KCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVySXNEaXNwbGF5ZWQpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRW50ZXIgfHwga2V5Q29kZSA9PT0gIEtleXMuVGFiKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWxlY3Qoc2VsZWN0ZWQsIGlucHV0LCBldik7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJlZVRleHRTZWxlY3QgPSB7bGFiZWw6IGlucHV0LnZhbHVlfSBhcyBUO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRnJlZVRleHRTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRnJlZVRleHRTZWxlY3QoZnJlZVRleHRTZWxlY3QsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdChmcmVlVGV4dFNlbGVjdCwgaW5wdXQsIGV2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdChzZWxlY3RlZCwgaW5wdXQsIGV2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvY3VzRXZlbnRIYW5kbGVyKCk6IHZvaWQge1xuICAgICAgICBpZiAoc2hvd09uRm9jdXMpIHtcbiAgICAgICAgICAgIHN0YXJ0RmV0Y2goRXZlbnRUcmlnZ2VyLkZvY3VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0RmV0Y2godHJpZ2dlcjogRXZlbnRUcmlnZ2VyKSB7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlIGtleXMgd2VyZSBwcmVzc2VkLCBiZWZvcmUgd2UgZ2V0IHVwZGF0ZSBmcm9tIHNlcnZlcixcbiAgICAgICAgLy8gdGhpcyBtYXkgY2F1c2UgcmVkcmF3aW5nIG91ciBhdXRvY29tcGxldGUgbXVsdGlwbGUgdGltZXMgYWZ0ZXIgdGhlIGxhc3Qga2V5IHByZXNzLlxuICAgICAgICAvLyB0byBhdm9pZCB0aGlzLCB0aGUgbnVtYmVyIG9mIHRpbWVzIGtleWJvYXJkIHdhcyBwcmVzc2VkIHdpbGwgYmVcbiAgICAgICAgLy8gc2F2ZWQgYW5kIGNoZWNrZWQgYmVmb3JlIHJlZHJhdyBvdXIgYXV0b2NvbXBsZXRlIGJveC5cbiAgICAgICAgY29uc3Qgc2F2ZWRLZXlwcmVzc0NvdW50ZXIgPSArK2tleXByZXNzQ291bnRlcjtcblxuICAgICAgICBjb25zdCB2YWwgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPj0gbWluTGVuIHx8IHRyaWdnZXIgPT09IEV2ZW50VHJpZ2dlci5Gb2N1cykge1xuICAgICAgICAgICAgY2xlYXJEZWJvdW5jZVRpbWVyKCk7XG4gICAgICAgICAgICBkZWJvdW5jZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKTogdm9pZCB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZmV0Y2godmFsLCBmdW5jdGlvbihlbGVtZW50czogVFtdIHwgZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXByZXNzQ291bnRlciA9PT0gc2F2ZWRLZXlwcmVzc0NvdW50ZXIgJiYgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtcy5sZW5ndGggPiAwICYmIGF1dG9zZWxlY3RmaXJzdCA/IGl0ZW1zWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBFdmVudFRyaWdnZXIuS2V5Ym9hcmQpO1xuICAgICAgICAgICAgfSwgdHJpZ2dlciA9PT0gRXZlbnRUcmlnZ2VyLktleWJvYXJkID8gZGVib3VuY2VXYWl0TXMgOiAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBibHVyRXZlbnRIYW5kbGVyKCk6IHZvaWQge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGF5IGNsZWFyLCBiZWNhdXNlIHdoZW4gd2UgY2xpY2sgb24gYW4gaXRlbSwgYmx1ciB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgY2xpY2sgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIERPTVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChkb2MuYWN0aXZlRWxlbWVudCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZW1vdmUgRE9NIGVsZW1lbnRzIGFuZCBjbGVhciBldmVudCBoYW5kbGVyc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGZvY3VzRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5ZG93bkV2ZW50SGFuZGxlcik7XG4gICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5VXBFdmVudE5hbWUsIGtleXVwRXZlbnRIYW5kbGVyIGFzIEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpO1xuICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2Nyb2xsRXZlbnRIYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgY2xlYXJEZWJvdW5jZVRpbWVyKCk7XG4gICAgICAgIGNsZWFyKCk7XG5cbiAgICAgICAgLy8gcHJldmVudCB0aGUgdXBkYXRlIGNhbGwgaWYgdGhlcmUgYXJlIHBlbmRpbmcgQUpBWCByZXF1ZXN0c1xuICAgICAgICBrZXlwcmVzc0NvdW50ZXIrKztcbiAgICB9XG5cbiAgICAvLyBzZXR1cCBldmVudCBoYW5kbGVyc1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtleWRvd25FdmVudEhhbmRsZXIpO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoa2V5VXBFdmVudE5hbWUsIGtleXVwRXZlbnRIYW5kbGVyIGFzIEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJFdmVudEhhbmRsZXIpO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBmb2N1c0V2ZW50SGFuZGxlcik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzY3JvbGxFdmVudEhhbmRsZXIsIHRydWUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveVxuICAgIH07XG59XG4iLCJpbXBvcnQge1xuICAgIEF1dG93aXJlZCxcbiAgICBDb25zdGFudHMsXG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLFxuICAgIElBZnRlckd1aUF0dGFjaGVkUGFyYW1zLFxuICAgIElDZWxsRWRpdG9yQ29tcCxcbiAgICBJQ2VsbEVkaXRvclBhcmFtcyxcbiAgICBQb3B1cENvbXBvbmVudCxcbiAgICBTdXBwcmVzc0tleWJvYXJkRXZlbnRQYXJhbXNcbn0gZnJvbSAnYWctZ3JpZC1jb21tdW5pdHknO1xuXG5pbXBvcnQgJy4vYWctZ3JpZC1hdXRvY29tcGxldGUtZWRpdG9yLnNjc3MnO1xuLy8gVGhpcyBpbXBvcnQgbXVzdCBiZSBkb25lIHdpdGggcmVxdWlyZSBiZWNhdXNlIG9mIFR5cGVTY3JpcHQgdHJhbnNwaWxlciBwcm9ibGVtcyB3aXRoIGV4cG9ydCBkZWZhdWx0XG5pbXBvcnQgYXV0b2NvbXBsZXRlLCB7QXV0b2NvbXBsZXRlSXRlbSwgRXZlbnRUcmlnZ2VyfSBmcm9tICcuL2F1dG9jb21wbGV0ZXIvYXV0b2NvbXBsZXRlJztcblxuZXhwb3J0IGludGVyZmFjZSBEYXRhRm9ybWF0IGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbSB7XG4gICAgdmFsdWU6IG51bWJlciB8IHN0cmluZztcbiAgICBsYWJlbDogc3RyaW5nO1xuICAgIGdyb3VwPzogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBBdXRvY29tcGxldGVDbGllbnQgPSBEYXRhRm9ybWF0ICYgQXV0b2NvbXBsZXRlSXRlbTtcblxuaW50ZXJmYWNlIElEZWZhdWx0QXV0b2NvbXBsZXRlclNldHRpbmdzPFQgZXh0ZW5kcyBBdXRvY29tcGxldGVJdGVtPiB7XG4gICAgcmVuZGVyOiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaXRlbTogVCwgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIHJlbmRlckdyb3VwOiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgbmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgY2xhc3NOYW1lOiBzdHJpbmc7XG4gICAgbWluTGVuZ3RoOiBudW1iZXI7XG4gICAgZW1wdHlNc2c6IHN0cmluZztcbiAgICBzdHJpY3Q6IGJvb2xlYW47XG4gICAgYXV0b3NlbGVjdGZpcnN0OiBib29sZWFuO1xuICAgIG9uRnJlZVRleHRTZWxlY3Q6IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBULCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcbiAgICBvblNlbGVjdDogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIGl0ZW06IFQgfCB1bmRlZmluZWQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB2b2lkO1xuICAgIGZldGNoOiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgdGV4dDogc3RyaW5nLCB1cGRhdGU6IChpdGVtczogVFtdIHwgZmFsc2UpID0+IHZvaWQsIHRyaWdnZXI/OiBFdmVudFRyaWdnZXIpID0+IHZvaWQ7XG4gICAgZGVib3VuY2VXYWl0TXM6IG51bWJlcjtcbiAgICBzaG93T25Gb2N1czogYm9vbGVhbjtcbiAgICBjdXN0b21pemU6IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpbnB1dDogSFRNTElucHV0RWxlbWVudCwgaW5wdXRSZWN0OiBDbGllbnRSZWN0IHwgRE9NUmVjdCwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgbWF4SGVpZ2h0OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUF1dG9jb21wbGV0ZXJTZXR0aW5nczxUIGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbT4ge1xuICAgIHJlbmRlcj86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBULCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgcmVuZGVyR3JvdXA/OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgbmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIG1pbkxlbmd0aD86IG51bWJlcjtcbiAgICBlbXB0eU1zZz86IHN0cmluZztcbiAgICBzdHJpY3Q/OiBib29sZWFuO1xuICAgIGF1dG9zZWxlY3RmaXJzdD86IGJvb2xlYW47XG4gICAgb25GcmVlVGV4dFNlbGVjdD86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBULCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcbiAgICBvblNlbGVjdD86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBUIHwgdW5kZWZpbmVkLCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcbiAgICBmZXRjaD86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCB0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBUW10gfCBmYWxzZSkgPT4gdm9pZCwgdHJpZ2dlcj86IEV2ZW50VHJpZ2dlcikgPT4gdm9pZDtcbiAgICBkZWJvdW5jZVdhaXRNcz86IG51bWJlcjtcbiAgICBjdXN0b21pemU/OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIGlucHV0UmVjdDogQ2xpZW50UmVjdCB8IERPTVJlY3QsIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIG1heEhlaWdodDogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yUGFyYW1zIGV4dGVuZHMgSUNlbGxFZGl0b3JQYXJhbXMge1xuICAgIGF1dG9jb21wbGV0ZT86IElBdXRvY29tcGxldGVyU2V0dGluZ3M8QXV0b2NvbXBsZXRlQ2xpZW50PjtcbiAgICBzZWxlY3REYXRhOiBBcnJheTxEYXRhRm9ybWF0PiB8ICgocGFyYW1zOiBJQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvclBhcmFtcykgPT4gQXJyYXk8RGF0YUZvcm1hdD4pO1xuICAgIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuICAgIHJlcXVpcmVkPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGNsYXNzIEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IgZXh0ZW5kcyBQb3B1cENvbXBvbmVudCBpbXBsZW1lbnRzIElDZWxsRWRpdG9yQ29tcCB7XG4gICAgcHJpdmF0ZSBmb2N1c0FmdGVyQXR0YWNoZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IGVJbnB1dDogSFRNTElucHV0RWxlbWVudDtcbiAgICBwdWJsaWMgY3VycmVudEl0ZW0/OiBEYXRhRm9ybWF0O1xuICAgIHByaXZhdGUgYXV0b2NvbXBsZXRlcj86IGFueTtcbiAgICBwcml2YXRlIHJlcXVpcmVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBzdG9wRWRpdGluZz86IChjYW5jZWw/OiBib29sZWFuKSA9PiB2b2lkO1xuXG4gICAgQEF1dG93aXJlZCgnZ3JpZE9wdGlvbnNXcmFwcGVyJykgcHJpdmF0ZSBncmlkT3B0aW9uc1dyYXBwZXI/OiBHcmlkT3B0aW9uc1dyYXBwZXI7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoJzxkaXYgY2xhc3M9XCJhZy1jZWxsLWVkaXQtaW5wdXRcIiBzdHlsZT1cInBhZGRpbmc6IDAgIWltcG9ydGFudDtcIj48aW5wdXQgY2xhc3M9XCJhZy1jZWxsLWVkaXQtaW5wdXRcIiB0eXBlPVwidGV4dFwiLz48L2Rpdj4nKTtcbiAgICAgICAgdGhpcy5lSW5wdXQgPSB0aGlzLmdldEd1aSgpLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0JykgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEl0ZW0pIHtcbiAgICAgICAgICAgIHRoaXMuZUlucHV0LnZhbHVlID0gdGhpcy5jdXJyZW50SXRlbS5sYWJlbCB8fCB0aGlzLmN1cnJlbnRJdGVtLnZhbHVlIGFzIHN0cmluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIHN0YXRpYyBzdXBwcmVzc0tleWJvYXJkRXZlbnQocGFyYW1zOiBTdXBwcmVzc0tleWJvYXJkRXZlbnRQYXJhbXMpOiBib29sZWFuIHtcbiAgICAgICAgbGV0IGtleUNvZGUgPSBwYXJhbXMuZXZlbnQua2V5Q29kZTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy5lZGl0aW5nICYmIChrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX1VQIHx8IGtleUNvZGUgPT09IENvbnN0YW50cy5LRVlfRE9XTiB8fCBrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX0VOVEVSIHx8IGtleUNvZGUgPT09IENvbnN0YW50cy5LRVlfVEFCKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBnZXRTdGFydFZhbHVlKHBhcmFtczogSUF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3JQYXJhbXMpIHtcbiAgICAgICAgY29uc3Qga2V5UHJlc3NCYWNrc3BhY2VPckRlbGV0ZSA9IHBhcmFtcy5rZXlQcmVzcyA9PT0gQ29uc3RhbnRzLktFWV9CQUNLU1BBQ0UgfHwgcGFyYW1zLmtleVByZXNzID09PSBDb25zdGFudHMuS0VZX0RFTEVURTtcbiAgICAgICAgaWYgKGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfSBlbHNlIGlmIChwYXJhbXMuY2hhclByZXNzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLmNoYXJQcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zLmZvcm1hdFZhbHVlKHBhcmFtcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgcHVibGljIGluaXQocGFyYW1zOiBJQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvclBhcmFtcykge1xuICAgICAgICB0aGlzLnN0b3BFZGl0aW5nID0gcGFyYW1zLnN0b3BFZGl0aW5nO1xuICAgICAgICBjb25zdCBkZWZhdWx0U2V0dGluZ3M6IElEZWZhdWx0QXV0b2NvbXBsZXRlclNldHRpbmdzPEF1dG9jb21wbGV0ZUNsaWVudD4gPSB7XG4gICAgICAgICAgICBzaG93T25Gb2N1czogZmFsc2UsXG4gICAgICAgICAgICByZW5kZXI6IGZ1bmN0aW9uIChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBBdXRvY29tcGxldGVDbGllbnQsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgICAgICBsZXQgcmVnZXggPSBuZXcgUmVnRXhwKHZhbHVlLCAnZ2knKTtcbiAgICAgICAgICAgICAgICBsZXQgZmllbGRJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIGZpZWxkSXRlbS5pbm5lckhUTUwgPSBpdGVtLmxhYmVsLnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uIChtYXRjaDogc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjxzdHJvbmc+XCIgKyBtYXRjaCArIFwiPC9zdHJvbmc+XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpdGVtRWxlbWVudC5hcHBlbmRDaGlsZChmaWVsZEl0ZW0pO1xuICAgICAgICAgICAgICAgIGNlbGxFZGl0b3IuYWRkRGVzdHJveWFibGVFdmVudExpc3RlbmVyKGl0ZW1FbGVtZW50LCAnbW91c2Vkb3duJywgKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxFZGl0b3IuY3VycmVudEl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbUVsZW1lbnQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVuZGVyR3JvdXA6IGZ1bmN0aW9uIChjZWxsRWRpdG9yLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGRpdi50ZXh0Q29udGVudCA9IG5hbWU7XG4gICAgICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwiZ3JvdXBcIjtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGl2O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2FnLWNlbGwtZWRpdG9yLWF1dG9jb21wbGV0ZScsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IDEsXG4gICAgICAgICAgICBlbXB0eU1zZzogXCJOb25lXCIsXG4gICAgICAgICAgICBzdHJpY3Q6IHRydWUsXG4gICAgICAgICAgICBhdXRvc2VsZWN0Zmlyc3Q6IHRydWUsXG4gICAgICAgICAgICBvbkZyZWVUZXh0U2VsZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25TZWxlY3Q6IGZ1bmN0aW9uIChjZWxsRWRpdG9yLCBpdGVtOiBBdXRvY29tcGxldGVDbGllbnQgfCB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjZWxsRWRpdG9yLmN1cnJlbnRJdGVtID0gaXRlbTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmZXRjaDogKGNlbGxFZGl0b3IsIHRleHQsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gdGhpcy5nZXRTZWxlY3REYXRhKHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGV4dC50b0xvd2VyQ2FzZSgpIHx8IGNlbGxFZGl0b3IuZUlucHV0LnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuLmxhYmVsLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihtYXRjaCkgIT09IC0xO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWJvdW5jZVdhaXRNczogMjAwLFxuICAgICAgICAgICAgY3VzdG9taXplOiBmdW5jdGlvbiAoY2VsbEVkaXRvciwgaW5wdXQsIGlucHV0UmVjdCwgY29udGFpbmVyLCBtYXhIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4SGVpZ2h0IDwgMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSBcIjEwcHhcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvdHRvbSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBpbnB1dFJlY3QuYm90dG9tICsgaW5wdXQub2Zmc2V0SGVpZ2h0KSArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLm1heEhlaWdodCA9IFwiMTQwcHhcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9jdXNBZnRlckF0dGFjaGVkID0gcGFyYW1zLmNlbGxTdGFydGVkRWRpdDtcblxuICAgICAgICB0aGlzLmVJbnB1dC5wbGFjZWhvbGRlciA9IHBhcmFtcy5wbGFjZWhvbGRlciB8fCAnJztcbiAgICAgICAgdGhpcy5lSW5wdXQudmFsdWUgPSBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLmdldFN0YXJ0VmFsdWUocGFyYW1zKTtcblxuICAgICAgICBjb25zdCBhdXRvY29tcGxldGVQYXJhbXMgPSB7Li4uZGVmYXVsdFNldHRpbmdzLCAuLi5wYXJhbXMuYXV0b2NvbXBsZXRlfTtcblxuICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZXIgPSBhdXRvY29tcGxldGUoe1xuICAgICAgICAgICAgaW5wdXQ6IHRoaXMuZUlucHV0LFxuICAgICAgICAgICAgcmVuZGVyOiAoaXRlbTogQXV0b2NvbXBsZXRlQ2xpZW50LCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdXRvY29tcGxldGVQYXJhbXMucmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvY29tcGxldGVQYXJhbXMucmVuZGVyKHRoaXMsIGl0ZW0sIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2V0dGluZ3MucmVuZGVyKHRoaXMsIGl0ZW0sIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVuZGVyR3JvdXA6IChuYW1lOiBzdHJpbmcsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5yZW5kZXJHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUGFyYW1zLnJlbmRlckdyb3VwKHRoaXMsIG5hbWUsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2V0dGluZ3MucmVuZGVyR3JvdXAodGhpcywgbmFtZSwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzc05hbWU6IGF1dG9jb21wbGV0ZVBhcmFtcy5jbGFzc05hbWUgfHwgZGVmYXVsdFNldHRpbmdzLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIG1pbkxlbmd0aDogYXV0b2NvbXBsZXRlUGFyYW1zLm1pbkxlbmd0aCAhPT0gdW5kZWZpbmVkID8gYXV0b2NvbXBsZXRlUGFyYW1zLm1pbkxlbmd0aCA6IGRlZmF1bHRTZXR0aW5ncy5taW5MZW5ndGgsXG4gICAgICAgICAgICBlbXB0eU1zZzogYXV0b2NvbXBsZXRlUGFyYW1zLmVtcHR5TXNnIHx8IGRlZmF1bHRTZXR0aW5ncy5lbXB0eU1zZyxcbiAgICAgICAgICAgIHN0cmljdDogYXV0b2NvbXBsZXRlUGFyYW1zLnN0cmljdCxcbiAgICAgICAgICAgIGF1dG9zZWxlY3RmaXJzdDogYXV0b2NvbXBsZXRlUGFyYW1zLmF1dG9zZWxlY3RmaXJzdCxcbiAgICAgICAgICAgIHNob3dPbkZvY3VzOiBhdXRvY29tcGxldGVQYXJhbXMuc2hvd09uRm9jdXMsXG4gICAgICAgICAgICBvbkZyZWVUZXh0U2VsZWN0OiAoaXRlbTogQXV0b2NvbXBsZXRlQ2xpZW50LCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdXRvY29tcGxldGVQYXJhbXMub25GcmVlVGV4dFNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUGFyYW1zLm9uRnJlZVRleHRTZWxlY3QodGhpcywgaXRlbSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzLm9uRnJlZVRleHRTZWxlY3QodGhpcywgaXRlbSwgaW5wdXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU2VsZWN0OiAoaXRlbTogQXV0b2NvbXBsZXRlQ2xpZW50IHwgdW5kZWZpbmVkLCBpbnB1dDogSFRNTElucHV0RWxlbWVudCwgZXZlbnQ6IEtleWJvYXJkRXZlbnQgfCBNb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdDogYW55O1xuICAgICAgICAgICAgICAgIGlmIChhdXRvY29tcGxldGVQYXJhbXMub25TZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYXV0b2NvbXBsZXRlUGFyYW1zLm9uU2VsZWN0KHRoaXMsIGl0ZW0sIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUYWJFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWZhdWx0U2V0dGluZ3Mub25TZWxlY3QodGhpcywgaXRlbSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUYWJFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmV0Y2g6ICh0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBBdXRvY29tcGxldGVDbGllbnRbXSB8IGZhbHNlKSA9PiB2b2lkLCB0cmlnZ2VyOiBFdmVudFRyaWdnZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUGFyYW1zLmZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvY29tcGxldGVQYXJhbXMuZmV0Y2godGhpcywgdGV4dCwgdXBkYXRlLCB0cmlnZ2VyKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzLmZldGNoKHRoaXMsIHRleHQsIHVwZGF0ZSwgdHJpZ2dlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVib3VuY2VXYWl0TXM6IGF1dG9jb21wbGV0ZVBhcmFtcy5kZWJvdW5jZVdhaXRNcyB8fCBkZWZhdWx0U2V0dGluZ3MuZGVib3VuY2VXYWl0TXMsXG4gICAgICAgICAgICBjdXN0b21pemU6IChpbnB1dDogSFRNTElucHV0RWxlbWVudCwgaW5wdXRSZWN0OiBDbGllbnRSZWN0IHwgRE9NUmVjdCwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgbWF4SGVpZ2h0OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUGFyYW1zLmN1c3RvbWl6ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUGFyYW1zLmN1c3RvbWl6ZSh0aGlzLCBpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2V0dGluZ3MuY3VzdG9taXplKHRoaXMsIGlucHV0LCBpbnB1dFJlY3QsIGNvbnRhaW5lciwgbWF4SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHBhcmFtcy5yZXF1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJhbXMuY29sRGVmLnN1cHByZXNzS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgcGFyYW1zLmNvbERlZi5zdXBwcmVzc0tleWJvYXJkRXZlbnQgPSBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLnN1cHByZXNzS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVRhYkV2ZW50KGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlIHx8IDA7XG4gICAgICAgIGlmIChrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX1RBQiAmJiB0aGlzLmdyaWRPcHRpb25zV3JhcHBlcikge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIuZ2V0QXBpKCkhLnRhYlRvUHJldmlvdXNDZWxsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpIS50YWJUb05leHRDZWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFmdGVyR3VpQXR0YWNoZWQocGFyYW1zPzogSUFmdGVyR3VpQXR0YWNoZWRQYXJhbXMpOiB2b2lkIHtcbiAgICAgICAgaWYgKCF0aGlzLmZvY3VzQWZ0ZXJBdHRhY2hlZCkgeyByZXR1cm47IH1cblxuICAgICAgICBjb25zdCBlSW5wdXQgPSB0aGlzLmVJbnB1dDtcbiAgICAgICAgZUlucHV0LmZvY3VzKCk7XG4gICAgICAgIGVJbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgLy8gd2hlbiB3ZSBzdGFydGVkIGVkaXRpbmcsIHdlIHdhbnQgdGhlIGNhcmV0IGF0IHRoZSBlbmQsIG5vdCB0aGUgc3RhcnQuXG4gICAgICAgIC8vIHRoaXMgY29tZXMgaW50byBwbGF5IGluIHR3byBzY2VuYXJpb3M6IGEpIHdoZW4gdXNlciBoaXRzIEYyIGFuZCBiKVxuICAgICAgICAvLyB3aGVuIHVzZXIgaGl0cyBhIHByaW50YWJsZSBjaGFyYWN0ZXIsIHRoZW4gb24gSUUgKGFuZCBvbmx5IElFKSB0aGUgY2FyZXRcbiAgICAgICAgLy8gd2FzIHBsYWNlZCBhZnRlciB0aGUgZmlyc3QgY2hhcmFjdGVyLCB0aHVzICdhcHBseScgd291bGQgZW5kIHVwIGFzICdwcGxlYSdcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZUlucHV0LnZhbHVlID8gZUlucHV0LnZhbHVlLmxlbmd0aCA6IDA7XG4gICAgICAgIGlmIChsZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBlSW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UobGVuZ3RoLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXNJbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5lSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgdGhpcy5lSW5wdXQuc2VsZWN0KCk7XG4gICAgfVxuXG4gICAgZm9jdXNPdXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZUlucHV0LmJsdXIoKTtcbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVyLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmZvY3VzT3V0KCk7XG4gICAgICAgIGlmICh0aGlzLnN0b3BFZGl0aW5nKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRWYWx1ZSgpOiBEYXRhRm9ybWF0IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEl0ZW07XG4gICAgfVxuXG4gICAgaXNDYW5jZWxBZnRlckVuZCgpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5jdXJyZW50SXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlzQ2FuY2VsQmVmb3JlU3RhcnQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpc1BvcHVwKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZ2V0U2VsZWN0RGF0YShwYXJhbXM6IElBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yUGFyYW1zKTogQXJyYXk8RGF0YUZvcm1hdD4ge1xuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcy5zZWxlY3REYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zLnNlbGVjdERhdGEocGFyYW1zKTtcbiAgICAgICAgfSBcblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMuc2VsZWN0RGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXMuc2VsZWN0RGF0YSBhcyBBcnJheTxEYXRhRm9ybWF0PjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7O0FBSUE7QUEwREE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeGRBO0FBV0E7QUFDQTtBQUNBO0FBZ0RBO0FBQUE7QUFVQTtBQUFBO0FBVEE7QUFJQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUEvTkE7QUFBQTtBQUFBO0FBZ09BO0FBQUE7QUF4T0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')}])}));