!function(g,I){if("object"==typeof exports&&"object"==typeof module)module.exports=I(require("ag-grid-community"));else if("function"==typeof define&&define.amd)define(["ag-grid-community"],I);else{var C="object"==typeof exports?I(require("ag-grid-community")):I(g["ag-grid-community"]);for(var e in C)("object"==typeof exports?exports:g)[e]=C[e]}}(window,function(__WEBPACK_EXTERNAL_MODULE__0__){return function(g){var I={};function C(e){if(I[e])return I[e].exports;var t=I[e]={i:e,l:!1,exports:{}};return g[e].call(t.exports,t,t.exports,C),t.l=!0,t.exports}return C.m=g,C.c=I,C.d=function(g,I,e){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:e})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var e=Object.create(null);if(C.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var t in g)C.d(e,t,function(I){return g[I]}.bind(null,t));return e},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="http://localhost:8080/",C(C.s=2)}([function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImFnLWdyaWQtY29tbXVuaXR5XCI/ODc0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzBfXzsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FnLWdyaWQtYXV0b2NvbXBsZXRlLWVkaXRvci5zY3NzP2E4NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external "ag-grid-community"\nvar external_ag_grid_community_ = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./ag-grid-autocomplete-editor.scss\nvar ag_grid_autocomplete_editor = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./autocompleter/autocomplete.ts\n/*\r\n * https://github.com/kraaden/autocomplete\r\n * Copyright (c) 2016 Denys Krasnoshchok\r\n * MIT License\r\n */\r\nfunction autocomplete(settings) {\r\n    // just an alias to minimize JS file size\r\n    var doc = document;\r\n    var container = doc.createElement("div");\r\n    var containerStyle = container.style;\r\n    var userAgent = navigator.userAgent;\r\n    var mobileFirefox = userAgent.indexOf("Firefox") !== -1 && userAgent.indexOf("Mobile") !== -1;\r\n    var debounceWaitMs = settings.debounceWaitMs || 0;\r\n    var strict = settings.strict;\r\n    var autoselectfirst = settings.autoselectfirst;\r\n    var onFreeTextSelect = settings.onFreeTextSelect;\r\n    // \'keyup\' event will not be fired on Mobile Firefox, so we have to use \'input\' event instead\r\n    var keyUpEventName = mobileFirefox ? "input" : "keyup";\r\n    var items = [];\r\n    var inputValue = "";\r\n    var minLen = settings.minLength || 2;\r\n    var selected;\r\n    var keypressCounter = 0;\r\n    var debounceTimer;\r\n    if (!settings.input) {\r\n        throw new Error("input undefined");\r\n    }\r\n    var input = settings.input;\r\n    container.className = "autocomplete " + (settings.className || "");\r\n    containerStyle.position = "fixed";\r\n    /**\r\n     * Detach the container from DOM\r\n     */\r\n    function detach() {\r\n        var parent = container.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(container);\r\n        }\r\n    }\r\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\r\n    function clearDebounceTimer() {\r\n        if (debounceTimer) {\r\n            window.clearTimeout(debounceTimer);\r\n        }\r\n    }\r\n    /**\r\n     * Attach the container to DOM\r\n     */\r\n    function attach() {\r\n        if (!container.parentNode) {\r\n            doc.body.appendChild(container);\r\n        }\r\n    }\r\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\r\n    function containerDisplayed() {\r\n        return !!container.parentNode;\r\n    }\r\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\r\n    function clear() {\r\n        keypressCounter++;\r\n        items = [];\r\n        inputValue = "";\r\n        selected = undefined;\r\n        detach();\r\n    }\r\n    /**\r\n     * Update autocomplete position\r\n     */\r\n    function updatePosition() {\r\n        if (!containerDisplayed()) {\r\n            return;\r\n        }\r\n        containerStyle.height = "auto";\r\n        containerStyle.width = input.offsetWidth + "px";\r\n        var inputRect = input.getBoundingClientRect();\r\n        var top = inputRect.top + input.offsetHeight;\r\n        var maxHeight = window.innerHeight - top;\r\n        if (maxHeight < 0) {\r\n            maxHeight = 0;\r\n        }\r\n        containerStyle.top = top + "px";\r\n        containerStyle.bottom = "";\r\n        containerStyle.left = inputRect.left + "px";\r\n        containerStyle.maxHeight = maxHeight + "px";\r\n        if (settings.customize) {\r\n            settings.customize(input, inputRect, container, maxHeight);\r\n        }\r\n    }\r\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\r\n    function update() {\r\n        // delete all children from autocomplete DOM container\r\n        while (container.firstChild) {\r\n            container.removeChild(container.firstChild);\r\n        }\r\n        // function for rendering autocomplete suggestions\r\n        var render = function (item, currentValue) {\r\n            var itemElement = doc.createElement("div");\r\n            itemElement.textContent = item.label || "";\r\n            return itemElement;\r\n        };\r\n        if (settings.render) {\r\n            render = settings.render;\r\n        }\r\n        // function to render autocomplete groups\r\n        var renderGroup = function (groupName, currentValue) {\r\n            var groupDiv = doc.createElement("div");\r\n            groupDiv.textContent = groupName;\r\n            return groupDiv;\r\n        };\r\n        if (settings.renderGroup) {\r\n            renderGroup = settings.renderGroup;\r\n        }\r\n        var fragment = doc.createDocumentFragment();\r\n        var prevGroup = "#9?$";\r\n        items.forEach(function (item) {\r\n            if (item.group && item.group !== prevGroup) {\r\n                prevGroup = item.group;\r\n                var groupDiv = renderGroup(item.group, inputValue);\r\n                if (groupDiv) {\r\n                    groupDiv.className += " group";\r\n                    fragment.appendChild(groupDiv);\r\n                }\r\n            }\r\n            var div = render(item, inputValue);\r\n            if (div) {\r\n                div.addEventListener("click", function (ev) {\r\n                    settings.onSelect(item, input, ev);\r\n                    clear();\r\n                    ev.preventDefault();\r\n                    ev.stopPropagation();\r\n                });\r\n                if (item === selected) {\r\n                    div.className += " selected";\r\n                }\r\n                fragment.appendChild(div);\r\n            }\r\n        });\r\n        container.appendChild(fragment);\r\n        if (items.length < 1 && strict) {\r\n            if (settings.emptyMsg) {\r\n                var empty = doc.createElement("div");\r\n                empty.className = "empty";\r\n                empty.textContent = settings.emptyMsg;\r\n                container.appendChild(empty);\r\n                selected = undefined;\r\n            }\r\n            else {\r\n                clear();\r\n                return;\r\n            }\r\n        }\r\n        attach();\r\n        updatePosition();\r\n        updateScroll();\r\n    }\r\n    function updateIfDisplayed() {\r\n        if (containerDisplayed()) {\r\n            update();\r\n        }\r\n    }\r\n    function resizeEventHandler() {\r\n        updateIfDisplayed();\r\n    }\r\n    function scrollEventHandler(e) {\r\n        if (e.target !== container) {\r\n            updateIfDisplayed();\r\n        }\r\n        else {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n    /**\r\n     * Event handler for keyup event\r\n     */\r\n    function keyup(ev) {\r\n        var keyCode = ev.which || ev.keyCode || 0;\r\n        var ignore = [38 /* Up */, 13 /* Enter */, 27 /* Esc */, 39 /* Right */, 37 /* Left */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */];\r\n        for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {\r\n            var key = ignore_1[_i];\r\n            if (keyCode === key) {\r\n                return;\r\n            }\r\n        }\r\n        // the down key is used to open autocomplete\r\n        if (keyCode === 40 /* Down */ && containerDisplayed()) {\r\n            return;\r\n        }\r\n        // if multiple keys were pressed, before we get update from server,\r\n        // this may cause redrawing our autocomplete multiple times after the last key press.\r\n        // to avoid this, the number of times keyboard was pressed will be\r\n        // saved and checked before redraw our autocomplete box.\r\n        var savedKeypressCounter = ++keypressCounter;\r\n        var val = input.value;\r\n        if (val.length >= minLen) {\r\n            clearDebounceTimer();\r\n            debounceTimer = window.setTimeout(function () {\r\n                settings.fetch(val, function (elements) {\r\n                    if (keypressCounter === savedKeypressCounter && elements) {\r\n                        items = elements;\r\n                        inputValue = val;\r\n                        selected = items.length > 0 && autoselectfirst ? items[0] : undefined;\r\n                        update();\r\n                    }\r\n                });\r\n            }, debounceWaitMs);\r\n        }\r\n        else {\r\n            clear();\r\n        }\r\n    }\r\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\r\n    function updateScroll() {\r\n        var elements = container.getElementsByClassName("selected");\r\n        if (elements.length > 0) {\r\n            var element = elements[0];\r\n            // make group visible\r\n            var previous = element.previousElementSibling;\r\n            if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {\r\n                element = previous;\r\n            }\r\n            if (element.offsetTop < container.scrollTop) {\r\n                container.scrollTop = element.offsetTop;\r\n            }\r\n            else {\r\n                var selectBottom = element.offsetTop + element.offsetHeight;\r\n                var containerBottom = container.scrollTop + container.offsetHeight;\r\n                if (selectBottom > containerBottom) {\r\n                    container.scrollTop += selectBottom - containerBottom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Select the previous item in suggestions\r\n     */\r\n    function selectPrev() {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        else {\r\n            if (selected === items[0] || selected === undefined) {\r\n                selected = items[items.length - 1];\r\n            }\r\n            else {\r\n                for (var i = items.length - 1; i > 0; i--) {\r\n                    if (selected === items[i] || i === 1) {\r\n                        selected = items[i - 1];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Select the next item in suggestions\r\n     */\r\n    function selectNext() {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        if (!selected || selected === items[items.length - 1]) {\r\n            selected = items[0];\r\n            return;\r\n        }\r\n        for (var i = 0; i < (items.length - 1); i++) {\r\n            if (selected === items[i]) {\r\n                selected = items[i + 1];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * keydown keyboard event handler\r\n     */\r\n    function keydown(ev) {\r\n        var keyCode = ev.which || ev.keyCode || 0;\r\n        if (keyCode === 38 /* Up */ || keyCode === 40 /* Down */ || keyCode === 27 /* Esc */) {\r\n            var containerIsDisplayed = containerDisplayed();\r\n            if (keyCode === 27 /* Esc */) {\r\n                settings.onSelect(undefined, input, ev);\r\n                clear();\r\n            }\r\n            else {\r\n                if (!containerDisplayed || items.length < 1) {\r\n                    return;\r\n                }\r\n                keyCode === 38 /* Up */\r\n                    ? selectPrev()\r\n                    : selectNext();\r\n                update();\r\n            }\r\n            ev.preventDefault();\r\n            if (containerIsDisplayed) {\r\n                ev.stopPropagation();\r\n            }\r\n            return;\r\n        }\r\n        if (keyCode === 13 /* Enter */ || keyCode === 9 /* Tab */) {\r\n            if (strict) {\r\n                settings.onSelect(selected, input, ev);\r\n                clear();\r\n            }\r\n            if (!strict) {\r\n                var freeTextSelect = { label: input.value };\r\n                if (!selected) {\r\n                    if (onFreeTextSelect) {\r\n                        onFreeTextSelect(freeTextSelect, input);\r\n                    }\r\n                    settings.onSelect(freeTextSelect, input, ev);\r\n                }\r\n                else {\r\n                    settings.onSelect(selected, input, ev);\r\n                }\r\n                clear();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Blur keyboard event handler\r\n     */\r\n    function blur() {\r\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\r\n        setTimeout(function () {\r\n            if (doc.activeElement !== input) {\r\n                clear();\r\n            }\r\n        }, 200);\r\n    }\r\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\r\n    function destroy() {\r\n        input.removeEventListener("keydown", keydown);\r\n        input.removeEventListener(keyUpEventName, keyup);\r\n        input.removeEventListener("blur", blur);\r\n        window.removeEventListener("resize", resizeEventHandler);\r\n        doc.removeEventListener("scroll", scrollEventHandler, true);\r\n        clearDebounceTimer();\r\n        clear();\r\n        // prevent the update call if there are pending AJAX requests\r\n        keypressCounter++;\r\n    }\r\n    // setup event handlers\r\n    input.addEventListener("keydown", keydown);\r\n    input.addEventListener(keyUpEventName, keyup);\r\n    input.addEventListener("blur", blur);\r\n    window.addEventListener("resize", resizeEventHandler);\r\n    doc.addEventListener("scroll", scrollEventHandler, true);\r\n    return {\r\n        destroy: destroy\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./ag-grid-autocomplete-editor.ts\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutocompleteSelectCellEditor", function() { return ag_grid_autocomplete_editor_AutocompleteSelectCellEditor; });\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n// This import must be done with require because of TypeScript transpiler problems with export default\r\n\r\nvar ag_grid_autocomplete_editor_AutocompleteSelectCellEditor = /** @class */ (function (_super) {\r\n    __extends(AutocompleteSelectCellEditor, _super);\r\n    function AutocompleteSelectCellEditor() {\r\n        var _this = _super.call(this, \'<div class="ag-cell-edit-input" style="padding: 0 !important;"><input class="ag-cell-edit-input" type="text"/></div>\') || this;\r\n        _this.focusAfterAttached = false;\r\n        _this.required = false;\r\n        _this.eInput = _this.getGui().querySelector(\'input\');\r\n        if (_this.currentItem) {\r\n            _this.eInput.value = _this.currentItem.label || _this.currentItem.value;\r\n        }\r\n        return _this;\r\n    }\r\n    AutocompleteSelectCellEditor.suppressKeyboardEvent = function (params) {\r\n        var keyCode = params.event.keyCode;\r\n        return params.editing && (keyCode === external_ag_grid_community_["Constants"].KEY_UP || keyCode === external_ag_grid_community_["Constants"].KEY_DOWN || keyCode === external_ag_grid_community_["Constants"].KEY_ENTER || keyCode === external_ag_grid_community_["Constants"].KEY_TAB);\r\n    };\r\n    AutocompleteSelectCellEditor.getStartValue = function (params) {\r\n        var keyPressBackspaceOrDelete = params.keyPress === external_ag_grid_community_["Constants"].KEY_BACKSPACE || params.keyPress === external_ag_grid_community_["Constants"].KEY_DELETE;\r\n        if (keyPressBackspaceOrDelete) {\r\n            return \'\';\r\n        }\r\n        else if (params.charPress) {\r\n            return params.charPress;\r\n        }\r\n        return params.formatValue(params.value);\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.init = function (params) {\r\n        var _this = this;\r\n        this.stopEditing = params.stopEditing;\r\n        var defaultSettings = {\r\n            render: function (cellEditor, item, value) {\r\n                var itemElement = document.createElement("div");\r\n                var regex = new RegExp(value, \'gi\');\r\n                var fieldItem = document.createElement(\'span\');\r\n                fieldItem.innerHTML = item.label.replace(regex, function (match) {\r\n                    return "<strong>" + match + "</strong>";\r\n                });\r\n                itemElement.append(fieldItem);\r\n                cellEditor.addDestroyableEventListener(itemElement, \'mousedown\', function (event) {\r\n                    cellEditor.currentItem = item;\r\n                    event.stopPropagation();\r\n                });\r\n                return itemElement;\r\n            },\r\n            renderGroup: function (cellEditor, name) {\r\n                var div = document.createElement(\'div\');\r\n                div.textContent = name;\r\n                div.className = "group";\r\n                return div;\r\n            },\r\n            className: \'ag-cell-editor-autocomplete\',\r\n            minLength: 1,\r\n            emptyMsg: "None",\r\n            strict: true,\r\n            autoselectfirst: true,\r\n            onFreeTextSelect: function () {\r\n            },\r\n            onSelect: function (cellEditor, item) {\r\n                cellEditor.currentItem = item;\r\n            },\r\n            fetch: function (cellEditor, text, callback) {\r\n                var items = params.selectData || [];\r\n                var match = text.toLowerCase() || cellEditor.eInput.value.toLowerCase();\r\n                callback(items.filter(function (n) {\r\n                    return n.label.toLowerCase().indexOf(match) !== -1;\r\n                }));\r\n            },\r\n            debounceWaitMs: 200,\r\n            customize: function (cellEditor, input, inputRect, container, maxHeight) {\r\n                if (maxHeight < 100) {\r\n                    container.style.top = "10px";\r\n                    container.style.bottom = (window.innerHeight - inputRect.bottom + input.offsetHeight) + "px";\r\n                    container.style.maxHeight = "140px";\r\n                }\r\n            }\r\n        };\r\n        this.focusAfterAttached = params.cellStartedEdit;\r\n        this.eInput.placeholder = params.placeholder || \'\';\r\n        this.eInput.value = AutocompleteSelectCellEditor.getStartValue(params);\r\n        var autocompleteParams = __assign({}, defaultSettings, params.autocomplete);\r\n        this.autocompleter = autocomplete({\r\n            input: this.eInput,\r\n            render: function (item, currentValue) {\r\n                if (autocompleteParams.render) {\r\n                    return autocompleteParams.render(_this, item, currentValue);\r\n                }\r\n                return defaultSettings.render(_this, item, currentValue);\r\n            },\r\n            renderGroup: function (name, currentValue) {\r\n                if (autocompleteParams.renderGroup) {\r\n                    return autocompleteParams.renderGroup(_this, name, currentValue);\r\n                }\r\n                return defaultSettings.renderGroup(_this, name, currentValue);\r\n            },\r\n            className: autocompleteParams.className || defaultSettings.className,\r\n            minLength: autocompleteParams.minLength || defaultSettings.minLength,\r\n            emptyMsg: autocompleteParams.emptyMsg || defaultSettings.emptyMsg,\r\n            strict: autocompleteParams.strict,\r\n            autoselectfirst: autocompleteParams.autoselectfirst,\r\n            onFreeTextSelect: function (item, input) {\r\n                if (autocompleteParams.onFreeTextSelect) {\r\n                    return autocompleteParams.onFreeTextSelect(_this, item, input);\r\n                }\r\n                return defaultSettings.onFreeTextSelect(_this, item, input);\r\n            },\r\n            onSelect: function (item, input, event) {\r\n                var result;\r\n                if (autocompleteParams.onSelect) {\r\n                    result = autocompleteParams.onSelect(_this, item, input);\r\n                    if (event instanceof KeyboardEvent) {\r\n                        _this.handleTabEvent(event);\r\n                    }\r\n                    return result;\r\n                }\r\n                result = defaultSettings.onSelect(_this, item, input);\r\n                if (event instanceof KeyboardEvent) {\r\n                    _this.handleTabEvent(event);\r\n                }\r\n                return result;\r\n            },\r\n            fetch: function (text, update) {\r\n                if (autocompleteParams.fetch) {\r\n                    return autocompleteParams.fetch(_this, text, update);\r\n                }\r\n                return defaultSettings.fetch(_this, text, update);\r\n            },\r\n            debounceWaitMs: autocompleteParams.debounceWaitMs || defaultSettings.debounceWaitMs,\r\n            customize: function (input, inputRect, container, maxHeight) {\r\n                if (autocompleteParams.customize) {\r\n                    return autocompleteParams.customize(_this, input, inputRect, container, maxHeight);\r\n                }\r\n                return defaultSettings.customize(_this, input, inputRect, container, maxHeight);\r\n            }\r\n        });\r\n        if (params.required) {\r\n            this.required = true;\r\n        }\r\n        if (!params.colDef.suppressKeyboardEvent) {\r\n            params.colDef.suppressKeyboardEvent = AutocompleteSelectCellEditor.suppressKeyboardEvent;\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.handleTabEvent = function (event) {\r\n        var keyCode = event.which || event.keyCode || 0;\r\n        if (keyCode === external_ag_grid_community_["Constants"].KEY_TAB && this.gridOptionsWrapper) {\r\n            if (event.shiftKey) {\r\n                this.gridOptionsWrapper.getApi().tabToPreviousCell();\r\n            }\r\n            else {\r\n                this.gridOptionsWrapper.getApi().tabToNextCell();\r\n            }\r\n        }\r\n        else {\r\n            this.destroy();\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.afterGuiAttached = function (params) {\r\n        if (!this.focusAfterAttached) {\r\n            return;\r\n        }\r\n        var eInput = this.eInput;\r\n        eInput.focus();\r\n        eInput.select();\r\n        // when we started editing, we want the caret at the end, not the start.\r\n        // this comes into play in two scenarios: a) when user hits F2 and b)\r\n        // when user hits a printable character, then on IE (and only IE) the caret\r\n        // was placed after the first character, thus \'apply\' would end up as \'pplea\'\r\n        var length = eInput.value ? eInput.value.length : 0;\r\n        if (length > 0) {\r\n            eInput.setSelectionRange(length, length);\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.focusIn = function () {\r\n        this.eInput.focus();\r\n        this.eInput.select();\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.focusOut = function () {\r\n        this.eInput.blur();\r\n        this.autocompleter.destroy();\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.destroy = function () {\r\n        this.focusOut();\r\n        if (this.stopEditing) {\r\n            this.stopEditing();\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.getValue = function () {\r\n        return this.currentItem;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isCancelAfterEnd = function () {\r\n        if (this.required) {\r\n            return !this.currentItem;\r\n        }\r\n        return false;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isCancelBeforeStart = function () {\r\n        return false;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isPopup = function () {\r\n        return false;\r\n    };\r\n    __decorate([\r\n        Object(external_ag_grid_community_["Autowired"])(\'gridOptionsWrapper\')\r\n    ], AutocompleteSelectCellEditor.prototype, "gridOptionsWrapper", void 0);\r\n    return AutocompleteSelectCellEditor;\r\n}(external_ag_grid_community_["PopupComponent"]));\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2F1dG9jb21wbGV0ZXIvYXV0b2NvbXBsZXRlLnRzPzk5ZjUiLCJ3ZWJwYWNrOi8vLy4vYWctZ3JpZC1hdXRvY29tcGxldGUtZWRpdG9yLnRzP2FhNWIiXSwic291cmNlc0NvbnRlbnQiOlsiIC8qXG4gICogaHR0cHM6Ly9naXRodWIuY29tL2tyYWFkZW4vYXV0b2NvbXBsZXRlXG4gICogQ29weXJpZ2h0IChjKSAyMDE2IERlbnlzIEtyYXNub3NoY2hva1xuICAqIE1JVCBMaWNlbnNlXG4gICovXG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlSXRlbSB7XG4gICAgbGFiZWw/OiBzdHJpbmc7XG4gICAgZ3JvdXA/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlU2V0dGluZ3M8VCBleHRlbmRzIEF1dG9jb21wbGV0ZUl0ZW0+IHtcbiAgICBpbnB1dDogSFRNTElucHV0RWxlbWVudDtcbiAgICByZW5kZXI/OiAoaXRlbTogVCwgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIHJlbmRlckdyb3VwPzogKG5hbWU6IHN0cmluZywgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIGNsYXNzTmFtZT86IHN0cmluZztcbiAgICBtaW5MZW5ndGg/OiBudW1iZXI7XG4gICAgZW1wdHlNc2c/OiBzdHJpbmc7XG4gICAgc3RyaWN0OiBib29sZWFuO1xuICAgIGF1dG9zZWxlY3RmaXJzdDogYm9vbGVhbjtcbiAgICBvbkZyZWVUZXh0U2VsZWN0PzogKGl0ZW06IFQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB2b2lkO1xuICAgIG9uU2VsZWN0OiAoaXRlbTogVCB8IHVuZGVmaW5lZCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIGV2ZW50OiBLZXlib2FyZEV2ZW50IHwgTW91c2VFdmVudCkgPT4gdm9pZDtcbiAgICBmZXRjaDogKHRleHQ6IHN0cmluZywgdXBkYXRlOiAoaXRlbXM6IFRbXSB8IGZhbHNlKSA9PiB2b2lkKSA9PiB2b2lkO1xuICAgIGRlYm91bmNlV2FpdE1zPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZvciBhZGRpdGlvbmFsIGF1dG9jb21wbGV0ZSBjdXN0b21pemF0aW9uXG4gICAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dCAtIGlucHV0IGJveCBhc3NvY2lhdGVkIHdpdGggYXV0b2NvbXBsZXRlXG4gICAgICogQHBhcmFtIHtDbGllbnRSZWN0IHwgRE9NUmVjdH0gaW5wdXRSZWN0IC0gc2l6ZSBvZiB0aGUgaW5wdXQgYm94IGFuZCBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyIC0gY29udGFpbmVyIHdpdGggc3VnZ2VzdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IC0gbWF4IGhlaWdodCB0aGF0IGNhbiBiZSB1c2VkIGJ5IGF1dG9jb21wbGV0ZVxuICAgICAqL1xuICAgIGN1c3RvbWl6ZT86IChpbnB1dDogSFRNTElucHV0RWxlbWVudCwgaW5wdXRSZWN0OiBDbGllbnRSZWN0IHwgRE9NUmVjdCwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgbWF4SGVpZ2h0OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlUmVzdWx0IHtcbiAgICBkZXN0cm95OiAoKSA9PiB2b2lkO1xufVxuXG5jb25zdCBlbnVtIEtleXMge1xuICAgIEVudGVyID0gMTMsXG4gICAgRXNjID0gMjcsXG4gICAgVXAgPSAzOCxcbiAgICBEb3duID0gNDAsXG4gICAgTGVmdCA9IDM3LFxuICAgIFJpZ2h0ID0gMzksXG4gICAgU2hpZnQgPSAxNixcbiAgICBDdHJsID0gMTcsXG4gICAgQWx0ID0gMTgsXG4gICAgQ2Fwc0xvY2sgPSAyMCxcbiAgICBXaW5kb3dzS2V5ID0gOTEsXG4gICAgVGFiID0gOVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhdXRvY29tcGxldGU8VCBleHRlbmRzIEF1dG9jb21wbGV0ZUl0ZW0+KHNldHRpbmdzOiBBdXRvY29tcGxldGVTZXR0aW5nczxUPik6IEF1dG9jb21wbGV0ZVJlc3VsdCB7XG5cbiAgICAvLyBqdXN0IGFuIGFsaWFzIHRvIG1pbmltaXplIEpTIGZpbGUgc2l6ZVxuICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50O1xuXG4gICAgY29uc3QgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgY29uc3QgbW9iaWxlRmlyZWZveCA9IHVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSAhPT0gLTEgJiYgdXNlckFnZW50LmluZGV4T2YoXCJNb2JpbGVcIikgIT09IC0xO1xuICAgIGNvbnN0IGRlYm91bmNlV2FpdE1zID0gc2V0dGluZ3MuZGVib3VuY2VXYWl0TXMgfHwgMDtcbiAgICBjb25zdCBzdHJpY3QgPSBzZXR0aW5ncy5zdHJpY3Q7XG4gICAgY29uc3QgYXV0b3NlbGVjdGZpcnN0ID0gc2V0dGluZ3MuYXV0b3NlbGVjdGZpcnN0O1xuICAgIGNvbnN0IG9uRnJlZVRleHRTZWxlY3QgPSBzZXR0aW5ncy5vbkZyZWVUZXh0U2VsZWN0O1xuXG4gICAgLy8gJ2tleXVwJyBldmVudCB3aWxsIG5vdCBiZSBmaXJlZCBvbiBNb2JpbGUgRmlyZWZveCwgc28gd2UgaGF2ZSB0byB1c2UgJ2lucHV0JyBldmVudCBpbnN0ZWFkXG4gICAgY29uc3Qga2V5VXBFdmVudE5hbWUgPSBtb2JpbGVGaXJlZm94ID8gXCJpbnB1dFwiIDogXCJrZXl1cFwiO1xuXG4gICAgbGV0IGl0ZW1zOiBUW10gPSBbXTtcbiAgICBsZXQgaW5wdXRWYWx1ZSA9IFwiXCI7XG4gICAgY29uc3QgbWluTGVuID0gc2V0dGluZ3MubWluTGVuZ3RoIHx8IDI7XG4gICAgbGV0IHNlbGVjdGVkOiBUIHwgdW5kZWZpbmVkO1xuICAgIGxldCBrZXlwcmVzc0NvdW50ZXIgPSAwO1xuICAgIGxldCBkZWJvdW5jZVRpbWVyIDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFzZXR0aW5ncy5pbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB1bmRlZmluZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQgPSBzZXR0aW5ncy5pbnB1dDtcblxuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcImF1dG9jb21wbGV0ZSBcIiArIChzZXR0aW5ncy5jbGFzc05hbWUgfHwgXCJcIik7XG4gICAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggdGhlIGNvbnRhaW5lciBmcm9tIERPTVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGFjaCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgZGVib3VuY2luZyB0aW1lciBpZiBhc3NpZ25lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFyRGVib3VuY2VUaW1lcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKGRlYm91bmNlVGltZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoZGVib3VuY2VUaW1lcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggdGhlIGNvbnRhaW5lciB0byBET01cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdHRhY2goKTogdm9pZCB7XG4gICAgICAgIGlmICghY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjb250YWluZXIgZm9yIGF1dG9jb21wbGV0ZSBpcyBkaXNwbGF5ZWRcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5lckRpc3BsYXllZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYXV0b2NvbXBsZXRlIHN0YXRlIGFuZCBoaWRlIGNvbnRhaW5lclxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIGtleXByZXNzQ291bnRlcisrO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBpbnB1dFZhbHVlID0gXCJcIjtcbiAgICAgICAgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGRldGFjaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhdXRvY29tcGxldGUgcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFjb250YWluZXJEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyU3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLndpZHRoID0gaW5wdXQub2Zmc2V0V2lkdGggKyBcInB4XCI7XG5cbiAgICAgICAgY29uc3QgaW5wdXRSZWN0ID0gaW5wdXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRvcCA9IGlucHV0UmVjdC50b3AgKyBpbnB1dC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGxldCBtYXhIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3A7XG5cbiAgICAgICAgaWYgKG1heEhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIG1heEhlaWdodCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXJTdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLmJvdHRvbSA9IFwiXCI7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLmxlZnQgPSBpbnB1dFJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgICAgY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXN0b21pemUpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmN1c3RvbWl6ZShpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgdGhlIGF1dG9jb21wbGV0ZSBkaXYgZWxlbWVudCB3aXRoIHN1Z2dlc3Rpb25zXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZGVsZXRlIGFsbCBjaGlsZHJlbiBmcm9tIGF1dG9jb21wbGV0ZSBET00gY29udGFpbmVyXG4gICAgICAgIHdoaWxlIChjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zXG4gICAgICAgIGxldCByZW5kZXIgPSBmdW5jdGlvbihpdGVtOiBULCBjdXJyZW50VmFsdWU6IHN0cmluZyk6IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1FbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBpdGVtRWxlbWVudC50ZXh0Q29udGVudCA9IGl0ZW0ubGFiZWwgfHwgXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBpdGVtRWxlbWVudDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnJlbmRlcikge1xuICAgICAgICAgICAgcmVuZGVyID0gc2V0dGluZ3MucmVuZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gcmVuZGVyIGF1dG9jb21wbGV0ZSBncm91cHNcbiAgICAgICAgbGV0IHJlbmRlckdyb3VwID0gZnVuY3Rpb24oZ3JvdXBOYW1lOiBzdHJpbmcsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKTogSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBEaXYgPSBkb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGdyb3VwRGl2LnRleHRDb250ZW50ID0gZ3JvdXBOYW1lO1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwRGl2O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoc2V0dGluZ3MucmVuZGVyR3JvdXApIHtcbiAgICAgICAgICAgIHJlbmRlckdyb3VwID0gc2V0dGluZ3MucmVuZGVyR3JvdXA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGRvYy5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGxldCBwcmV2R3JvdXAgPSBcIiM5PyRcIjtcblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGl0ZW06IFQpOiB2b2lkIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmdyb3VwICYmIGl0ZW0uZ3JvdXAgIT09IHByZXZHcm91cCkge1xuICAgICAgICAgICAgICAgIHByZXZHcm91cCA9IGl0ZW0uZ3JvdXA7XG4gICAgICAgICAgICAgICAgY29uc3QgZ3JvdXBEaXYgPSByZW5kZXJHcm91cChpdGVtLmdyb3VwLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBEaXYpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBEaXYuY2xhc3NOYW1lICs9IFwiIGdyb3VwXCI7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGdyb3VwRGl2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkaXYgPSByZW5kZXIoaXRlbSwgaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoZGl2KSB7XG4gICAgICAgICAgICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldjogTW91c2VFdmVudCk6IHZvaWQge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdChpdGVtLCBpbnB1dCwgZXYpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSA9PT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmNsYXNzTmFtZSArPSBcIiBzZWxlY3RlZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEgJiYgc3RyaWN0KSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZW1wdHlNc2cpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgICAgIGVtcHR5LmNsYXNzTmFtZSA9IFwiZW1wdHlcIjtcbiAgICAgICAgICAgICAgICBlbXB0eS50ZXh0Q29udGVudCA9IHNldHRpbmdzLmVtcHR5TXNnO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYXR0YWNoKCk7XG4gICAgICAgIHVwZGF0ZVBvc2l0aW9uKCk7XG5cbiAgICAgICAgdXBkYXRlU2Nyb2xsKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXBkYXRlSWZEaXNwbGF5ZWQoKTogdm9pZCB7XG4gICAgICAgIGlmIChjb250YWluZXJEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemVFdmVudEhhbmRsZXIoKTogdm9pZCB7XG4gICAgICAgIHVwZGF0ZUlmRGlzcGxheWVkKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2Nyb2xsRXZlbnRIYW5kbGVyKGU6IEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmIChlLnRhcmdldCAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICB1cGRhdGVJZkRpc3BsYXllZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlciBmb3Iga2V5dXAgZXZlbnRcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGtleXVwKGV2OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldi53aGljaCB8fCBldi5rZXlDb2RlIHx8IDA7XG5cbiAgICAgICAgY29uc3QgaWdub3JlID0gW0tleXMuVXAsIEtleXMuRW50ZXIsIEtleXMuRXNjLCBLZXlzLlJpZ2h0LCBLZXlzLkxlZnQsIEtleXMuU2hpZnQsIEtleXMuQ3RybCwgS2V5cy5BbHQsIEtleXMuQ2Fwc0xvY2ssIEtleXMuV2luZG93c0tleSwgS2V5cy5UYWJdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBpZ25vcmUpIHtcbiAgICAgICAgICAgIGlmIChrZXlDb2RlID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgZG93biBrZXkgaXMgdXNlZCB0byBvcGVuIGF1dG9jb21wbGV0ZVxuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Eb3duICYmIGNvbnRhaW5lckRpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBtdWx0aXBsZSBrZXlzIHdlcmUgcHJlc3NlZCwgYmVmb3JlIHdlIGdldCB1cGRhdGUgZnJvbSBzZXJ2ZXIsXG4gICAgICAgIC8vIHRoaXMgbWF5IGNhdXNlIHJlZHJhd2luZyBvdXIgYXV0b2NvbXBsZXRlIG11bHRpcGxlIHRpbWVzIGFmdGVyIHRoZSBsYXN0IGtleSBwcmVzcy5cbiAgICAgICAgLy8gdG8gYXZvaWQgdGhpcywgdGhlIG51bWJlciBvZiB0aW1lcyBrZXlib2FyZCB3YXMgcHJlc3NlZCB3aWxsIGJlXG4gICAgICAgIC8vIHNhdmVkIGFuZCBjaGVja2VkIGJlZm9yZSByZWRyYXcgb3VyIGF1dG9jb21wbGV0ZSBib3guXG4gICAgICAgIGNvbnN0IHNhdmVkS2V5cHJlc3NDb3VudGVyID0gKytrZXlwcmVzc0NvdW50ZXI7XG5cbiAgICAgICAgY29uc3QgdmFsID0gaW5wdXQudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPj0gbWluTGVuKSB7XG4gICAgICAgICAgICBjbGVhckRlYm91bmNlVGltZXIoKTtcbiAgICAgICAgICAgIGRlYm91bmNlVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5mZXRjaCh2YWwsIGZ1bmN0aW9uKGVsZW1lbnRzOiBUW10gfCBmYWxzZSk6IHZvaWQge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5cHJlc3NDb3VudGVyID09PSBzYXZlZEtleXByZXNzQ291bnRlciAmJiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSBlbGVtZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zLmxlbmd0aCA+IDAgJiYgYXV0b3NlbGVjdGZpcnN0ID8gaXRlbXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgZGVib3VuY2VXYWl0TXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgbW92ZSBzY3JvbGwgYmFyIGlmIHNlbGVjdGVkIGl0ZW0gaXMgbm90IHZpc2libGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBjb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInNlbGVjdGVkXCIpO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBlbGVtZW50c1swXSBhcyBIVE1MRGl2RWxlbWVudDtcblxuICAgICAgICAgICAgLy8gbWFrZSBncm91cCB2aXNpYmxlXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZyBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cy5jbGFzc05hbWUuaW5kZXhPZihcImdyb3VwXCIpICE9PSAtMSAmJiAhcHJldmlvdXMucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwcmV2aW91cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0VG9wIDwgY29udGFpbmVyLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0Qm90dG9tID0gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJCb3R0b20gPSBjb250YWluZXIuc2Nyb2xsVG9wICsgY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0Qm90dG9tID4gY29udGFpbmVyQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2VsZWN0Qm90dG9tIC0gY29udGFpbmVyQm90dG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgcHJldmlvdXMgaXRlbSBpbiBzdWdnZXN0aW9uc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2VsZWN0UHJldigpOiB2b2lkIHtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1swXSB8fCBzZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSB8fCBpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSBuZXh0IGl0ZW0gaW4gc3VnZ2VzdGlvbnNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHNlbGVjdE5leHQoKTogdm9pZCB7XG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGVjdGVkIHx8IHNlbGVjdGVkID09PSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1swXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChpdGVtcy5sZW5ndGggLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IGl0ZW1zW2ldKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpICsgMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBrZXlkb3duIGtleWJvYXJkIGV2ZW50IGhhbmRsZXJcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGtleWRvd24oZXY6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2LndoaWNoIHx8IGV2LmtleUNvZGUgfHwgMDtcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuVXAgfHwga2V5Q29kZSA9PT0gS2V5cy5Eb3duIHx8IGtleUNvZGUgPT09IEtleXMuRXNjKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJJc0Rpc3BsYXllZCA9IGNvbnRhaW5lckRpc3BsYXllZCgpO1xuXG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Fc2MpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdCh1bmRlZmluZWQsIGlucHV0LCBldik7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXJEaXNwbGF5ZWQgfHwgaXRlbXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleUNvZGUgPT09IEtleXMuVXBcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxlY3RQcmV2KClcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxlY3ROZXh0KCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVySXNEaXNwbGF5ZWQpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRW50ZXIgfHwga2V5Q29kZSA9PT0gIEtleXMuVGFiKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWxlY3Qoc2VsZWN0ZWQsIGlucHV0LCBldik7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJlZVRleHRTZWxlY3QgPSB7bGFiZWw6IGlucHV0LnZhbHVlfSBhcyBUO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRnJlZVRleHRTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRnJlZVRleHRTZWxlY3QoZnJlZVRleHRTZWxlY3QsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdChmcmVlVGV4dFNlbGVjdCwgaW5wdXQsIGV2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdChzZWxlY3RlZCwgaW5wdXQsIGV2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJsdXIga2V5Ym9hcmQgZXZlbnQgaGFuZGxlclxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gYmx1cigpOiB2b2lkIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBkZWxheSBjbGVhciwgYmVjYXVzZSB3aGVuIHdlIGNsaWNrIG9uIGFuIGl0ZW0sIGJsdXIgd2lsbCBiZSBjYWxsZWQgYmVmb3JlIGNsaWNrIGFuZCByZW1vdmUgaXRlbXMgZnJvbSBET01cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jLmFjdGl2ZUVsZW1lbnQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcmVtb3ZlIERPTSBlbGVtZW50cyBhbmQgY2xlYXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtleWRvd24pO1xuICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKGtleVVwRXZlbnROYW1lLCBrZXl1cCBhcyBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KTtcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1cik7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZUV2ZW50SGFuZGxlcik7XG4gICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEV2ZW50SGFuZGxlciwgdHJ1ZSk7XG4gICAgICAgIGNsZWFyRGVib3VuY2VUaW1lcigpO1xuICAgICAgICBjbGVhcigpO1xuXG4gICAgICAgIC8vIHByZXZlbnQgdGhlIHVwZGF0ZSBjYWxsIGlmIHRoZXJlIGFyZSBwZW5kaW5nIEFKQVggcmVxdWVzdHNcbiAgICAgICAga2V5cHJlc3NDb3VudGVyKys7XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgZXZlbnQgaGFuZGxlcnNcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBrZXlkb3duKTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKGtleVVwRXZlbnROYW1lLCBrZXl1cCBhcyBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCByZXNpemVFdmVudEhhbmRsZXIpO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbEV2ZW50SGFuZGxlciwgdHJ1ZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBkZXN0cm95XG4gICAgfTtcbn1cbiIsImltcG9ydCB7XG4gICAgQXV0b3dpcmVkLFxuICAgIENvbnN0YW50cyxcbiAgICBHcmlkT3B0aW9uc1dyYXBwZXIsXG4gICAgSUFmdGVyR3VpQXR0YWNoZWRQYXJhbXMsXG4gICAgSUNlbGxFZGl0b3JDb21wLFxuICAgIElDZWxsRWRpdG9yUGFyYW1zLFxuICAgIFBvcHVwQ29tcG9uZW50LFxuICAgIFN1cHByZXNzS2V5Ym9hcmRFdmVudFBhcmFtc1xufSBmcm9tICdhZy1ncmlkLWNvbW11bml0eSc7XG5cbmltcG9ydCAnLi9hZy1ncmlkLWF1dG9jb21wbGV0ZS1lZGl0b3Iuc2Nzcyc7XG4vLyBUaGlzIGltcG9ydCBtdXN0IGJlIGRvbmUgd2l0aCByZXF1aXJlIGJlY2F1c2Ugb2YgVHlwZVNjcmlwdCB0cmFuc3BpbGVyIHByb2JsZW1zIHdpdGggZXhwb3J0IGRlZmF1bHRcbmltcG9ydCBhdXRvY29tcGxldGUsIHtBdXRvY29tcGxldGVJdGVtfSBmcm9tICcuL2F1dG9jb21wbGV0ZXIvYXV0b2NvbXBsZXRlJztcblxuZXhwb3J0IGludGVyZmFjZSBEYXRhRm9ybWF0IGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbSB7XG4gICAgdmFsdWU6IG51bWJlciB8IHN0cmluZztcbiAgICBsYWJlbDogc3RyaW5nO1xuICAgIGdyb3VwPzogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBBdXRvY29tcGxldGVDbGllbnQgPSBEYXRhRm9ybWF0ICYgQXV0b2NvbXBsZXRlSXRlbTtcblxuaW50ZXJmYWNlIElEZWZhdWx0QXV0b2NvbXBsZXRlclNldHRpbmdzPFQgZXh0ZW5kcyBBdXRvY29tcGxldGVJdGVtPiB7XG4gICAgcmVuZGVyOiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaXRlbTogVCwgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIHJlbmRlckdyb3VwOiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgbmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgY2xhc3NOYW1lOiBzdHJpbmc7XG4gICAgbWluTGVuZ3RoOiBudW1iZXI7XG4gICAgZW1wdHlNc2c6IHN0cmluZztcbiAgICBzdHJpY3Q6IGJvb2xlYW47XG4gICAgYXV0b3NlbGVjdGZpcnN0OiBib29sZWFuO1xuICAgIG9uRnJlZVRleHRTZWxlY3Q6IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBULCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcbiAgICBvblNlbGVjdDogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIGl0ZW06IFQgfCB1bmRlZmluZWQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB2b2lkO1xuICAgIGZldGNoOiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgdGV4dDogc3RyaW5nLCB1cGRhdGU6IChpdGVtczogVFtdIHwgZmFsc2UpID0+IHZvaWQpID0+IHZvaWQ7XG4gICAgZGVib3VuY2VXYWl0TXM6IG51bWJlcjtcbiAgICBjdXN0b21pemU6IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpbnB1dDogSFRNTElucHV0RWxlbWVudCwgaW5wdXRSZWN0OiBDbGllbnRSZWN0IHwgRE9NUmVjdCwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgbWF4SGVpZ2h0OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUF1dG9jb21wbGV0ZXJTZXR0aW5nczxUIGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbT4ge1xuICAgIHJlbmRlcj86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBULCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgcmVuZGVyR3JvdXA/OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgbmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIG1pbkxlbmd0aD86IG51bWJlcjtcbiAgICBlbXB0eU1zZz86IHN0cmluZztcbiAgICBzdHJpY3Q/OiBib29sZWFuO1xuICAgIGF1dG9zZWxlY3RmaXJzdD86IGJvb2xlYW47XG4gICAgb25GcmVlVGV4dFNlbGVjdD86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBULCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcbiAgICBvblNlbGVjdD86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBUIHwgdW5kZWZpbmVkLCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcbiAgICBmZXRjaD86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCB0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBUW10gfCBmYWxzZSkgPT4gdm9pZCkgPT4gdm9pZDtcbiAgICBkZWJvdW5jZVdhaXRNcz86IG51bWJlcjtcbiAgICBjdXN0b21pemU/OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIGlucHV0UmVjdDogQ2xpZW50UmVjdCB8IERPTVJlY3QsIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIG1heEhlaWdodDogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yUGFyYW1zIGV4dGVuZHMgSUNlbGxFZGl0b3JQYXJhbXMge1xuICAgIGF1dG9jb21wbGV0ZT86IElBdXRvY29tcGxldGVyU2V0dGluZ3M8QXV0b2NvbXBsZXRlQ2xpZW50PjtcbiAgICBzZWxlY3REYXRhOiBBcnJheTxEYXRhRm9ybWF0PjtcbiAgICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgICByZXF1aXJlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yIGV4dGVuZHMgUG9wdXBDb21wb25lbnQgaW1wbGVtZW50cyBJQ2VsbEVkaXRvckNvbXAge1xuICAgIHByaXZhdGUgZm9jdXNBZnRlckF0dGFjaGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSByZWFkb25seSBlSW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHVibGljIGN1cnJlbnRJdGVtPzogRGF0YUZvcm1hdDtcbiAgICBwcml2YXRlIGF1dG9jb21wbGV0ZXI/OiBhbnk7XG4gICAgcHJpdmF0ZSByZXF1aXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgc3RvcEVkaXRpbmc/OiAoY2FuY2VsPzogYm9vbGVhbikgPT4gdm9pZDtcblxuICAgIEBBdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpIHByaXZhdGUgZ3JpZE9wdGlvbnNXcmFwcGVyPzogR3JpZE9wdGlvbnNXcmFwcGVyO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCc8ZGl2IGNsYXNzPVwiYWctY2VsbC1lZGl0LWlucHV0XCIgc3R5bGU9XCJwYWRkaW5nOiAwICFpbXBvcnRhbnQ7XCI+PGlucHV0IGNsYXNzPVwiYWctY2VsbC1lZGl0LWlucHV0XCIgdHlwZT1cInRleHRcIi8+PC9kaXY+Jyk7XG4gICAgICAgIHRoaXMuZUlucHV0ID0gdGhpcy5nZXRHdWkoKS5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmVJbnB1dC52YWx1ZSA9IHRoaXMuY3VycmVudEl0ZW0ubGFiZWwgfHwgdGhpcy5jdXJyZW50SXRlbS52YWx1ZSBhcyBzdHJpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBzdGF0aWMgc3VwcHJlc3NLZXlib2FyZEV2ZW50KHBhcmFtczogU3VwcHJlc3NLZXlib2FyZEV2ZW50UGFyYW1zKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBrZXlDb2RlID0gcGFyYW1zLmV2ZW50LmtleUNvZGU7XG4gICAgICAgIHJldHVybiBwYXJhbXMuZWRpdGluZyAmJiAoa2V5Q29kZSA9PT0gQ29uc3RhbnRzLktFWV9VUCB8fCBrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX0RPV04gfHwga2V5Q29kZSA9PT0gQ29uc3RhbnRzLktFWV9FTlRFUiB8fCBrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX1RBQik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0U3RhcnRWYWx1ZShwYXJhbXM6IElBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yUGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUgPSBwYXJhbXMua2V5UHJlc3MgPT09IENvbnN0YW50cy5LRVlfQkFDS1NQQUNFIHx8IHBhcmFtcy5rZXlQcmVzcyA9PT0gQ29uc3RhbnRzLktFWV9ERUxFVEU7XG4gICAgICAgIGlmIChrZXlQcmVzc0JhY2tzcGFjZU9yRGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmNoYXJQcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5jaGFyUHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5mb3JtYXRWYWx1ZShwYXJhbXMudmFsdWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KHBhcmFtczogSUF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3JQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZyA9IHBhcmFtcy5zdG9wRWRpdGluZztcbiAgICAgICAgY29uc3QgZGVmYXVsdFNldHRpbmdzOiBJRGVmYXVsdEF1dG9jb21wbGV0ZXJTZXR0aW5nczxBdXRvY29tcGxldGVDbGllbnQ+ID0ge1xuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaXRlbTogQXV0b2NvbXBsZXRlQ2xpZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgbGV0IHJlZ2V4ID0gbmV3IFJlZ0V4cCh2YWx1ZSwgJ2dpJyk7XG4gICAgICAgICAgICAgICAgbGV0IGZpZWxkSXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICBmaWVsZEl0ZW0uaW5uZXJIVE1MID0gaXRlbS5sYWJlbC5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbiAobWF0Y2g6IHN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI8c3Ryb25nPlwiICsgbWF0Y2ggKyBcIjwvc3Ryb25nPlwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaXRlbUVsZW1lbnQuYXBwZW5kKGZpZWxkSXRlbSk7XG4gICAgICAgICAgICAgICAgY2VsbEVkaXRvci5hZGREZXN0cm95YWJsZUV2ZW50TGlzdGVuZXIoaXRlbUVsZW1lbnQsICdtb3VzZWRvd24nLCAoZXZlbnQ6IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbEVkaXRvci5jdXJyZW50SXRlbSA9IGl0ZW07XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtRWxlbWVudDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW5kZXJHcm91cDogZnVuY3Rpb24gKGNlbGxFZGl0b3IsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgZGl2LnRleHRDb250ZW50ID0gbmFtZTtcbiAgICAgICAgICAgICAgICBkaXYuY2xhc3NOYW1lID0gXCJncm91cFwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXY7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnYWctY2VsbC1lZGl0b3ItYXV0b2NvbXBsZXRlJyxcbiAgICAgICAgICAgIG1pbkxlbmd0aDogMSxcbiAgICAgICAgICAgIGVtcHR5TXNnOiBcIk5vbmVcIixcbiAgICAgICAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgICAgICAgIGF1dG9zZWxlY3RmaXJzdDogdHJ1ZSxcbiAgICAgICAgICAgIG9uRnJlZVRleHRTZWxlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdDogZnVuY3Rpb24gKGNlbGxFZGl0b3IsIGl0ZW06IEF1dG9jb21wbGV0ZUNsaWVudCB8IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNlbGxFZGl0b3IuY3VycmVudEl0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZldGNoOiAoY2VsbEVkaXRvciwgdGV4dCwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgaXRlbXMgPSBwYXJhbXMuc2VsZWN0RGF0YSB8fCBbXTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSB0ZXh0LnRvTG93ZXJDYXNlKCkgfHwgY2VsbEVkaXRvci5lSW5wdXQudmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG4ubGFiZWwudG9Mb3dlckNhc2UoKS5pbmRleE9mKG1hdGNoKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYm91bmNlV2FpdE1zOiAyMDAsXG4gICAgICAgICAgICBjdXN0b21pemU6IGZ1bmN0aW9uIChjZWxsRWRpdG9yLCBpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXhIZWlnaHQgPCAxMDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IFwiMTBweFwiO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm90dG9tID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIGlucHV0UmVjdC5ib3R0b20gKyBpbnB1dC5vZmZzZXRIZWlnaHQpICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUubWF4SGVpZ2h0ID0gXCIxNDBweFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQgPSBwYXJhbXMuY2VsbFN0YXJ0ZWRFZGl0O1xuXG4gICAgICAgIHRoaXMuZUlucHV0LnBsYWNlaG9sZGVyID0gcGFyYW1zLnBsYWNlaG9sZGVyIHx8ICcnO1xuICAgICAgICB0aGlzLmVJbnB1dC52YWx1ZSA9IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IuZ2V0U3RhcnRWYWx1ZShwYXJhbXMpO1xuXG4gICAgICAgIGNvbnN0IGF1dG9jb21wbGV0ZVBhcmFtcyA9IHsuLi5kZWZhdWx0U2V0dGluZ3MsIC4uLnBhcmFtcy5hdXRvY29tcGxldGV9O1xuXG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlciA9IGF1dG9jb21wbGV0ZSh7XG4gICAgICAgICAgICBpbnB1dDogdGhpcy5lSW5wdXQsXG4gICAgICAgICAgICByZW5kZXI6IChpdGVtOiBBdXRvY29tcGxldGVDbGllbnQsIGN1cnJlbnRWYWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5yZW5kZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9jb21wbGV0ZVBhcmFtcy5yZW5kZXIodGhpcywgaXRlbSwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZXR0aW5ncy5yZW5kZXIodGhpcywgaXRlbSwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW5kZXJHcm91cDogKG5hbWU6IHN0cmluZywgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUGFyYW1zLnJlbmRlckdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvY29tcGxldGVQYXJhbXMucmVuZGVyR3JvdXAodGhpcywgbmFtZSwgY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZXR0aW5ncy5yZW5kZXJHcm91cCh0aGlzLCBuYW1lLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYXV0b2NvbXBsZXRlUGFyYW1zLmNsYXNzTmFtZSB8fCBkZWZhdWx0U2V0dGluZ3MuY2xhc3NOYW1lLFxuICAgICAgICAgICAgbWluTGVuZ3RoOiBhdXRvY29tcGxldGVQYXJhbXMubWluTGVuZ3RoIHx8IGRlZmF1bHRTZXR0aW5ncy5taW5MZW5ndGgsXG4gICAgICAgICAgICBlbXB0eU1zZzogYXV0b2NvbXBsZXRlUGFyYW1zLmVtcHR5TXNnIHx8IGRlZmF1bHRTZXR0aW5ncy5lbXB0eU1zZyxcbiAgICAgICAgICAgIHN0cmljdDogYXV0b2NvbXBsZXRlUGFyYW1zLnN0cmljdCxcbiAgICAgICAgICAgIGF1dG9zZWxlY3RmaXJzdDogYXV0b2NvbXBsZXRlUGFyYW1zLmF1dG9zZWxlY3RmaXJzdCxcbiAgICAgICAgICAgIG9uRnJlZVRleHRTZWxlY3Q6IChpdGVtOiBBdXRvY29tcGxldGVDbGllbnQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5vbkZyZWVUZXh0U2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhdXRvY29tcGxldGVQYXJhbXMub25GcmVlVGV4dFNlbGVjdCh0aGlzLCBpdGVtLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0U2V0dGluZ3Mub25GcmVlVGV4dFNlbGVjdCh0aGlzLCBpdGVtLCBpbnB1dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25TZWxlY3Q6IChpdGVtOiBBdXRvY29tcGxldGVDbGllbnQgfCB1bmRlZmluZWQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50LCBldmVudDogS2V5Ym9hcmRFdmVudCB8IE1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0OiBhbnk7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5vblNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhdXRvY29tcGxldGVQYXJhbXMub25TZWxlY3QodGhpcywgaXRlbSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRhYkV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBkZWZhdWx0U2V0dGluZ3Mub25TZWxlY3QodGhpcywgaXRlbSwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVUYWJFdmVudChldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmV0Y2g6ICh0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBBdXRvY29tcGxldGVDbGllbnRbXSB8IGZhbHNlKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5mZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUGFyYW1zLmZldGNoKHRoaXMsIHRleHQsIHVwZGF0ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZXR0aW5ncy5mZXRjaCh0aGlzLCB0ZXh0LCB1cGRhdGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYm91bmNlV2FpdE1zOiBhdXRvY29tcGxldGVQYXJhbXMuZGVib3VuY2VXYWl0TXMgfHwgZGVmYXVsdFNldHRpbmdzLmRlYm91bmNlV2FpdE1zLFxuICAgICAgICAgICAgY3VzdG9taXplOiAoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIGlucHV0UmVjdDogQ2xpZW50UmVjdCB8IERPTVJlY3QsIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIG1heEhlaWdodDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5jdXN0b21pemUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9jb21wbGV0ZVBhcmFtcy5jdXN0b21pemUodGhpcywgaW5wdXQsIGlucHV0UmVjdCwgY29udGFpbmVyLCBtYXhIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzLmN1c3RvbWl6ZSh0aGlzLCBpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwYXJhbXMucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zLmNvbERlZi5zdXBwcmVzc0tleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5jb2xEZWYuc3VwcHJlc3NLZXlib2FyZEV2ZW50ID0gQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvci5zdXBwcmVzc0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVUYWJFdmVudChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZSB8fCAwO1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gQ29uc3RhbnRzLktFWV9UQUIgJiYgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpIS50YWJUb1ByZXZpb3VzQ2VsbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRBcGkoKSEudGFiVG9OZXh0Q2VsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZnRlckd1aUF0dGFjaGVkKHBhcmFtcz86IElBZnRlckd1aUF0dGFjaGVkUGFyYW1zKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgY29uc3QgZUlucHV0ID0gdGhpcy5lSW5wdXQ7XG4gICAgICAgIGVJbnB1dC5mb2N1cygpO1xuICAgICAgICBlSW5wdXQuc2VsZWN0KCk7XG4gICAgICAgIC8vIHdoZW4gd2Ugc3RhcnRlZCBlZGl0aW5nLCB3ZSB3YW50IHRoZSBjYXJldCBhdCB0aGUgZW5kLCBub3QgdGhlIHN0YXJ0LlxuICAgICAgICAvLyB0aGlzIGNvbWVzIGludG8gcGxheSBpbiB0d28gc2NlbmFyaW9zOiBhKSB3aGVuIHVzZXIgaGl0cyBGMiBhbmQgYilcbiAgICAgICAgLy8gd2hlbiB1c2VyIGhpdHMgYSBwcmludGFibGUgY2hhcmFjdGVyLCB0aGVuIG9uIElFIChhbmQgb25seSBJRSkgdGhlIGNhcmV0XG4gICAgICAgIC8vIHdhcyBwbGFjZWQgYWZ0ZXIgdGhlIGZpcnN0IGNoYXJhY3RlciwgdGh1cyAnYXBwbHknIHdvdWxkIGVuZCB1cCBhcyAncHBsZWEnXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVJbnB1dC52YWx1ZSA/IGVJbnB1dC52YWx1ZS5sZW5ndGggOiAwO1xuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZUlucHV0LnNldFNlbGVjdGlvblJhbmdlKGxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzSW4oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZUlucHV0LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuZUlucHV0LnNlbGVjdCgpO1xuICAgIH1cblxuICAgIGZvY3VzT3V0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmVJbnB1dC5ibHVyKCk7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2N1c091dCgpO1xuICAgICAgICBpZiAodGhpcy5zdG9wRWRpdGluZykge1xuICAgICAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VmFsdWUoKTogRGF0YUZvcm1hdCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRJdGVtO1xuICAgIH1cblxuICAgIGlzQ2FuY2VsQWZ0ZXJFbmQoKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuY3VycmVudEl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc0NhbmNlbEJlZm9yZVN0YXJ0KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaXNQb3B1cCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFJQTtBQWlEQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNWNBO0FBV0E7QUFDQTtBQUNBO0FBK0NBO0FBQUE7QUFVQTtBQUFBO0FBVEE7QUFJQTtBQU9BO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQTdNQTtBQUFBO0FBQUE7QUE4TUE7QUFBQTtBQXROQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')}])});