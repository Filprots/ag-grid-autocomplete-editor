!function(g,I){if("object"==typeof exports&&"object"==typeof module)module.exports=I(require("ag-grid-community"));else if("function"==typeof define&&define.amd)define(["ag-grid-community"],I);else{var C="object"==typeof exports?I(require("ag-grid-community")):I(g["ag-grid-community"]);for(var e in C)("object"==typeof exports?exports:g)[e]=C[e]}}(window,function(__WEBPACK_EXTERNAL_MODULE__0__){return function(g){var I={};function C(e){if(I[e])return I[e].exports;var t=I[e]={i:e,l:!1,exports:{}};return g[e].call(t.exports,t,t.exports,C),t.l=!0,t.exports}return C.m=g,C.c=I,C.d=function(g,I,e){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:e})},C.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var e=Object.create(null);if(C.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var t in g)C.d(e,t,function(I){return g[I]}.bind(null,t));return e},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,"a",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p="http://localhost:8080/",C(C.s=2)}([function(module,exports){eval("module.exports = __WEBPACK_EXTERNAL_MODULE__0__;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImFnLWdyaWQtY29tbXVuaXR5XCI/ODc0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfXzBfXzsiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2FnLWdyaWQtYXV0b2NvbXBsZXRlLWVkaXRvci5zY3NzP2E4NmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: external "ag-grid-community"\nvar external_ag_grid_community_ = __webpack_require__(0);\n\n// EXTERNAL MODULE: ./ag-grid-autocomplete-editor.scss\nvar ag_grid_autocomplete_editor = __webpack_require__(1);\n\n// CONCATENATED MODULE: ./autocompleter/autocomplete.ts\n/*\r\n * https://github.com/kraaden/autocomplete\r\n * Copyright (c) 2016 Denys Krasnoshchok\r\n * MIT License\r\n */\r\nfunction autocomplete(settings) {\r\n    // just an alias to minimize JS file size\r\n    var doc = document;\r\n    var container = doc.createElement("div");\r\n    var containerStyle = container.style;\r\n    var userAgent = navigator.userAgent;\r\n    var mobileFirefox = userAgent.indexOf("Firefox") !== -1 && userAgent.indexOf("Mobile") !== -1;\r\n    var debounceWaitMs = settings.debounceWaitMs || 0;\r\n    var strict = settings.strict;\r\n    var autoselectfirst = settings.autoselectfirst;\r\n    var onFreeTextSelect = settings.onFreeTextSelect;\r\n    // \'keyup\' event will not be fired on Mobile Firefox, so we have to use \'input\' event instead\r\n    var keyUpEventName = mobileFirefox ? "input" : "keyup";\r\n    var items = [];\r\n    var inputValue = "";\r\n    var minLen = settings.minLength !== undefined ? settings.minLength : 2;\r\n    var showOnFocus = settings.showOnFocus;\r\n    var selected;\r\n    var keypressCounter = 0;\r\n    var debounceTimer;\r\n    if (!settings.input) {\r\n        throw new Error("input undefined");\r\n    }\r\n    var input = settings.input;\r\n    container.className = "autocomplete " + (settings.className || "");\r\n    containerStyle.position = "fixed";\r\n    /**\r\n     * Detach the container from DOM\r\n     */\r\n    function detach() {\r\n        var parent = container.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(container);\r\n        }\r\n    }\r\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\r\n    function clearDebounceTimer() {\r\n        if (debounceTimer) {\r\n            window.clearTimeout(debounceTimer);\r\n        }\r\n    }\r\n    /**\r\n     * Attach the container to DOM\r\n     */\r\n    function attach() {\r\n        if (!container.parentNode) {\r\n            doc.body.appendChild(container);\r\n        }\r\n    }\r\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\r\n    function containerDisplayed() {\r\n        return !!container.parentNode;\r\n    }\r\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\r\n    function clear() {\r\n        keypressCounter++;\r\n        items = [];\r\n        inputValue = "";\r\n        selected = undefined;\r\n        detach();\r\n    }\r\n    /**\r\n     * Update autocomplete position\r\n     */\r\n    function updatePosition() {\r\n        if (!containerDisplayed()) {\r\n            return;\r\n        }\r\n        containerStyle.height = "auto";\r\n        containerStyle.width = input.offsetWidth + "px";\r\n        var inputRect = input.getBoundingClientRect();\r\n        var top = inputRect.top + input.offsetHeight;\r\n        var maxHeight = window.innerHeight - top;\r\n        if (maxHeight < 0) {\r\n            maxHeight = 0;\r\n        }\r\n        containerStyle.top = top + "px";\r\n        containerStyle.bottom = "";\r\n        containerStyle.left = inputRect.left + "px";\r\n        containerStyle.maxHeight = maxHeight + "px";\r\n        if (settings.customize) {\r\n            settings.customize(input, inputRect, container, maxHeight);\r\n        }\r\n    }\r\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\r\n    function update() {\r\n        // delete all children from autocomplete DOM container\r\n        while (container.firstChild) {\r\n            container.removeChild(container.firstChild);\r\n        }\r\n        // function for rendering autocomplete suggestions\r\n        // noinspection JSUnusedLocalSymbols\r\n        var render = function (item, currentValue) {\r\n            var itemElement = doc.createElement("div");\r\n            itemElement.textContent = item.label || "";\r\n            return itemElement;\r\n        };\r\n        if (settings.render) {\r\n            render = settings.render;\r\n        }\r\n        // function to render autocomplete groups\r\n        // noinspection JSUnusedLocalSymbols\r\n        var renderGroup = function (groupName, currentValue) {\r\n            var groupDiv = doc.createElement("div");\r\n            groupDiv.textContent = groupName;\r\n            return groupDiv;\r\n        };\r\n        if (settings.renderGroup) {\r\n            renderGroup = settings.renderGroup;\r\n        }\r\n        var fragment = doc.createDocumentFragment();\r\n        var prevGroup = "#9?$";\r\n        items.forEach(function (item) {\r\n            if (item.group && item.group !== prevGroup) {\r\n                prevGroup = item.group;\r\n                var groupDiv = renderGroup(item.group, inputValue);\r\n                if (groupDiv) {\r\n                    groupDiv.className += " group";\r\n                    fragment.appendChild(groupDiv);\r\n                }\r\n            }\r\n            var div = render(item, inputValue);\r\n            if (div) {\r\n                div.addEventListener("click", function (ev) {\r\n                    settings.onSelect(item, input, ev);\r\n                    clear();\r\n                    ev.preventDefault();\r\n                    ev.stopPropagation();\r\n                });\r\n                if (item === selected) {\r\n                    div.className += " selected";\r\n                }\r\n                fragment.appendChild(div);\r\n            }\r\n        });\r\n        container.appendChild(fragment);\r\n        if (items.length < 1 && strict) {\r\n            if (settings.emptyMsg) {\r\n                var empty = doc.createElement("div");\r\n                empty.className = "empty";\r\n                empty.textContent = settings.emptyMsg;\r\n                container.appendChild(empty);\r\n                selected = undefined;\r\n            }\r\n            else {\r\n                clear();\r\n                return;\r\n            }\r\n        }\r\n        attach();\r\n        updatePosition();\r\n        updateScroll();\r\n    }\r\n    function updateIfDisplayed() {\r\n        if (containerDisplayed()) {\r\n            update();\r\n        }\r\n    }\r\n    function resizeEventHandler() {\r\n        updateIfDisplayed();\r\n    }\r\n    function scrollEventHandler(e) {\r\n        if (e.target !== container) {\r\n            updateIfDisplayed();\r\n        }\r\n        else {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n    function keyupEventHandler(ev) {\r\n        var keyCode = ev.which || ev.keyCode || 0;\r\n        var ignore = [38 /* Up */, 13 /* Enter */, 27 /* Esc */, 39 /* Right */, 37 /* Left */, 16 /* Shift */, 17 /* Ctrl */, 18 /* Alt */, 20 /* CapsLock */, 91 /* WindowsKey */, 9 /* Tab */];\r\n        for (var _i = 0, ignore_1 = ignore; _i < ignore_1.length; _i++) {\r\n            var key = ignore_1[_i];\r\n            if (keyCode === key) {\r\n                return;\r\n            }\r\n        }\r\n        // the down key is used to open autocomplete\r\n        if (keyCode === 40 /* Down */ && containerDisplayed()) {\r\n            return;\r\n        }\r\n        startFetch(0 /* Keyboard */);\r\n    }\r\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\r\n    function updateScroll() {\r\n        var elements = container.getElementsByClassName("selected");\r\n        if (elements.length > 0) {\r\n            var element = elements[0];\r\n            // make group visible\r\n            var previous = element.previousElementSibling;\r\n            if (previous && previous.className.indexOf("group") !== -1 && !previous.previousElementSibling) {\r\n                element = previous;\r\n            }\r\n            if (element.offsetTop < container.scrollTop) {\r\n                container.scrollTop = element.offsetTop;\r\n            }\r\n            else {\r\n                var selectBottom = element.offsetTop + element.offsetHeight;\r\n                var containerBottom = container.scrollTop + container.offsetHeight;\r\n                if (selectBottom > containerBottom) {\r\n                    container.scrollTop += selectBottom - containerBottom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Select the previous item in suggestions\r\n     */\r\n    function selectPrev() {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        else {\r\n            if (selected === items[0] || selected === undefined) {\r\n                selected = items[items.length - 1];\r\n            }\r\n            else {\r\n                for (var i = items.length - 1; i > 0; i--) {\r\n                    if (selected === items[i] || i === 1) {\r\n                        selected = items[i - 1];\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Select the next item in suggestions\r\n     */\r\n    function selectNext() {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        }\r\n        if (!selected || selected === items[items.length - 1]) {\r\n            selected = items[0];\r\n            return;\r\n        }\r\n        for (var i = 0; i < (items.length - 1); i++) {\r\n            if (selected === items[i]) {\r\n                selected = items[i + 1];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    function keydownEventHandler(ev) {\r\n        var keyCode = ev.which || ev.keyCode || 0;\r\n        if (keyCode === 38 /* Up */ || keyCode === 40 /* Down */ || keyCode === 27 /* Esc */) {\r\n            var containerIsDisplayed = containerDisplayed();\r\n            if (keyCode === 27 /* Esc */) {\r\n                settings.onSelect(undefined, input, ev);\r\n                clear();\r\n            }\r\n            else {\r\n                if (!containerDisplayed || items.length < 1) {\r\n                    return;\r\n                }\r\n                keyCode === 38 /* Up */\r\n                    ? selectPrev()\r\n                    : selectNext();\r\n                update();\r\n            }\r\n            ev.preventDefault();\r\n            if (containerIsDisplayed) {\r\n                ev.stopPropagation();\r\n            }\r\n            return;\r\n        }\r\n        if (keyCode === 13 /* Enter */ || keyCode === 9 /* Tab */) {\r\n            if (strict) {\r\n                settings.onSelect(selected, input, ev);\r\n                clear();\r\n            }\r\n            if (!strict) {\r\n                var freeTextSelect = { label: input.value };\r\n                if (!selected) {\r\n                    if (onFreeTextSelect) {\r\n                        onFreeTextSelect(freeTextSelect, input);\r\n                    }\r\n                    settings.onSelect(freeTextSelect, input, ev);\r\n                }\r\n                else {\r\n                    settings.onSelect(selected, input, ev);\r\n                }\r\n                clear();\r\n            }\r\n        }\r\n    }\r\n    function focusEventHandler() {\r\n        if (showOnFocus) {\r\n            startFetch(1 /* Focus */);\r\n        }\r\n    }\r\n    function startFetch(trigger) {\r\n        // if multiple keys were pressed, before we get update from server,\r\n        // this may cause redrawing our autocomplete multiple times after the last key press.\r\n        // to avoid this, the number of times keyboard was pressed will be\r\n        // saved and checked before redraw our autocomplete box.\r\n        var savedKeypressCounter = ++keypressCounter;\r\n        var val = input.value;\r\n        if (val.length >= minLen || trigger === 1 /* Focus */) {\r\n            clearDebounceTimer();\r\n            debounceTimer = window.setTimeout(function () {\r\n                settings.fetch(val, function (elements) {\r\n                    if (keypressCounter === savedKeypressCounter && elements) {\r\n                        items = elements;\r\n                        inputValue = val;\r\n                        selected = items.length > 0 && autoselectfirst ? items[0] : undefined;\r\n                        update();\r\n                    }\r\n                }, 0 /* Keyboard */);\r\n            }, trigger === 0 /* Keyboard */ ? debounceWaitMs : 0);\r\n        }\r\n        else {\r\n            clear();\r\n        }\r\n    }\r\n    function blurEventHandler() {\r\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\r\n        setTimeout(function () {\r\n            if (doc.activeElement !== input) {\r\n                clear();\r\n            }\r\n        }, 200);\r\n    }\r\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\r\n    function destroy() {\r\n        input.removeEventListener("focus", focusEventHandler);\r\n        input.removeEventListener("keydown", keydownEventHandler);\r\n        input.removeEventListener(keyUpEventName, keyupEventHandler);\r\n        input.removeEventListener("blur", blurEventHandler);\r\n        window.removeEventListener("resize", resizeEventHandler);\r\n        doc.removeEventListener("scroll", scrollEventHandler, true);\r\n        clearDebounceTimer();\r\n        clear();\r\n        // prevent the update call if there are pending AJAX requests\r\n        keypressCounter++;\r\n    }\r\n    // setup event handlers\r\n    input.addEventListener("keydown", keydownEventHandler);\r\n    input.addEventListener(keyUpEventName, keyupEventHandler);\r\n    input.addEventListener("blur", blurEventHandler);\r\n    input.addEventListener("focus", focusEventHandler);\r\n    window.addEventListener("resize", resizeEventHandler);\r\n    doc.addEventListener("scroll", scrollEventHandler, true);\r\n    return {\r\n        destroy: destroy\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./ag-grid-autocomplete-editor.ts\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AutocompleteSelectCellEditor", function() { return ag_grid_autocomplete_editor_AutocompleteSelectCellEditor; });\nvar __extends = (undefined && undefined.__extends) || (function () {\r\n    var extendStatics = function (d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n    return function (d, b) {\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n})();\r\nvar __assign = (undefined && undefined.__assign) || function () {\r\n    __assign = Object.assign || function(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\r\n                t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n};\r\n\r\n\r\n// This import must be done with require because of TypeScript transpiler problems with export default\r\n\r\nvar ag_grid_autocomplete_editor_AutocompleteSelectCellEditor = /** @class */ (function (_super) {\r\n    __extends(AutocompleteSelectCellEditor, _super);\r\n    function AutocompleteSelectCellEditor() {\r\n        var _this = _super.call(this, \'<div class="ag-cell-edit-input" style="padding: 0 !important;"><input class="ag-cell-edit-input" type="text"/></div>\') || this;\r\n        _this.focusAfterAttached = false;\r\n        _this.required = false;\r\n        _this.eInput = _this.getGui().querySelector(\'input\');\r\n        if (_this.currentItem) {\r\n            _this.eInput.value = _this.currentItem.label || _this.currentItem.value;\r\n        }\r\n        return _this;\r\n    }\r\n    AutocompleteSelectCellEditor.suppressKeyboardEvent = function (params) {\r\n        var keyCode = params.event.keyCode;\r\n        return params.editing && (keyCode === external_ag_grid_community_["Constants"].KEY_UP || keyCode === external_ag_grid_community_["Constants"].KEY_DOWN || keyCode === external_ag_grid_community_["Constants"].KEY_ENTER || keyCode === external_ag_grid_community_["Constants"].KEY_TAB);\r\n    };\r\n    AutocompleteSelectCellEditor.getStartValue = function (params) {\r\n        var keyPressBackspaceOrDelete = params.keyPress === external_ag_grid_community_["Constants"].KEY_BACKSPACE || params.keyPress === external_ag_grid_community_["Constants"].KEY_DELETE;\r\n        if (keyPressBackspaceOrDelete) {\r\n            return \'\';\r\n        }\r\n        else if (params.charPress) {\r\n            return params.charPress;\r\n        }\r\n        return params.formatValue(params.value);\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.init = function (params) {\r\n        var _this = this;\r\n        this.stopEditing = params.stopEditing;\r\n        var defaultSettings = {\r\n            showOnFocus: false,\r\n            render: function (cellEditor, item, value) {\r\n                var itemElement = document.createElement("div");\r\n                var regex = new RegExp(value, \'gi\');\r\n                var fieldItem = document.createElement(\'span\');\r\n                fieldItem.innerHTML = item.label.replace(regex, function (match) {\r\n                    return "<strong>" + match + "</strong>";\r\n                });\r\n                itemElement.appendChild(fieldItem);\r\n                cellEditor.addDestroyableEventListener(itemElement, \'mousedown\', function (event) {\r\n                    cellEditor.currentItem = item;\r\n                    event.stopPropagation();\r\n                });\r\n                return itemElement;\r\n            },\r\n            renderGroup: function (cellEditor, name) {\r\n                var div = document.createElement(\'div\');\r\n                div.textContent = name;\r\n                div.className = "group";\r\n                return div;\r\n            },\r\n            className: \'ag-cell-editor-autocomplete\',\r\n            minLength: 1,\r\n            emptyMsg: "None",\r\n            strict: true,\r\n            autoselectfirst: true,\r\n            onFreeTextSelect: function () {\r\n            },\r\n            onSelect: function (cellEditor, item) {\r\n                cellEditor.currentItem = item;\r\n            },\r\n            fetch: function (cellEditor, text, callback) {\r\n                var items = params.selectData || [];\r\n                var match = text.toLowerCase() || cellEditor.eInput.value.toLowerCase();\r\n                callback(items.filter(function (n) {\r\n                    return n.label.toLowerCase().indexOf(match) !== -1;\r\n                }));\r\n            },\r\n            debounceWaitMs: 200,\r\n            customize: function (cellEditor, input, inputRect, container, maxHeight) {\r\n                if (maxHeight < 100) {\r\n                    container.style.top = "10px";\r\n                    container.style.bottom = (window.innerHeight - inputRect.bottom + input.offsetHeight) + "px";\r\n                    container.style.maxHeight = "140px";\r\n                }\r\n            }\r\n        };\r\n        this.focusAfterAttached = params.cellStartedEdit;\r\n        this.eInput.placeholder = params.placeholder || \'\';\r\n        this.eInput.value = AutocompleteSelectCellEditor.getStartValue(params);\r\n        var autocompleteParams = __assign({}, defaultSettings, params.autocomplete);\r\n        this.autocompleter = autocomplete({\r\n            input: this.eInput,\r\n            render: function (item, currentValue) {\r\n                if (autocompleteParams.render) {\r\n                    return autocompleteParams.render(_this, item, currentValue);\r\n                }\r\n                return defaultSettings.render(_this, item, currentValue);\r\n            },\r\n            renderGroup: function (name, currentValue) {\r\n                if (autocompleteParams.renderGroup) {\r\n                    return autocompleteParams.renderGroup(_this, name, currentValue);\r\n                }\r\n                return defaultSettings.renderGroup(_this, name, currentValue);\r\n            },\r\n            className: autocompleteParams.className || defaultSettings.className,\r\n            minLength: autocompleteParams.minLength !== undefined ? autocompleteParams.minLength : defaultSettings.minLength,\r\n            emptyMsg: autocompleteParams.emptyMsg || defaultSettings.emptyMsg,\r\n            strict: autocompleteParams.strict,\r\n            autoselectfirst: autocompleteParams.autoselectfirst,\r\n            showOnFocus: autocompleteParams.showOnFocus,\r\n            onFreeTextSelect: function (item, input) {\r\n                if (autocompleteParams.onFreeTextSelect) {\r\n                    return autocompleteParams.onFreeTextSelect(_this, item, input);\r\n                }\r\n                return defaultSettings.onFreeTextSelect(_this, item, input);\r\n            },\r\n            onSelect: function (item, input, event) {\r\n                var result;\r\n                if (autocompleteParams.onSelect) {\r\n                    result = autocompleteParams.onSelect(_this, item, input);\r\n                    if (event instanceof KeyboardEvent) {\r\n                        _this.handleTabEvent(event);\r\n                    }\r\n                    else {\r\n                        _this.destroy();\r\n                    }\r\n                    return result;\r\n                }\r\n                result = defaultSettings.onSelect(_this, item, input);\r\n                if (event instanceof KeyboardEvent) {\r\n                    _this.handleTabEvent(event);\r\n                }\r\n                else {\r\n                    _this.destroy();\r\n                }\r\n                return result;\r\n            },\r\n            fetch: function (text, update, trigger) {\r\n                if (autocompleteParams.fetch) {\r\n                    return autocompleteParams.fetch(_this, text, update, trigger);\r\n                }\r\n                return defaultSettings.fetch(_this, text, update, trigger);\r\n            },\r\n            debounceWaitMs: autocompleteParams.debounceWaitMs || defaultSettings.debounceWaitMs,\r\n            customize: function (input, inputRect, container, maxHeight) {\r\n                if (autocompleteParams.customize) {\r\n                    return autocompleteParams.customize(_this, input, inputRect, container, maxHeight);\r\n                }\r\n                return defaultSettings.customize(_this, input, inputRect, container, maxHeight);\r\n            }\r\n        });\r\n        if (params.required) {\r\n            this.required = true;\r\n        }\r\n        if (!params.colDef.suppressKeyboardEvent) {\r\n            params.colDef.suppressKeyboardEvent = AutocompleteSelectCellEditor.suppressKeyboardEvent;\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.handleTabEvent = function (event) {\r\n        var keyCode = event.which || event.keyCode || 0;\r\n        if (keyCode === external_ag_grid_community_["Constants"].KEY_TAB && this.gridOptionsWrapper) {\r\n            if (event.shiftKey) {\r\n                this.gridOptionsWrapper.getApi().tabToPreviousCell();\r\n            }\r\n            else {\r\n                this.gridOptionsWrapper.getApi().tabToNextCell();\r\n            }\r\n        }\r\n        else {\r\n            this.destroy();\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.afterGuiAttached = function (params) {\r\n        if (!this.focusAfterAttached) {\r\n            return;\r\n        }\r\n        var eInput = this.eInput;\r\n        eInput.focus();\r\n        eInput.select();\r\n        // when we started editing, we want the caret at the end, not the start.\r\n        // this comes into play in two scenarios: a) when user hits F2 and b)\r\n        // when user hits a printable character, then on IE (and only IE) the caret\r\n        // was placed after the first character, thus \'apply\' would end up as \'pplea\'\r\n        var length = eInput.value ? eInput.value.length : 0;\r\n        if (length > 0) {\r\n            eInput.setSelectionRange(length, length);\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.focusIn = function () {\r\n        this.eInput.focus();\r\n        this.eInput.select();\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.focusOut = function () {\r\n        this.eInput.blur();\r\n        this.autocompleter.destroy();\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.destroy = function () {\r\n        this.focusOut();\r\n        if (this.stopEditing) {\r\n            this.stopEditing();\r\n        }\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.getValue = function () {\r\n        return this.currentItem;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isCancelAfterEnd = function () {\r\n        if (this.required) {\r\n            return !this.currentItem;\r\n        }\r\n        return false;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isCancelBeforeStart = function () {\r\n        return false;\r\n    };\r\n    AutocompleteSelectCellEditor.prototype.isPopup = function () {\r\n        return false;\r\n    };\r\n    __decorate([\r\n        Object(external_ag_grid_community_["Autowired"])(\'gridOptionsWrapper\')\r\n    ], AutocompleteSelectCellEditor.prototype, "gridOptionsWrapper", void 0);\r\n    return AutocompleteSelectCellEditor;\r\n}(external_ag_grid_community_["PopupComponent"]));\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2F1dG9jb21wbGV0ZXIvYXV0b2NvbXBsZXRlLnRzPzk5ZjUiLCJ3ZWJwYWNrOi8vLy4vYWctZ3JpZC1hdXRvY29tcGxldGUtZWRpdG9yLnRzP2FhNWIiXSwic291cmNlc0NvbnRlbnQiOlsiIC8qXG4gICogaHR0cHM6Ly9naXRodWIuY29tL2tyYWFkZW4vYXV0b2NvbXBsZXRlXG4gICogQ29weXJpZ2h0IChjKSAyMDE2IERlbnlzIEtyYXNub3NoY2hva1xuICAqIE1JVCBMaWNlbnNlXG4gICovXG5cbiBleHBvcnQgY29uc3QgZW51bSBFdmVudFRyaWdnZXIge1xuICAgICBLZXlib2FyZCA9IDAsXG4gICAgIEZvY3VzID0gMVxuIH1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRvY29tcGxldGVJdGVtIHtcbiAgICBsYWJlbD86IHN0cmluZztcbiAgICBncm91cD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdXRvY29tcGxldGVTZXR0aW5nczxUIGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbT4ge1xuICAgIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50O1xuICAgIHJlbmRlcj86IChpdGVtOiBULCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgcmVuZGVyR3JvdXA/OiAobmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIG1pbkxlbmd0aD86IG51bWJlcjtcbiAgICBlbXB0eU1zZz86IHN0cmluZztcbiAgICBzdHJpY3Q6IGJvb2xlYW47XG4gICAgYXV0b3NlbGVjdGZpcnN0OiBib29sZWFuO1xuICAgIG9uRnJlZVRleHRTZWxlY3Q/OiAoaXRlbTogVCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHZvaWQ7XG4gICAgb25TZWxlY3Q6IChpdGVtOiBUIHwgdW5kZWZpbmVkLCBpbnB1dDogSFRNTElucHV0RWxlbWVudCwgZXZlbnQ6IEtleWJvYXJkRXZlbnQgfCBNb3VzZUV2ZW50KSA9PiB2b2lkO1xuICAgIC8qKlxuICAgICAqIFNob3cgYXV0b2NvbXBsZXRlIG9uIGZvY3VzIGV2ZW50LiBGb2N1cyBldmVudCB3aWxsIGlnbm9yZSB0aGUgYG1pbkxlbmd0aGAgcHJvcGVydHkgYW5kIHdpbGwgYWx3YXlzIGNhbGwgYGZldGNoYC5cbiAgICAgKi9cbiAgICBzaG93T25Gb2N1cz86IGJvb2xlYW47XG4gICAgZmV0Y2g6ICh0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBUW10gfCBmYWxzZSkgPT4gdm9pZCwgdHJpZ2dlcjogRXZlbnRUcmlnZ2VyKSA9PiB2b2lkO1xuICAgIGRlYm91bmNlV2FpdE1zPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZvciBhZGRpdGlvbmFsIGF1dG9jb21wbGV0ZSBjdXN0b21pemF0aW9uXG4gICAgICogQHBhcmFtIHtIVE1MSW5wdXRFbGVtZW50fSBpbnB1dCAtIGlucHV0IGJveCBhc3NvY2lhdGVkIHdpdGggYXV0b2NvbXBsZXRlXG4gICAgICogQHBhcmFtIHtDbGllbnRSZWN0IHwgRE9NUmVjdH0gaW5wdXRSZWN0IC0gc2l6ZSBvZiB0aGUgaW5wdXQgYm94IGFuZCBpdHMgcG9zaXRpb24gcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0XG4gICAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gY29udGFpbmVyIC0gY29udGFpbmVyIHdpdGggc3VnZ2VzdGlvbnNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0IC0gbWF4IGhlaWdodCB0aGF0IGNhbiBiZSB1c2VkIGJ5IGF1dG9jb21wbGV0ZVxuICAgICAqL1xuICAgIGN1c3RvbWl6ZT86IChpbnB1dDogSFRNTElucHV0RWxlbWVudCwgaW5wdXRSZWN0OiBDbGllbnRSZWN0IHwgRE9NUmVjdCwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgbWF4SGVpZ2h0OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXV0b2NvbXBsZXRlUmVzdWx0IHtcbiAgICBkZXN0cm95OiAoKSA9PiB2b2lkO1xufVxuXG5jb25zdCBlbnVtIEtleXMge1xuICAgIEVudGVyID0gMTMsXG4gICAgRXNjID0gMjcsXG4gICAgVXAgPSAzOCxcbiAgICBEb3duID0gNDAsXG4gICAgTGVmdCA9IDM3LFxuICAgIFJpZ2h0ID0gMzksXG4gICAgU2hpZnQgPSAxNixcbiAgICBDdHJsID0gMTcsXG4gICAgQWx0ID0gMTgsXG4gICAgQ2Fwc0xvY2sgPSAyMCxcbiAgICBXaW5kb3dzS2V5ID0gOTEsXG4gICAgVGFiID0gOVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhdXRvY29tcGxldGU8VCBleHRlbmRzIEF1dG9jb21wbGV0ZUl0ZW0+KHNldHRpbmdzOiBBdXRvY29tcGxldGVTZXR0aW5nczxUPik6IEF1dG9jb21wbGV0ZVJlc3VsdCB7XG5cbiAgICAvLyBqdXN0IGFuIGFsaWFzIHRvIG1pbmltaXplIEpTIGZpbGUgc2l6ZVxuICAgIGNvbnN0IGRvYyA9IGRvY3VtZW50O1xuXG4gICAgY29uc3QgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgY29uc3QgbW9iaWxlRmlyZWZveCA9IHVzZXJBZ2VudC5pbmRleE9mKFwiRmlyZWZveFwiKSAhPT0gLTEgJiYgdXNlckFnZW50LmluZGV4T2YoXCJNb2JpbGVcIikgIT09IC0xO1xuICAgIGNvbnN0IGRlYm91bmNlV2FpdE1zID0gc2V0dGluZ3MuZGVib3VuY2VXYWl0TXMgfHwgMDtcbiAgICBjb25zdCBzdHJpY3QgPSBzZXR0aW5ncy5zdHJpY3Q7XG4gICAgY29uc3QgYXV0b3NlbGVjdGZpcnN0ID0gc2V0dGluZ3MuYXV0b3NlbGVjdGZpcnN0O1xuICAgIGNvbnN0IG9uRnJlZVRleHRTZWxlY3QgPSBzZXR0aW5ncy5vbkZyZWVUZXh0U2VsZWN0O1xuXG4gICAgLy8gJ2tleXVwJyBldmVudCB3aWxsIG5vdCBiZSBmaXJlZCBvbiBNb2JpbGUgRmlyZWZveCwgc28gd2UgaGF2ZSB0byB1c2UgJ2lucHV0JyBldmVudCBpbnN0ZWFkXG4gICAgY29uc3Qga2V5VXBFdmVudE5hbWUgPSBtb2JpbGVGaXJlZm94ID8gXCJpbnB1dFwiIDogXCJrZXl1cFwiO1xuXG4gICAgbGV0IGl0ZW1zOiBUW10gPSBbXTtcbiAgICBsZXQgaW5wdXRWYWx1ZSA9IFwiXCI7XG4gICAgY29uc3QgbWluTGVuID0gc2V0dGluZ3MubWluTGVuZ3RoICE9PSB1bmRlZmluZWQgPyBzZXR0aW5ncy5taW5MZW5ndGggOiAyO1xuICAgIGNvbnN0IHNob3dPbkZvY3VzID0gc2V0dGluZ3Muc2hvd09uRm9jdXM7XG4gICAgbGV0IHNlbGVjdGVkOiBUIHwgdW5kZWZpbmVkO1xuICAgIGxldCBrZXlwcmVzc0NvdW50ZXIgPSAwO1xuICAgIGxldCBkZWJvdW5jZVRpbWVyIDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKCFzZXR0aW5ncy5pbnB1dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB1bmRlZmluZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3QgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQgPSBzZXR0aW5ncy5pbnB1dDtcblxuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcImF1dG9jb21wbGV0ZSBcIiArIChzZXR0aW5ncy5jbGFzc05hbWUgfHwgXCJcIik7XG4gICAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG5cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggdGhlIGNvbnRhaW5lciBmcm9tIERPTVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRldGFjaCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgZGVib3VuY2luZyB0aW1lciBpZiBhc3NpZ25lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsZWFyRGVib3VuY2VUaW1lcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKGRlYm91bmNlVGltZXIpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoZGVib3VuY2VUaW1lcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggdGhlIGNvbnRhaW5lciB0byBET01cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhdHRhY2goKTogdm9pZCB7XG4gICAgICAgIGlmICghY29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjb250YWluZXIgZm9yIGF1dG9jb21wbGV0ZSBpcyBkaXNwbGF5ZWRcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5lckRpc3BsYXllZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYXV0b2NvbXBsZXRlIHN0YXRlIGFuZCBoaWRlIGNvbnRhaW5lclxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gY2xlYXIoKTogdm9pZCB7XG4gICAgICAgIGtleXByZXNzQ291bnRlcisrO1xuICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICBpbnB1dFZhbHVlID0gXCJcIjtcbiAgICAgICAgc2VsZWN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGRldGFjaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhdXRvY29tcGxldGUgcG9zaXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVQb3NpdGlvbigpOiB2b2lkIHtcbiAgICAgICAgaWYgKCFjb250YWluZXJEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyU3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLndpZHRoID0gaW5wdXQub2Zmc2V0V2lkdGggKyBcInB4XCI7XG5cbiAgICAgICAgY29uc3QgaW5wdXRSZWN0ID0gaW5wdXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHRvcCA9IGlucHV0UmVjdC50b3AgKyBpbnB1dC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGxldCBtYXhIZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3A7XG5cbiAgICAgICAgaWYgKG1heEhlaWdodCA8IDApIHtcbiAgICAgICAgICAgIG1heEhlaWdodCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXJTdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLmJvdHRvbSA9IFwiXCI7XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLmxlZnQgPSBpbnB1dFJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgICAgY29udGFpbmVyU3R5bGUubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0ICsgXCJweFwiO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXN0b21pemUpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmN1c3RvbWl6ZShpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWRyYXcgdGhlIGF1dG9jb21wbGV0ZSBkaXYgZWxlbWVudCB3aXRoIHN1Z2dlc3Rpb25zXG4gICAgICovXG5cbiAgICBmdW5jdGlvbiB1cGRhdGUoKTogdm9pZCB7XG5cbiAgICAgICAgLy8gZGVsZXRlIGFsbCBjaGlsZHJlbiBmcm9tIGF1dG9jb21wbGV0ZSBET00gY29udGFpbmVyXG4gICAgICAgIHdoaWxlIChjb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgYXV0b2NvbXBsZXRlIHN1Z2dlc3Rpb25zXG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZExvY2FsU3ltYm9sc1xuICAgICAgICBsZXQgcmVuZGVyID0gZnVuY3Rpb24oaXRlbTogVCwgY3VycmVudFZhbHVlOiBzdHJpbmcpOiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZCB7XG4gICAgICAgICAgICBjb25zdCBpdGVtRWxlbWVudCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgaXRlbUVsZW1lbnQudGV4dENvbnRlbnQgPSBpdGVtLmxhYmVsIHx8IFwiXCI7XG4gICAgICAgICAgICByZXR1cm4gaXRlbUVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXIpIHtcbiAgICAgICAgICAgIHJlbmRlciA9IHNldHRpbmdzLnJlbmRlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIHJlbmRlciBhdXRvY29tcGxldGUgZ3JvdXBzXG4gICAgICAgIC8vIG5vaW5zcGVjdGlvbiBKU1VudXNlZExvY2FsU3ltYm9sc1xuICAgICAgICBsZXQgcmVuZGVyR3JvdXAgPSBmdW5jdGlvbihncm91cE5hbWU6IHN0cmluZywgY3VycmVudFZhbHVlOiBzdHJpbmcpOiBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZCB7XG4gICAgICAgICAgICBjb25zdCBncm91cERpdiA9IGRvYy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgZ3JvdXBEaXYudGV4dENvbnRlbnQgPSBncm91cE5hbWU7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBEaXY7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzZXR0aW5ncy5yZW5kZXJHcm91cCkge1xuICAgICAgICAgICAgcmVuZGVyR3JvdXAgPSBzZXR0aW5ncy5yZW5kZXJHcm91cDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgbGV0IHByZXZHcm91cCA9IFwiIzk/JFwiO1xuXG4gICAgICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24oaXRlbTogVCk6IHZvaWQge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZ3JvdXAgJiYgaXRlbS5ncm91cCAhPT0gcHJldkdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcHJldkdyb3VwID0gaXRlbS5ncm91cDtcbiAgICAgICAgICAgICAgICBjb25zdCBncm91cERpdiA9IHJlbmRlckdyb3VwKGl0ZW0uZ3JvdXAsIGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChncm91cERpdikge1xuICAgICAgICAgICAgICAgICAgICBncm91cERpdi5jbGFzc05hbWUgKz0gXCIgZ3JvdXBcIjtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZ3JvdXBEaXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpdiA9IHJlbmRlcihpdGVtLCBpbnB1dFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkaXYpIHtcbiAgICAgICAgICAgICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLm9uU2VsZWN0KGl0ZW0sIGlucHV0LCBldik7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtID09PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBkaXYuY2xhc3NOYW1lICs9IFwiIHNlbGVjdGVkXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRpdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgICBpZiAoaXRlbXMubGVuZ3RoIDwgMSAmJiBzdHJpY3QpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbXB0eU1zZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgZW1wdHkuY2xhc3NOYW1lID0gXCJlbXB0eVwiO1xuICAgICAgICAgICAgICAgIGVtcHR5LnRleHRDb250ZW50ID0gc2V0dGluZ3MuZW1wdHlNc2c7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGVtcHR5KTtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhdHRhY2goKTtcbiAgICAgICAgdXBkYXRlUG9zaXRpb24oKTtcblxuICAgICAgICB1cGRhdGVTY3JvbGwoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVJZkRpc3BsYXllZCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKGNvbnRhaW5lckRpc3BsYXllZCgpKSB7XG4gICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc2l6ZUV2ZW50SGFuZGxlcigpOiB2b2lkIHtcbiAgICAgICAgdXBkYXRlSWZEaXNwbGF5ZWQoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzY3JvbGxFdmVudEhhbmRsZXIoZTogRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgICAgIHVwZGF0ZUlmRGlzcGxheWVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXl1cEV2ZW50SGFuZGxlcihldjogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gZXYud2hpY2ggfHwgZXYua2V5Q29kZSB8fCAwO1xuXG4gICAgICAgIGNvbnN0IGlnbm9yZSA9IFtLZXlzLlVwLCBLZXlzLkVudGVyLCBLZXlzLkVzYywgS2V5cy5SaWdodCwgS2V5cy5MZWZ0LCBLZXlzLlNoaWZ0LCBLZXlzLkN0cmwsIEtleXMuQWx0LCBLZXlzLkNhcHNMb2NrLCBLZXlzLldpbmRvd3NLZXksIEtleXMuVGFiXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgaWdub3JlKSB7XG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGRvd24ga2V5IGlzIHVzZWQgdG8gb3BlbiBhdXRvY29tcGxldGVcbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRG93biAmJiBjb250YWluZXJEaXNwbGF5ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnRGZXRjaChFdmVudFRyaWdnZXIuS2V5Ym9hcmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF1dG9tYXRpY2FsbHkgbW92ZSBzY3JvbGwgYmFyIGlmIHNlbGVjdGVkIGl0ZW0gaXMgbm90IHZpc2libGVcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbCgpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBjb250YWluZXIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcInNlbGVjdGVkXCIpO1xuICAgICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGVsZW1lbnQgPSBlbGVtZW50c1swXSBhcyBIVE1MRGl2RWxlbWVudDtcblxuICAgICAgICAgICAgLy8gbWFrZSBncm91cCB2aXNpYmxlXG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IGVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZyBhcyBIVE1MRGl2RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyAmJiBwcmV2aW91cy5jbGFzc05hbWUuaW5kZXhPZihcImdyb3VwXCIpICE9PSAtMSAmJiAhcHJldmlvdXMucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBwcmV2aW91cztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0VG9wIDwgY29udGFpbmVyLnNjcm9sbFRvcCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0Qm90dG9tID0gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJCb3R0b20gPSBjb250YWluZXIuc2Nyb2xsVG9wICsgY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0Qm90dG9tID4gY29udGFpbmVyQm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zY3JvbGxUb3AgKz0gc2VsZWN0Qm90dG9tIC0gY29udGFpbmVyQm90dG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdCB0aGUgcHJldmlvdXMgaXRlbSBpbiBzdWdnZXN0aW9uc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gc2VsZWN0UHJldigpOiB2b2lkIHtcbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1swXSB8fCBzZWxlY3RlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkID09PSBpdGVtc1tpXSB8fCBpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZCA9IGl0ZW1zW2kgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0IHRoZSBuZXh0IGl0ZW0gaW4gc3VnZ2VzdGlvbnNcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIHNlbGVjdE5leHQoKTogdm9pZCB7XG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGVjdGVkIHx8IHNlbGVjdGVkID09PSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1swXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChpdGVtcy5sZW5ndGggLSAxKTsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgPT09IGl0ZW1zW2ldKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtc1tpICsgMV07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrZXlkb3duRXZlbnRIYW5kbGVyKGV2OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldi53aGljaCB8fCBldi5rZXlDb2RlIHx8IDA7XG5cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuVXAgfHwga2V5Q29kZSA9PT0gS2V5cy5Eb3duIHx8IGtleUNvZGUgPT09IEtleXMuRXNjKSB7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJJc0Rpc3BsYXllZCA9IGNvbnRhaW5lckRpc3BsYXllZCgpO1xuXG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gS2V5cy5Fc2MpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdCh1bmRlZmluZWQsIGlucHV0LCBldik7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb250YWluZXJEaXNwbGF5ZWQgfHwgaXRlbXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleUNvZGUgPT09IEtleXMuVXBcbiAgICAgICAgICAgICAgICAgICAgPyBzZWxlY3RQcmV2KClcbiAgICAgICAgICAgICAgICAgICAgOiBzZWxlY3ROZXh0KCk7XG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoY29udGFpbmVySXNEaXNwbGF5ZWQpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGtleUNvZGUgPT09IEtleXMuRW50ZXIgfHwga2V5Q29kZSA9PT0gIEtleXMuVGFiKSB7XG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Mub25TZWxlY3Qoc2VsZWN0ZWQsIGlucHV0LCBldik7XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJlZVRleHRTZWxlY3QgPSB7bGFiZWw6IGlucHV0LnZhbHVlfSBhcyBUO1xuICAgICAgICAgICAgICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9uRnJlZVRleHRTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRnJlZVRleHRTZWxlY3QoZnJlZVRleHRTZWxlY3QsIGlucHV0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdChmcmVlVGV4dFNlbGVjdCwgaW5wdXQsIGV2KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5vblNlbGVjdChzZWxlY3RlZCwgaW5wdXQsIGV2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZvY3VzRXZlbnRIYW5kbGVyKCk6IHZvaWQge1xuICAgICAgICBpZiAoc2hvd09uRm9jdXMpIHtcbiAgICAgICAgICAgIHN0YXJ0RmV0Y2goRXZlbnRUcmlnZ2VyLkZvY3VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0RmV0Y2godHJpZ2dlcjogRXZlbnRUcmlnZ2VyKSB7XG4gICAgICAgIC8vIGlmIG11bHRpcGxlIGtleXMgd2VyZSBwcmVzc2VkLCBiZWZvcmUgd2UgZ2V0IHVwZGF0ZSBmcm9tIHNlcnZlcixcbiAgICAgICAgLy8gdGhpcyBtYXkgY2F1c2UgcmVkcmF3aW5nIG91ciBhdXRvY29tcGxldGUgbXVsdGlwbGUgdGltZXMgYWZ0ZXIgdGhlIGxhc3Qga2V5IHByZXNzLlxuICAgICAgICAvLyB0byBhdm9pZCB0aGlzLCB0aGUgbnVtYmVyIG9mIHRpbWVzIGtleWJvYXJkIHdhcyBwcmVzc2VkIHdpbGwgYmVcbiAgICAgICAgLy8gc2F2ZWQgYW5kIGNoZWNrZWQgYmVmb3JlIHJlZHJhdyBvdXIgYXV0b2NvbXBsZXRlIGJveC5cbiAgICAgICAgY29uc3Qgc2F2ZWRLZXlwcmVzc0NvdW50ZXIgPSArK2tleXByZXNzQ291bnRlcjtcblxuICAgICAgICBjb25zdCB2YWwgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbC5sZW5ndGggPj0gbWluTGVuIHx8IHRyaWdnZXIgPT09IEV2ZW50VHJpZ2dlci5Gb2N1cykge1xuICAgICAgICAgICAgY2xlYXJEZWJvdW5jZVRpbWVyKCk7XG4gICAgICAgICAgICBkZWJvdW5jZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKTogdm9pZCB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZmV0Y2godmFsLCBmdW5jdGlvbihlbGVtZW50czogVFtdIHwgZmFsc2UpOiB2b2lkIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleXByZXNzQ291bnRlciA9PT0gc2F2ZWRLZXlwcmVzc0NvdW50ZXIgJiYgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQgPSBpdGVtcy5sZW5ndGggPiAwICYmIGF1dG9zZWxlY3RmaXJzdCA/IGl0ZW1zWzBdIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBFdmVudFRyaWdnZXIuS2V5Ym9hcmQpO1xuICAgICAgICAgICAgfSwgdHJpZ2dlciA9PT0gRXZlbnRUcmlnZ2VyLktleWJvYXJkID8gZGVib3VuY2VXYWl0TXMgOiAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBibHVyRXZlbnRIYW5kbGVyKCk6IHZvaWQge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIGRlbGF5IGNsZWFyLCBiZWNhdXNlIHdoZW4gd2UgY2xpY2sgb24gYW4gaXRlbSwgYmx1ciB3aWxsIGJlIGNhbGxlZCBiZWZvcmUgY2xpY2sgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIERPTVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChkb2MuYWN0aXZlRWxlbWVudCAhPT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAyMDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCByZW1vdmUgRE9NIGVsZW1lbnRzIGFuZCBjbGVhciBldmVudCBoYW5kbGVyc1xuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGZvY3VzRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwga2V5ZG93bkV2ZW50SGFuZGxlcik7XG4gICAgICAgIGlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoa2V5VXBFdmVudE5hbWUsIGtleXVwRXZlbnRIYW5kbGVyIGFzIEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpO1xuICAgICAgICBpbnB1dC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBibHVyRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgc2Nyb2xsRXZlbnRIYW5kbGVyLCB0cnVlKTtcbiAgICAgICAgY2xlYXJEZWJvdW5jZVRpbWVyKCk7XG4gICAgICAgIGNsZWFyKCk7XG5cbiAgICAgICAgLy8gcHJldmVudCB0aGUgdXBkYXRlIGNhbGwgaWYgdGhlcmUgYXJlIHBlbmRpbmcgQUpBWCByZXF1ZXN0c1xuICAgICAgICBrZXlwcmVzc0NvdW50ZXIrKztcbiAgICB9XG5cbiAgICAvLyBzZXR1cCBldmVudCBoYW5kbGVyc1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGtleWRvd25FdmVudEhhbmRsZXIpO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoa2V5VXBFdmVudE5hbWUsIGtleXVwRXZlbnRIYW5kbGVyIGFzIEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJFdmVudEhhbmRsZXIpO1xuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBmb2N1c0V2ZW50SGFuZGxlcik7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplRXZlbnRIYW5kbGVyKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBzY3JvbGxFdmVudEhhbmRsZXIsIHRydWUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveVxuICAgIH07XG59XG4iLCJpbXBvcnQge1xuICAgIEF1dG93aXJlZCxcbiAgICBDb25zdGFudHMsXG4gICAgR3JpZE9wdGlvbnNXcmFwcGVyLFxuICAgIElBZnRlckd1aUF0dGFjaGVkUGFyYW1zLFxuICAgIElDZWxsRWRpdG9yQ29tcCxcbiAgICBJQ2VsbEVkaXRvclBhcmFtcyxcbiAgICBQb3B1cENvbXBvbmVudCxcbiAgICBTdXBwcmVzc0tleWJvYXJkRXZlbnRQYXJhbXNcbn0gZnJvbSAnYWctZ3JpZC1jb21tdW5pdHknO1xuXG5pbXBvcnQgJy4vYWctZ3JpZC1hdXRvY29tcGxldGUtZWRpdG9yLnNjc3MnO1xuLy8gVGhpcyBpbXBvcnQgbXVzdCBiZSBkb25lIHdpdGggcmVxdWlyZSBiZWNhdXNlIG9mIFR5cGVTY3JpcHQgdHJhbnNwaWxlciBwcm9ibGVtcyB3aXRoIGV4cG9ydCBkZWZhdWx0XG5pbXBvcnQgYXV0b2NvbXBsZXRlLCB7QXV0b2NvbXBsZXRlSXRlbSwgRXZlbnRUcmlnZ2VyfSBmcm9tICcuL2F1dG9jb21wbGV0ZXIvYXV0b2NvbXBsZXRlJztcblxuZXhwb3J0IGludGVyZmFjZSBEYXRhRm9ybWF0IGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbSB7XG4gICAgdmFsdWU6IG51bWJlciB8IHN0cmluZztcbiAgICBsYWJlbDogc3RyaW5nO1xuICAgIGdyb3VwPzogc3RyaW5nO1xufVxuXG5leHBvcnQgdHlwZSBBdXRvY29tcGxldGVDbGllbnQgPSBEYXRhRm9ybWF0ICYgQXV0b2NvbXBsZXRlSXRlbTtcblxuaW50ZXJmYWNlIElEZWZhdWx0QXV0b2NvbXBsZXRlclNldHRpbmdzPFQgZXh0ZW5kcyBBdXRvY29tcGxldGVJdGVtPiB7XG4gICAgcmVuZGVyOiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaXRlbTogVCwgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkO1xuICAgIHJlbmRlckdyb3VwOiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgbmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgY2xhc3NOYW1lOiBzdHJpbmc7XG4gICAgbWluTGVuZ3RoOiBudW1iZXI7XG4gICAgZW1wdHlNc2c6IHN0cmluZztcbiAgICBzdHJpY3Q6IGJvb2xlYW47XG4gICAgYXV0b3NlbGVjdGZpcnN0OiBib29sZWFuO1xuICAgIG9uRnJlZVRleHRTZWxlY3Q6IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBULCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcbiAgICBvblNlbGVjdDogKGNlbGxFZGl0b3I6IEF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3IsIGl0ZW06IFQgfCB1bmRlZmluZWQsIGlucHV0OiBIVE1MSW5wdXRFbGVtZW50KSA9PiB2b2lkO1xuICAgIGZldGNoOiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgdGV4dDogc3RyaW5nLCB1cGRhdGU6IChpdGVtczogVFtdIHwgZmFsc2UpID0+IHZvaWQsIHRyaWdnZXI/OiBFdmVudFRyaWdnZXIpID0+IHZvaWQ7XG4gICAgZGVib3VuY2VXYWl0TXM6IG51bWJlcjtcbiAgICBzaG93T25Gb2N1czogYm9vbGVhbjtcbiAgICBjdXN0b21pemU6IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpbnB1dDogSFRNTElucHV0RWxlbWVudCwgaW5wdXRSZWN0OiBDbGllbnRSZWN0IHwgRE9NUmVjdCwgY29udGFpbmVyOiBIVE1MRGl2RWxlbWVudCwgbWF4SGVpZ2h0OiBudW1iZXIpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUF1dG9jb21wbGV0ZXJTZXR0aW5nczxUIGV4dGVuZHMgQXV0b2NvbXBsZXRlSXRlbT4ge1xuICAgIHJlbmRlcj86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBULCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgcmVuZGVyR3JvdXA/OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgbmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWQ7XG4gICAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICAgIG1pbkxlbmd0aD86IG51bWJlcjtcbiAgICBlbXB0eU1zZz86IHN0cmluZztcbiAgICBzdHJpY3Q/OiBib29sZWFuO1xuICAgIGF1dG9zZWxlY3RmaXJzdD86IGJvb2xlYW47XG4gICAgb25GcmVlVGV4dFNlbGVjdD86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBULCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcbiAgICBvblNlbGVjdD86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCBpdGVtOiBUIHwgdW5kZWZpbmVkLCBpbnB1dDogSFRNTElucHV0RWxlbWVudCkgPT4gdm9pZDtcbiAgICBmZXRjaD86IChjZWxsRWRpdG9yOiBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yLCB0ZXh0OiBzdHJpbmcsIHVwZGF0ZTogKGl0ZW1zOiBUW10gfCBmYWxzZSkgPT4gdm9pZCwgdHJpZ2dlcj86IEV2ZW50VHJpZ2dlcikgPT4gdm9pZDtcbiAgICBkZWJvdW5jZVdhaXRNcz86IG51bWJlcjtcbiAgICBjdXN0b21pemU/OiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIGlucHV0UmVjdDogQ2xpZW50UmVjdCB8IERPTVJlY3QsIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIG1heEhlaWdodDogbnVtYmVyKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yUGFyYW1zIGV4dGVuZHMgSUNlbGxFZGl0b3JQYXJhbXMge1xuICAgIGF1dG9jb21wbGV0ZT86IElBdXRvY29tcGxldGVyU2V0dGluZ3M8QXV0b2NvbXBsZXRlQ2xpZW50PjtcbiAgICBzZWxlY3REYXRhOiBBcnJheTxEYXRhRm9ybWF0PjtcbiAgICBwbGFjZWhvbGRlcj86IHN0cmluZztcbiAgICByZXF1aXJlZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBjbGFzcyBBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yIGV4dGVuZHMgUG9wdXBDb21wb25lbnQgaW1wbGVtZW50cyBJQ2VsbEVkaXRvckNvbXAge1xuICAgIHByaXZhdGUgZm9jdXNBZnRlckF0dGFjaGVkOiBib29sZWFuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSByZWFkb25seSBlSW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgcHVibGljIGN1cnJlbnRJdGVtPzogRGF0YUZvcm1hdDtcbiAgICBwcml2YXRlIGF1dG9jb21wbGV0ZXI/OiBhbnk7XG4gICAgcHJpdmF0ZSByZXF1aXJlZDogYm9vbGVhbiA9IGZhbHNlO1xuICAgIHByaXZhdGUgc3RvcEVkaXRpbmc/OiAoY2FuY2VsPzogYm9vbGVhbikgPT4gdm9pZDtcblxuICAgIEBBdXRvd2lyZWQoJ2dyaWRPcHRpb25zV3JhcHBlcicpIHByaXZhdGUgZ3JpZE9wdGlvbnNXcmFwcGVyPzogR3JpZE9wdGlvbnNXcmFwcGVyO1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCc8ZGl2IGNsYXNzPVwiYWctY2VsbC1lZGl0LWlucHV0XCIgc3R5bGU9XCJwYWRkaW5nOiAwICFpbXBvcnRhbnQ7XCI+PGlucHV0IGNsYXNzPVwiYWctY2VsbC1lZGl0LWlucHV0XCIgdHlwZT1cInRleHRcIi8+PC9kaXY+Jyk7XG4gICAgICAgIHRoaXMuZUlucHV0ID0gdGhpcy5nZXRHdWkoKS5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpIGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRJdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmVJbnB1dC52YWx1ZSA9IHRoaXMuY3VycmVudEl0ZW0ubGFiZWwgfHwgdGhpcy5jdXJyZW50SXRlbS52YWx1ZSBhcyBzdHJpbmc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJpdmF0ZSBzdGF0aWMgc3VwcHJlc3NLZXlib2FyZEV2ZW50KHBhcmFtczogU3VwcHJlc3NLZXlib2FyZEV2ZW50UGFyYW1zKTogYm9vbGVhbiB7XG4gICAgICAgIGxldCBrZXlDb2RlID0gcGFyYW1zLmV2ZW50LmtleUNvZGU7XG4gICAgICAgIHJldHVybiBwYXJhbXMuZWRpdGluZyAmJiAoa2V5Q29kZSA9PT0gQ29uc3RhbnRzLktFWV9VUCB8fCBrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX0RPV04gfHwga2V5Q29kZSA9PT0gQ29uc3RhbnRzLktFWV9FTlRFUiB8fCBrZXlDb2RlID09PSBDb25zdGFudHMuS0VZX1RBQik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGF0aWMgZ2V0U3RhcnRWYWx1ZShwYXJhbXM6IElBdXRvY29tcGxldGVTZWxlY3RDZWxsRWRpdG9yUGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGtleVByZXNzQmFja3NwYWNlT3JEZWxldGUgPSBwYXJhbXMua2V5UHJlc3MgPT09IENvbnN0YW50cy5LRVlfQkFDS1NQQUNFIHx8IHBhcmFtcy5rZXlQcmVzcyA9PT0gQ29uc3RhbnRzLktFWV9ERUxFVEU7XG4gICAgICAgIGlmIChrZXlQcmVzc0JhY2tzcGFjZU9yRGVsZXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAocGFyYW1zLmNoYXJQcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcy5jaGFyUHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5mb3JtYXRWYWx1ZShwYXJhbXMudmFsdWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBpbml0KHBhcmFtczogSUF1dG9jb21wbGV0ZVNlbGVjdENlbGxFZGl0b3JQYXJhbXMpIHtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZyA9IHBhcmFtcy5zdG9wRWRpdGluZztcbiAgICAgICAgY29uc3QgZGVmYXVsdFNldHRpbmdzOiBJRGVmYXVsdEF1dG9jb21wbGV0ZXJTZXR0aW5nczxBdXRvY29tcGxldGVDbGllbnQ+ID0ge1xuICAgICAgICAgICAgc2hvd09uRm9jdXM6IGZhbHNlLFxuICAgICAgICAgICAgcmVuZGVyOiBmdW5jdGlvbiAoY2VsbEVkaXRvcjogQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvciwgaXRlbTogQXV0b2NvbXBsZXRlQ2xpZW50LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgbGV0IHJlZ2V4ID0gbmV3IFJlZ0V4cCh2YWx1ZSwgJ2dpJyk7XG4gICAgICAgICAgICAgICAgbGV0IGZpZWxkSXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICBmaWVsZEl0ZW0uaW5uZXJIVE1MID0gaXRlbS5sYWJlbC5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbiAobWF0Y2g6IHN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCI8c3Ryb25nPlwiICsgbWF0Y2ggKyBcIjwvc3Ryb25nPlwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaXRlbUVsZW1lbnQuYXBwZW5kQ2hpbGQoZmllbGRJdGVtKTtcbiAgICAgICAgICAgICAgICBjZWxsRWRpdG9yLmFkZERlc3Ryb3lhYmxlRXZlbnRMaXN0ZW5lcihpdGVtRWxlbWVudCwgJ21vdXNlZG93bicsIChldmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjZWxsRWRpdG9yLmN1cnJlbnRJdGVtID0gaXRlbTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1FbGVtZW50O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlckdyb3VwOiBmdW5jdGlvbiAoY2VsbEVkaXRvciwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBkaXYudGV4dENvbnRlbnQgPSBuYW1lO1xuICAgICAgICAgICAgICAgIGRpdi5jbGFzc05hbWUgPSBcImdyb3VwXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhZy1jZWxsLWVkaXRvci1hdXRvY29tcGxldGUnLFxuICAgICAgICAgICAgbWluTGVuZ3RoOiAxLFxuICAgICAgICAgICAgZW1wdHlNc2c6IFwiTm9uZVwiLFxuICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgYXV0b3NlbGVjdGZpcnN0OiB0cnVlLFxuICAgICAgICAgICAgb25GcmVlVGV4dFNlbGVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uU2VsZWN0OiBmdW5jdGlvbiAoY2VsbEVkaXRvciwgaXRlbTogQXV0b2NvbXBsZXRlQ2xpZW50IHwgdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2VsbEVkaXRvci5jdXJyZW50SXRlbSA9IGl0ZW07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmV0Y2g6IChjZWxsRWRpdG9yLCB0ZXh0LCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBpdGVtcyA9IHBhcmFtcy5zZWxlY3REYXRhIHx8IFtdO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRleHQudG9Mb3dlckNhc2UoKSB8fCBjZWxsRWRpdG9yLmVJbnB1dC52YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGl0ZW1zLmZpbHRlcihmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5sYWJlbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YobWF0Y2gpICE9PSAtMTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVib3VuY2VXYWl0TXM6IDIwMCxcbiAgICAgICAgICAgIGN1c3RvbWl6ZTogZnVuY3Rpb24gKGNlbGxFZGl0b3IsIGlucHV0LCBpbnB1dFJlY3QsIGNvbnRhaW5lciwgbWF4SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heEhlaWdodCA8IDEwMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXIuc3R5bGUudG9wID0gXCIxMHB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3R0b20gPSAod2luZG93LmlubmVySGVpZ2h0IC0gaW5wdXRSZWN0LmJvdHRvbSArIGlucHV0Lm9mZnNldEhlaWdodCkgKyBcInB4XCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5tYXhIZWlnaHQgPSBcIjE0MHB4XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmZvY3VzQWZ0ZXJBdHRhY2hlZCA9IHBhcmFtcy5jZWxsU3RhcnRlZEVkaXQ7XG5cbiAgICAgICAgdGhpcy5lSW5wdXQucGxhY2Vob2xkZXIgPSBwYXJhbXMucGxhY2Vob2xkZXIgfHwgJyc7XG4gICAgICAgIHRoaXMuZUlucHV0LnZhbHVlID0gQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvci5nZXRTdGFydFZhbHVlKHBhcmFtcyk7XG5cbiAgICAgICAgY29uc3QgYXV0b2NvbXBsZXRlUGFyYW1zID0gey4uLmRlZmF1bHRTZXR0aW5ncywgLi4ucGFyYW1zLmF1dG9jb21wbGV0ZX07XG5cbiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVyID0gYXV0b2NvbXBsZXRlKHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLmVJbnB1dCxcbiAgICAgICAgICAgIHJlbmRlcjogKGl0ZW06IEF1dG9jb21wbGV0ZUNsaWVudCwgY3VycmVudFZhbHVlOiBzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUGFyYW1zLnJlbmRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUGFyYW1zLnJlbmRlcih0aGlzLCBpdGVtLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzLnJlbmRlcih0aGlzLCBpdGVtLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbmRlckdyb3VwOiAobmFtZTogc3RyaW5nLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdXRvY29tcGxldGVQYXJhbXMucmVuZGVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9jb21wbGV0ZVBhcmFtcy5yZW5kZXJHcm91cCh0aGlzLCBuYW1lLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzLnJlbmRlckdyb3VwKHRoaXMsIG5hbWUsIGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBhdXRvY29tcGxldGVQYXJhbXMuY2xhc3NOYW1lIHx8IGRlZmF1bHRTZXR0aW5ncy5jbGFzc05hbWUsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IGF1dG9jb21wbGV0ZVBhcmFtcy5taW5MZW5ndGggIT09IHVuZGVmaW5lZCA/IGF1dG9jb21wbGV0ZVBhcmFtcy5taW5MZW5ndGggOiBkZWZhdWx0U2V0dGluZ3MubWluTGVuZ3RoLFxuICAgICAgICAgICAgZW1wdHlNc2c6IGF1dG9jb21wbGV0ZVBhcmFtcy5lbXB0eU1zZyB8fCBkZWZhdWx0U2V0dGluZ3MuZW1wdHlNc2csXG4gICAgICAgICAgICBzdHJpY3Q6IGF1dG9jb21wbGV0ZVBhcmFtcy5zdHJpY3QsXG4gICAgICAgICAgICBhdXRvc2VsZWN0Zmlyc3Q6IGF1dG9jb21wbGV0ZVBhcmFtcy5hdXRvc2VsZWN0Zmlyc3QsXG4gICAgICAgICAgICBzaG93T25Gb2N1czogYXV0b2NvbXBsZXRlUGFyYW1zLnNob3dPbkZvY3VzLFxuICAgICAgICAgICAgb25GcmVlVGV4dFNlbGVjdDogKGl0ZW06IEF1dG9jb21wbGV0ZUNsaWVudCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUGFyYW1zLm9uRnJlZVRleHRTZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9jb21wbGV0ZVBhcmFtcy5vbkZyZWVUZXh0U2VsZWN0KHRoaXMsIGl0ZW0sIGlucHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZXR0aW5ncy5vbkZyZWVUZXh0U2VsZWN0KHRoaXMsIGl0ZW0sIGlucHV0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblNlbGVjdDogKGl0ZW06IEF1dG9jb21wbGV0ZUNsaWVudCB8IHVuZGVmaW5lZCwgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIGV2ZW50OiBLZXlib2FyZEV2ZW50IHwgTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ6IGFueTtcbiAgICAgICAgICAgICAgICBpZiAoYXV0b2NvbXBsZXRlUGFyYW1zLm9uU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGF1dG9jb21wbGV0ZVBhcmFtcy5vblNlbGVjdCh0aGlzLCBpdGVtLCBpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVGFiRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZGVmYXVsdFNldHRpbmdzLm9uU2VsZWN0KHRoaXMsIGl0ZW0sIGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVGFiRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZldGNoOiAodGV4dDogc3RyaW5nLCB1cGRhdGU6IChpdGVtczogQXV0b2NvbXBsZXRlQ2xpZW50W10gfCBmYWxzZSkgPT4gdm9pZCwgdHJpZ2dlcjogRXZlbnRUcmlnZ2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5mZXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0b2NvbXBsZXRlUGFyYW1zLmZldGNoKHRoaXMsIHRleHQsIHVwZGF0ZSwgdHJpZ2dlcilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTZXR0aW5ncy5mZXRjaCh0aGlzLCB0ZXh0LCB1cGRhdGUsIHRyaWdnZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlYm91bmNlV2FpdE1zOiBhdXRvY29tcGxldGVQYXJhbXMuZGVib3VuY2VXYWl0TXMgfHwgZGVmYXVsdFNldHRpbmdzLmRlYm91bmNlV2FpdE1zLFxuICAgICAgICAgICAgY3VzdG9taXplOiAoaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQsIGlucHV0UmVjdDogQ2xpZW50UmVjdCB8IERPTVJlY3QsIGNvbnRhaW5lcjogSFRNTERpdkVsZW1lbnQsIG1heEhlaWdodDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGF1dG9jb21wbGV0ZVBhcmFtcy5jdXN0b21pemUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF1dG9jb21wbGV0ZVBhcmFtcy5jdXN0b21pemUodGhpcywgaW5wdXQsIGlucHV0UmVjdCwgY29udGFpbmVyLCBtYXhIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFNldHRpbmdzLmN1c3RvbWl6ZSh0aGlzLCBpbnB1dCwgaW5wdXRSZWN0LCBjb250YWluZXIsIG1heEhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChwYXJhbXMucmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zLmNvbERlZi5zdXBwcmVzc0tleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5jb2xEZWYuc3VwcHJlc3NLZXlib2FyZEV2ZW50ID0gQXV0b2NvbXBsZXRlU2VsZWN0Q2VsbEVkaXRvci5zdXBwcmVzc0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVUYWJFdmVudChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBjb25zdCBrZXlDb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZSB8fCAwO1xuICAgICAgICBpZiAoa2V5Q29kZSA9PT0gQ29uc3RhbnRzLktFWV9UQUIgJiYgdGhpcy5ncmlkT3B0aW9uc1dyYXBwZXIpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZE9wdGlvbnNXcmFwcGVyLmdldEFwaSgpIS50YWJUb1ByZXZpb3VzQ2VsbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWRPcHRpb25zV3JhcHBlci5nZXRBcGkoKSEudGFiVG9OZXh0Q2VsbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZnRlckd1aUF0dGFjaGVkKHBhcmFtcz86IElBZnRlckd1aUF0dGFjaGVkUGFyYW1zKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5mb2N1c0FmdGVyQXR0YWNoZWQpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgY29uc3QgZUlucHV0ID0gdGhpcy5lSW5wdXQ7XG4gICAgICAgIGVJbnB1dC5mb2N1cygpO1xuICAgICAgICBlSW5wdXQuc2VsZWN0KCk7XG4gICAgICAgIC8vIHdoZW4gd2Ugc3RhcnRlZCBlZGl0aW5nLCB3ZSB3YW50IHRoZSBjYXJldCBhdCB0aGUgZW5kLCBub3QgdGhlIHN0YXJ0LlxuICAgICAgICAvLyB0aGlzIGNvbWVzIGludG8gcGxheSBpbiB0d28gc2NlbmFyaW9zOiBhKSB3aGVuIHVzZXIgaGl0cyBGMiBhbmQgYilcbiAgICAgICAgLy8gd2hlbiB1c2VyIGhpdHMgYSBwcmludGFibGUgY2hhcmFjdGVyLCB0aGVuIG9uIElFIChhbmQgb25seSBJRSkgdGhlIGNhcmV0XG4gICAgICAgIC8vIHdhcyBwbGFjZWQgYWZ0ZXIgdGhlIGZpcnN0IGNoYXJhY3RlciwgdGh1cyAnYXBwbHknIHdvdWxkIGVuZCB1cCBhcyAncHBsZWEnXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVJbnB1dC52YWx1ZSA/IGVJbnB1dC52YWx1ZS5sZW5ndGggOiAwO1xuICAgICAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZUlucHV0LnNldFNlbGVjdGlvblJhbmdlKGxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzSW4oKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZUlucHV0LmZvY3VzKCk7XG4gICAgICAgIHRoaXMuZUlucHV0LnNlbGVjdCgpO1xuICAgIH1cblxuICAgIGZvY3VzT3V0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmVJbnB1dC5ibHVyKCk7XG4gICAgICAgIHRoaXMuYXV0b2NvbXBsZXRlci5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5mb2N1c091dCgpO1xuICAgICAgICBpZiAodGhpcy5zdG9wRWRpdGluZykge1xuICAgICAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VmFsdWUoKTogRGF0YUZvcm1hdCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRJdGVtO1xuICAgIH1cblxuICAgIGlzQ2FuY2VsQWZ0ZXJFbmQoKTogYm9vbGVhbiB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuY3VycmVudEl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpc0NhbmNlbEJlZm9yZVN0YXJ0KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaXNQb3B1cCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7Ozs7QUFJQTtBQTBEQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOztBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4ZEE7QUFXQTtBQUNBO0FBQ0E7QUFnREE7QUFBQTtBQVVBO0FBQUE7QUFUQTtBQUlBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQW5OQTtBQUFBO0FBQUE7QUFvTkE7QUFBQTtBQTVOQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')}])});