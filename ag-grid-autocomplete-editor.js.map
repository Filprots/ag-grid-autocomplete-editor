{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///external \"ag-grid-community\"","webpack:///./autocompleter/autocomplete.ts","webpack:///./ag-grid-autocomplete-editor.ts"],"names":["root","factory","exports","module","require","define","amd","a","i","window","__WEBPACK_EXTERNAL_MODULE__0__","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","autocomplete","settings","selected","debounceTimer","doc","document","container","createElement","containerStyle","style","userAgent","navigator","mobileFirefox","indexOf","debounceWaitMs","strict","autoselectfirst","onFreeTextSelect","keyUpEventName","items","inputValue","minLen","undefined","minLength","showOnFocus","keypressCounter","input","Error","clearDebounceTimer","clearTimeout","containerDisplayed","parentNode","clear","parent","removeChild","update","firstChild","render","item","currentValue","itemElement","textContent","label","renderGroup","groupName","groupDiv","fragment","createDocumentFragment","prevGroup","forEach","group","className","appendChild","div","addEventListener","ev","onSelect","preventDefault","stopPropagation","length","emptyMsg","empty","body","height","width","offsetWidth","inputRect","getBoundingClientRect","top","offsetHeight","maxHeight","innerHeight","bottom","left","customize","updatePosition","elements","getElementsByClassName","element","previous","previousElementSibling","offsetTop","scrollTop","selectBottom","containerBottom","updateScroll","updateIfDisplayed","resizeEventHandler","scrollEventHandler","e","target","keyupEventHandler","keyCode","which","startFetch","keydownEventHandler","containerIsDisplayed","selectPrev","selectNext","freeTextSelect","focusEventHandler","trigger","savedKeypressCounter","val","setTimeout","fetch","blurEventHandler","activeElement","position","destroy","removeEventListener","focusAfterAttached","required","eInput","getGui","querySelector","currentItem","suppressKeyboardEvent","params","event","editing","KEY_UP","KEY_DOWN","KEY_ENTER","KEY_TAB","getStartValue","keyPress","KEY_BACKSPACE","KEY_DELETE","charPress","formatValue","init","this","stopEditing","defaultSettings","cellEditor","regex","RegExp","fieldItem","innerHTML","replace","match","addDestroyableEventListener","text","callback","getSelectData","toLowerCase","filter","cellStartedEdit","placeholder","AutocompleteSelectCellEditor","autocompleteParams","autocompleter","result","KeyboardEvent","handleTabEvent","colDef","gridOptionsWrapper","shiftKey","getApi","tabToPreviousCell","tabToNextCell","afterGuiAttached","focus","select","setSelectionRange","focusIn","focusOut","blur","getValue","isCancelAfterEnd","isCancelBeforeStart","isPopup","selectData","Array","isArray"],"mappings":"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","file":"ag-grid-autocomplete-editor.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"ag-grid-community\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"ag-grid-community\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"ag-grid-community\")) : factory(root[\"ag-grid-community\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function(__WEBPACK_EXTERNAL_MODULE__0__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"http://localhost:8080/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;"," /*\n  * https://github.com/kraaden/autocomplete\n  * Copyright (c) 2016 Denys Krasnoshchok\n  * MIT License\n  */\n\n export const enum EventTrigger {\n     Keyboard = 0,\n     Focus = 1\n }\n\nexport interface AutocompleteItem {\n    label?: string;\n    group?: string;\n}\n\nexport interface AutocompleteSettings<T extends AutocompleteItem> {\n    input: HTMLInputElement;\n    render?: (item: T, currentValue: string) => HTMLDivElement | undefined;\n    renderGroup?: (name: string, currentValue: string) => HTMLDivElement | undefined;\n    className?: string;\n    minLength?: number;\n    emptyMsg?: string;\n    strict: boolean;\n    autoselectfirst: boolean;\n    onFreeTextSelect?: (item: T, input: HTMLInputElement) => void;\n    onSelect: (item: T | undefined, input: HTMLInputElement, event: KeyboardEvent | MouseEvent) => void;\n    /**\n     * Show autocomplete on focus event. Focus event will ignore the `minLength` property and will always call `fetch`.\n     */\n    showOnFocus?: boolean;\n    fetch: (text: string, update: (items: T[] | false) => void, trigger: EventTrigger) => void;\n    debounceWaitMs?: number;\n    /**\n     * Callback for additional autocomplete customization\n     * @param {HTMLInputElement} input - input box associated with autocomplete\n     * @param {ClientRect | DOMRect} inputRect - size of the input box and its position relative to the viewport\n     * @param {HTMLDivElement} container - container with suggestions\n     * @param {number} maxHeight - max height that can be used by autocomplete\n     */\n    customize?: (input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\n}\n\nexport interface AutocompleteResult {\n    destroy: () => void;\n}\n\nconst enum Keys {\n    Enter = 13,\n    Esc = 27,\n    Up = 38,\n    Down = 40,\n    Left = 37,\n    Right = 39,\n    Shift = 16,\n    Ctrl = 17,\n    Alt = 18,\n    CapsLock = 20,\n    WindowsKey = 91,\n    Tab = 9\n}\n\nexport default function autocomplete<T extends AutocompleteItem>(settings: AutocompleteSettings<T>): AutocompleteResult {\n\n    // just an alias to minimize JS file size\n    const doc = document;\n\n    const container: HTMLDivElement = doc.createElement(\"div\");\n    const containerStyle = container.style;\n    const userAgent = navigator.userAgent;\n    const mobileFirefox = userAgent.indexOf(\"Firefox\") !== -1 && userAgent.indexOf(\"Mobile\") !== -1;\n    const debounceWaitMs = settings.debounceWaitMs || 0;\n    const strict = settings.strict;\n    const autoselectfirst = settings.autoselectfirst;\n    const onFreeTextSelect = settings.onFreeTextSelect;\n\n    // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\n    const keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\n\n    let items: T[] = [];\n    let inputValue = \"\";\n    const minLen = settings.minLength !== undefined ? settings.minLength : 2;\n    const showOnFocus = settings.showOnFocus;\n    let selected: T | undefined;\n    let keypressCounter = 0;\n    let debounceTimer : number | undefined;\n\n    if (!settings.input) {\n        throw new Error(\"input undefined\");\n    }\n\n    const input: HTMLInputElement = settings.input;\n\n    container.className = \"autocomplete \" + (settings.className || \"\");\n    containerStyle.position = \"fixed\";\n\n    /**\n     * Detach the container from DOM\n     */\n    function detach(): void {\n        const parent = container.parentNode;\n        if (parent) {\n            parent.removeChild(container);\n        }\n    }\n\n    /**\n     * Clear debouncing timer if assigned\n     */\n    function clearDebounceTimer(): void {\n        if (debounceTimer) {\n            window.clearTimeout(debounceTimer);\n        }\n    }\n\n    /**\n     * Attach the container to DOM\n     */\n    function attach(): void {\n        if (!container.parentNode) {\n            doc.body.appendChild(container);\n        }\n    }\n\n    /**\n     * Check if container for autocomplete is displayed\n     */\n\n    function containerDisplayed(): boolean {\n        return !!container.parentNode;\n    }\n\n    /**\n     * Clear autocomplete state and hide container\n     */\n\n    function clear(): void {\n        keypressCounter++;\n        items = [];\n        inputValue = \"\";\n        selected = undefined;\n        detach();\n    }\n\n    /**\n     * Update autocomplete position\n     */\n    function updatePosition(): void {\n        if (!containerDisplayed()) {\n            return;\n        }\n\n        containerStyle.height = \"auto\";\n        containerStyle.width = input.offsetWidth + \"px\";\n\n        const inputRect = input.getBoundingClientRect();\n        const top = inputRect.top + input.offsetHeight;\n        let maxHeight = window.innerHeight - top;\n\n        if (maxHeight < 0) {\n            maxHeight = 0;\n        }\n\n        containerStyle.top = top + \"px\";\n        containerStyle.bottom = \"\";\n        containerStyle.left = inputRect.left + \"px\";\n        containerStyle.maxHeight = maxHeight + \"px\";\n\n        if (settings.customize) {\n            settings.customize(input, inputRect, container, maxHeight);\n        }\n    }\n\n    /**\n     * Redraw the autocomplete div element with suggestions\n     */\n\n    function update(): void {\n\n        // delete all children from autocomplete DOM container\n        while (container.firstChild) {\n            container.removeChild(container.firstChild);\n        }\n\n        // function for rendering autocomplete suggestions\n        // noinspection JSUnusedLocalSymbols\n        let render = function(item: T, currentValue: string): HTMLDivElement | undefined {\n            const itemElement = doc.createElement(\"div\");\n            itemElement.textContent = item.label || \"\";\n            return itemElement;\n        };\n        if (settings.render) {\n            render = settings.render;\n        }\n\n        // function to render autocomplete groups\n        // noinspection JSUnusedLocalSymbols\n        let renderGroup = function(groupName: string, currentValue: string): HTMLDivElement | undefined {\n            const groupDiv = doc.createElement(\"div\");\n            groupDiv.textContent = groupName;\n            return groupDiv;\n        };\n        if (settings.renderGroup) {\n            renderGroup = settings.renderGroup;\n        }\n\n        const fragment = doc.createDocumentFragment();\n        let prevGroup = \"#9?$\";\n\n        items.forEach(function(item: T): void {\n            if (item.group && item.group !== prevGroup) {\n                prevGroup = item.group;\n                const groupDiv = renderGroup(item.group, inputValue);\n                if (groupDiv) {\n                    groupDiv.className += \" group\";\n                    fragment.appendChild(groupDiv);\n                }\n            }\n            const div = render(item, inputValue);\n            if (div) {\n                div.addEventListener(\"click\", function(ev: MouseEvent): void {\n                    settings.onSelect(item, input, ev);\n                    clear();\n                    ev.preventDefault();\n                    ev.stopPropagation();\n                });\n                if (item === selected) {\n                    div.className += \" selected\";\n                }\n                fragment.appendChild(div);\n            }\n        });\n        container.appendChild(fragment);\n        if (items.length < 1 && strict) {\n            if (settings.emptyMsg) {\n                const empty = doc.createElement(\"div\");\n                empty.className = \"empty\";\n                empty.textContent = settings.emptyMsg;\n                container.appendChild(empty);\n                selected = undefined;\n            } else {\n                clear();\n                return;\n            }\n        }\n\n        attach();\n        updatePosition();\n\n        updateScroll();\n    }\n\n    function updateIfDisplayed(): void {\n        if (containerDisplayed()) {\n            update();\n        }\n    }\n\n    function resizeEventHandler(): void {\n        updateIfDisplayed();\n    }\n\n    function scrollEventHandler(e: Event): void {\n        if (e.target !== container) {\n            updateIfDisplayed();\n        } else {\n            e.preventDefault();\n        }\n    }\n\n    function keyupEventHandler(ev: KeyboardEvent): void {\n        const keyCode = ev.which || ev.keyCode || 0;\n\n        const ignore = [Keys.Up, Keys.Enter, Keys.Esc, Keys.Right, Keys.Left, Keys.Shift, Keys.Ctrl, Keys.Alt, Keys.CapsLock, Keys.WindowsKey, Keys.Tab];\n        for (const key of ignore) {\n            if (keyCode === key) {\n                return;\n            }\n        }\n\n        // the down key is used to open autocomplete\n        if (keyCode === Keys.Down && containerDisplayed()) {\n            return;\n        }\n\n        startFetch(EventTrigger.Keyboard);\n    }\n\n    /**\n     * Automatically move scroll bar if selected item is not visible\n     */\n\n    function updateScroll(): void {\n        const elements = container.getElementsByClassName(\"selected\");\n        if (elements.length > 0) {\n            let element = elements[0] as HTMLDivElement;\n\n            // make group visible\n            const previous = element.previousElementSibling as HTMLDivElement;\n            if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\n                element = previous;\n            }\n\n            if (element.offsetTop < container.scrollTop) {\n                container.scrollTop = element.offsetTop;\n            } else {\n                const selectBottom = element.offsetTop + element.offsetHeight;\n                const containerBottom = container.scrollTop + container.offsetHeight;\n                if (selectBottom > containerBottom) {\n                    container.scrollTop += selectBottom - containerBottom;\n                }\n            }\n        }\n    }\n\n    /**\n     * Select the previous item in suggestions\n     */\n\n    function selectPrev(): void {\n        if (items.length < 1) {\n            selected = undefined;\n        } else {\n            if (selected === items[0] || selected === undefined) {\n                selected = items[items.length - 1];\n            } else {\n                for (let i = items.length - 1; i > 0; i--) {\n                    if (selected === items[i] || i === 1) {\n                        selected = items[i - 1];\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Select the next item in suggestions\n     */\n\n    function selectNext(): void {\n        if (items.length < 1) {\n            selected = undefined;\n        }\n        if (!selected || selected === items[items.length - 1]) {\n            selected = items[0];\n            return;\n        }\n        for (let i = 0; i < (items.length - 1); i++) {\n            if (selected === items[i]) {\n                selected = items[i + 1];\n                break;\n            }\n        }\n    }\n\n    function keydownEventHandler(ev: KeyboardEvent): void {\n        const keyCode = ev.which || ev.keyCode || 0;\n\n        if (keyCode === Keys.Up || keyCode === Keys.Down || keyCode === Keys.Esc) {\n            const containerIsDisplayed = containerDisplayed();\n\n            if (keyCode === Keys.Esc) {\n                settings.onSelect(undefined, input, ev);\n                clear();\n            } else {\n                if (!containerDisplayed || items.length < 1) {\n                    return;\n                }\n                keyCode === Keys.Up\n                    ? selectPrev()\n                    : selectNext();\n                update();\n            }\n\n            ev.preventDefault();\n            if (containerIsDisplayed) {\n                ev.stopPropagation();\n            }\n\n            return;\n        }\n\n        if (keyCode === Keys.Enter || keyCode ===  Keys.Tab) {\n            if (strict) {\n                settings.onSelect(selected, input, ev);\n                clear();\n            }\n            if (!strict) {\n                const freeTextSelect = {label: input.value} as T;\n                if (!selected) {\n                    if (onFreeTextSelect) {\n                        onFreeTextSelect(freeTextSelect, input);\n                    }\n                    settings.onSelect(freeTextSelect, input, ev);\n                } else {\n                    settings.onSelect(selected, input, ev);\n                }\n                clear();\n            }\n        }\n    }\n\n    function focusEventHandler(): void {\n        if (showOnFocus) {\n            startFetch(EventTrigger.Focus);\n        }\n    }\n\n    function startFetch(trigger: EventTrigger) {\n        // if multiple keys were pressed, before we get update from server,\n        // this may cause redrawing our autocomplete multiple times after the last key press.\n        // to avoid this, the number of times keyboard was pressed will be\n        // saved and checked before redraw our autocomplete box.\n        const savedKeypressCounter = ++keypressCounter;\n\n        const val = input.value;\n        if (val.length >= minLen || trigger === EventTrigger.Focus) {\n            clearDebounceTimer();\n            debounceTimer = window.setTimeout(function(): void {\n                settings.fetch(val, function(elements: T[] | false): void {\n                    if (keypressCounter === savedKeypressCounter && elements) {\n                        items = elements;\n                        inputValue = val;\n                        selected = items.length > 0 && autoselectfirst ? items[0] : undefined;\n                        update();\n                    }\n                }, EventTrigger.Keyboard);\n            }, trigger === EventTrigger.Keyboard ? debounceWaitMs : 0);\n        } else {\n            clear();\n        }\n    }\n\n    function blurEventHandler(): void {\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\n        setTimeout(() => {\n            if (doc.activeElement !== input) {\n                clear();\n            }\n        }, 200);\n    }\n\n    /**\n     * This function will remove DOM elements and clear event handlers\n     */\n\n    function destroy(): void {\n        input.removeEventListener(\"focus\", focusEventHandler);\n        input.removeEventListener(\"keydown\", keydownEventHandler);\n        input.removeEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\n        input.removeEventListener(\"blur\", blurEventHandler);\n        window.removeEventListener(\"resize\", resizeEventHandler);\n        doc.removeEventListener(\"scroll\", scrollEventHandler, true);\n        clearDebounceTimer();\n        clear();\n\n        // prevent the update call if there are pending AJAX requests\n        keypressCounter++;\n    }\n\n    // setup event handlers\n    input.addEventListener(\"keydown\", keydownEventHandler);\n    input.addEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\n    input.addEventListener(\"blur\", blurEventHandler);\n    input.addEventListener(\"focus\", focusEventHandler);\n    window.addEventListener(\"resize\", resizeEventHandler);\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\n\n    return {\n        destroy\n    };\n}\n","import {\n    Autowired,\n    Constants,\n    GridOptionsWrapper,\n    IAfterGuiAttachedParams,\n    ICellEditorComp,\n    ICellEditorParams,\n    PopupComponent,\n    SuppressKeyboardEventParams\n} from 'ag-grid-community';\n\nimport './ag-grid-autocomplete-editor.scss';\n// This import must be done with require because of TypeScript transpiler problems with export default\nimport autocomplete, {AutocompleteItem, EventTrigger} from './autocompleter/autocomplete';\n\nexport interface DataFormat extends AutocompleteItem {\n    value: number | string;\n    label: string;\n    group?: string;\n}\n\nexport type AutocompleteClient = DataFormat & AutocompleteItem;\n\ninterface IDefaultAutocompleterSettings<T extends AutocompleteItem> {\n    render: (cellEditor: AutocompleteSelectCellEditor, item: T, currentValue: string) => HTMLDivElement | undefined;\n    renderGroup: (cellEditor: AutocompleteSelectCellEditor, name: string, currentValue: string) => HTMLDivElement | undefined;\n    className: string;\n    minLength: number;\n    emptyMsg: string;\n    strict: boolean;\n    autoselectfirst: boolean;\n    onFreeTextSelect: (cellEditor: AutocompleteSelectCellEditor, item: T, input: HTMLInputElement) => void;\n    onSelect: (cellEditor: AutocompleteSelectCellEditor, item: T | undefined, input: HTMLInputElement) => void;\n    fetch: (cellEditor: AutocompleteSelectCellEditor, text: string, update: (items: T[] | false) => void, trigger?: EventTrigger) => void;\n    debounceWaitMs: number;\n    showOnFocus: boolean;\n    customize: (cellEditor: AutocompleteSelectCellEditor, input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\n}\n\nexport interface IAutocompleterSettings<T extends AutocompleteItem> {\n    render?: (cellEditor: AutocompleteSelectCellEditor, item: T, currentValue: string) => HTMLDivElement | undefined;\n    renderGroup?: (cellEditor: AutocompleteSelectCellEditor, name: string, currentValue: string) => HTMLDivElement | undefined;\n    className?: string;\n    minLength?: number;\n    emptyMsg?: string;\n    strict?: boolean;\n    autoselectfirst?: boolean;\n    onFreeTextSelect?: (cellEditor: AutocompleteSelectCellEditor, item: T, input: HTMLInputElement) => void;\n    onSelect?: (cellEditor: AutocompleteSelectCellEditor, item: T | undefined, input: HTMLInputElement) => void;\n    fetch?: (cellEditor: AutocompleteSelectCellEditor, text: string, update: (items: T[] | false) => void, trigger?: EventTrigger) => void;\n    debounceWaitMs?: number;\n    customize?: (cellEditor: AutocompleteSelectCellEditor, input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\n}\n\nexport interface IAutocompleteSelectCellEditorParams extends ICellEditorParams {\n    autocomplete?: IAutocompleterSettings<AutocompleteClient>;\n    selectData: Array<DataFormat> | ((params: IAutocompleteSelectCellEditorParams) => Array<DataFormat>);\n    placeholder?: string;\n    required?: boolean;\n}\n\nexport class AutocompleteSelectCellEditor extends PopupComponent implements ICellEditorComp {\n    private focusAfterAttached: boolean = false;\n    private readonly eInput: HTMLInputElement;\n    public currentItem?: DataFormat;\n    private autocompleter?: any;\n    private required: boolean = false;\n    private stopEditing?: (cancel?: boolean) => void;\n\n    @Autowired('gridOptionsWrapper') private gridOptionsWrapper?: GridOptionsWrapper;\n\n    constructor() {\n        super('<div class=\"ag-cell-edit-input\" style=\"padding: 0 !important;\"><input class=\"ag-cell-edit-input\" type=\"text\"/></div>');\n        this.eInput = this.getGui().querySelector('input') as HTMLInputElement;\n        if (this.currentItem) {\n            this.eInput.value = this.currentItem.label || this.currentItem.value as string;\n        }\n    }\n    private static suppressKeyboardEvent(params: SuppressKeyboardEventParams): boolean {\n        let keyCode = params.event.keyCode;\n        return params.editing && (keyCode === Constants.KEY_UP || keyCode === Constants.KEY_DOWN || keyCode === Constants.KEY_ENTER || keyCode === Constants.KEY_TAB);\n    }\n\n    private static getStartValue(params: IAutocompleteSelectCellEditorParams) {\n        const keyPressBackspaceOrDelete = params.keyPress === Constants.KEY_BACKSPACE || params.keyPress === Constants.KEY_DELETE;\n        if (keyPressBackspaceOrDelete) {\n            return '';\n        } else if (params.charPress) {\n            return params.charPress;\n        }\n        return params.formatValue(params.value);\n    }\n\n    public init(params: IAutocompleteSelectCellEditorParams) {\n        this.stopEditing = params.stopEditing;\n        const defaultSettings: IDefaultAutocompleterSettings<AutocompleteClient> = {\n            showOnFocus: false,\n            render: function (cellEditor: AutocompleteSelectCellEditor, item: AutocompleteClient, value) {\n                let itemElement = document.createElement(\"div\");\n                let regex = new RegExp(value, 'gi');\n                let fieldItem = document.createElement('span');\n                fieldItem.innerHTML = item.label.replace(regex, function (match: string) {\n                    return \"<strong>\" + match + \"</strong>\"\n                });\n                itemElement.appendChild(fieldItem);\n                cellEditor.addDestroyableEventListener(itemElement, 'mousedown', (event: MouseEvent) => {\n                    cellEditor.currentItem = item;\n                    event.stopPropagation();\n                });\n                return itemElement;\n            },\n            renderGroup: function (cellEditor, name) {\n                let div = document.createElement('div');\n                div.textContent = name;\n                div.className = \"group\";\n                return div;\n            },\n            className: 'ag-cell-editor-autocomplete',\n            minLength: 1,\n            emptyMsg: \"None\",\n            strict: true,\n            autoselectfirst: true,\n            onFreeTextSelect: function () {\n            },\n            onSelect: function (cellEditor, item: AutocompleteClient | undefined) {\n                cellEditor.currentItem = item;\n            },\n            fetch: (cellEditor, text, callback) => {\n                let items = this.getSelectData(params);\n                let match = text.toLowerCase() || cellEditor.eInput.value.toLowerCase();\n                callback(items.filter(function (n) {\n                    return n.label.toLowerCase().indexOf(match) !== -1;\n                }));\n            },\n            debounceWaitMs: 200,\n            customize: function (cellEditor, input, inputRect, container, maxHeight) {\n                if (maxHeight < 100) {\n                    container.style.top = \"10px\";\n                    container.style.bottom = (window.innerHeight - inputRect.bottom + input.offsetHeight) + \"px\";\n                    container.style.maxHeight = \"140px\";\n                }\n            }\n        };\n        this.focusAfterAttached = params.cellStartedEdit;\n\n        this.eInput.placeholder = params.placeholder || '';\n        this.eInput.value = AutocompleteSelectCellEditor.getStartValue(params);\n\n        const autocompleteParams = {...defaultSettings, ...params.autocomplete};\n\n        this.autocompleter = autocomplete({\n            input: this.eInput,\n            render: (item: AutocompleteClient, currentValue: string) => {\n                if (autocompleteParams.render) {\n                    return autocompleteParams.render(this, item, currentValue);\n                }\n                return defaultSettings.render(this, item, currentValue);\n            },\n            renderGroup: (name: string, currentValue: string) => {\n                if (autocompleteParams.renderGroup) {\n                    return autocompleteParams.renderGroup(this, name, currentValue);\n                }\n                return defaultSettings.renderGroup(this, name, currentValue);\n            },\n            className: autocompleteParams.className || defaultSettings.className,\n            minLength: autocompleteParams.minLength !== undefined ? autocompleteParams.minLength : defaultSettings.minLength,\n            emptyMsg: autocompleteParams.emptyMsg || defaultSettings.emptyMsg,\n            strict: autocompleteParams.strict,\n            autoselectfirst: autocompleteParams.autoselectfirst,\n            showOnFocus: autocompleteParams.showOnFocus,\n            onFreeTextSelect: (item: AutocompleteClient, input: HTMLInputElement) => {\n                if (autocompleteParams.onFreeTextSelect) {\n                    return autocompleteParams.onFreeTextSelect(this, item, input);\n                }\n                return defaultSettings.onFreeTextSelect(this, item, input);\n            },\n            onSelect: (item: AutocompleteClient | undefined, input: HTMLInputElement, event: KeyboardEvent | MouseEvent) => {\n                let result: any;\n                if (autocompleteParams.onSelect) {\n                    result = autocompleteParams.onSelect(this, item, input);\n                    if (event instanceof KeyboardEvent) {\n                        this.handleTabEvent(event);\n                    } else {\n                        this.destroy();\n                    }\n                    return result;\n                }\n                result = defaultSettings.onSelect(this, item, input);\n                if (event instanceof KeyboardEvent) {\n                    this.handleTabEvent(event);\n                } else {\n                    this.destroy();\n                }\n                return result;\n            },\n            fetch: (text: string, update: (items: AutocompleteClient[] | false) => void, trigger: EventTrigger) => {\n                if (autocompleteParams.fetch) {\n                    return autocompleteParams.fetch(this, text, update, trigger)\n                }\n                return defaultSettings.fetch(this, text, update, trigger);\n            },\n            debounceWaitMs: autocompleteParams.debounceWaitMs || defaultSettings.debounceWaitMs,\n            customize: (input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => {\n                if (autocompleteParams.customize) {\n                    return autocompleteParams.customize(this, input, inputRect, container, maxHeight);\n                }\n                return defaultSettings.customize(this, input, inputRect, container, maxHeight);\n            }\n        });\n\n        if (params.required) {\n            this.required = true;\n        }\n        if (!params.colDef.suppressKeyboardEvent) {\n            params.colDef.suppressKeyboardEvent = AutocompleteSelectCellEditor.suppressKeyboardEvent;\n        }\n    }\n\n    handleTabEvent(event: KeyboardEvent) {\n        const keyCode = event.which || event.keyCode || 0;\n        if (keyCode === Constants.KEY_TAB && this.gridOptionsWrapper) {\n            if (event.shiftKey) {\n                this.gridOptionsWrapper.getApi()!.tabToPreviousCell();\n            } else {\n                this.gridOptionsWrapper.getApi()!.tabToNextCell();\n            }\n        } else {\n            this.destroy();\n        }\n    }\n\n    afterGuiAttached(params?: IAfterGuiAttachedParams): void {\n        if (!this.focusAfterAttached) { return; }\n\n        const eInput = this.eInput;\n        eInput.focus();\n        eInput.select();\n        // when we started editing, we want the caret at the end, not the start.\n        // this comes into play in two scenarios: a) when user hits F2 and b)\n        // when user hits a printable character, then on IE (and only IE) the caret\n        // was placed after the first character, thus 'apply' would end up as 'pplea'\n        const length = eInput.value ? eInput.value.length : 0;\n        if (length > 0) {\n            eInput.setSelectionRange(length, length);\n        }\n    }\n\n    focusIn(): void {\n        this.eInput.focus();\n        this.eInput.select();\n    }\n\n    focusOut(): void {\n        this.eInput.blur();\n        this.autocompleter.destroy();\n    }\n\n    destroy(): void {\n        this.focusOut();\n        if (this.stopEditing) {\n            this.stopEditing();\n        }\n    }\n\n    getValue(): DataFormat | undefined {\n        return this.currentItem;\n    }\n\n    isCancelAfterEnd(): boolean {\n        if (this.required) {\n            return !this.currentItem;\n        }\n        return false;\n    }\n    isCancelBeforeStart(): boolean {\n        return false;\n    }\n\n    isPopup(): boolean {\n        return false;\n    }\n\n    getSelectData(params: IAutocompleteSelectCellEditorParams): Array<DataFormat> {\n        if (typeof params.selectData === 'function') {\n            return params.selectData(params);\n        } \n\n        if (Array.isArray(params.selectData)) {\n            return params.selectData as Array<DataFormat>;\n        }\n\n        return [];\n    }\n}\n"],"sourceRoot":""}